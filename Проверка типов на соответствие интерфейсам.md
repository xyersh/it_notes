

### Проверка на этапе компиляции (Рекомендуемый способ)

 #### Использование нулевого указателя

Создаем переменную-заполнитель типа интерфейса и присвойте ей нулевой указатель на вашу структуру.
```go
var _ InterfaceName = (*StructName)(nil)
```

- `(*StructName)(nil)`: Создаёт **нулевой указатель** на вашу структуру.
- `var _ InterfaceName =`: Пытается присвоить этот нулевой указатель переменной **типа интерфейса** (`InterfaceName`).
Если `StructName` (в виде указателя `*StructName`) не реализует все методы `InterfaceName`, компилятор выдаст ошибку, например: `cannot use (*StructName)(nil) (type *StructName) as type InterfaceName in assignment: *StructName does not implement InterfaceName (missing method X)` (невозможно использовать... поскольку *StructName не реализует InterfaceName (отсутствует метод X)).


#### Использование нулевой структуры (редко используется)

Этот вариант менее распространён, поскольку часто методы интерфейса принимают **указатели** на структуры (`*StructName`) в качестве ресиверов.
```go
var _ InterfaceName = StructName{}
```

- Используйте его, только если **все** методы интерфейса имеют **значение** (`StructName`) в качестве ресивера.


---
### Проверка на этапе выполнения (Утверждение типа)

Мы можем использовать **утверждение типа** (type assertion) или **переключение типов** (type switch) на этапе выполнения. Это полезно, если вы работаете с переменной, тип которой **неизвестен заранее** (например, `interface{}`), и вам нужно проверить, можно ли она интерпретировать как определённый интерфейс.

#### Если имя интерфейса известно
Если у вас есть переменная `x` типа `interface{}`, вы можете проверить:
```go
func checkRuntime(x interface{}) {
    if _, ok := x.(InterfaceName); ok {
        fmt.Println("Переменная имплементирует InterfaceName")
    } else {
        fmt.Println("Переменная не имплементирует InterfaceName")
    }
}
```
- `x.(InterfaceName)`: Пытается преобразовать значение `x` к типу `InterfaceName`.
- `ok`: Булево значение, которое истинно, если преобразование **удалось**.


#### Если имя интерфейса НЕ известно

Если мы не знаем имени интерфейса, и нам собственно оно не нужно. А нужен нам лишь факт реализации структурой конкретной функции. То на помощь на придет следующий код:
```go
if joined, ok := combinedError.(interface{ Unwrap() []error }); ok {
	...
}
```
в данном  примере проверяется факт наличия у переменной `combinedError` реализованной её типом функции с сигнатурой `Unwrap() []error`. 
