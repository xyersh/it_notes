
## Глоссарий
- **Cache miss** - промах кэша, запрошенный ключ не найден в кэше
- **Cache hit** - попадание в кэш, запрошенный ключ найден к кэше 
					(`Hit Ratio + Cache Miss Rate=1`)
- **Hit ratio(rate)** - процент попадания запросов в кэш, характеризует эффективность кэширования
- **throughout** - пропускная способность кэша
- **Горячий ключ** - ключ, на который приходится большая часть запросов
- **Прогрев кэша** - процесс наполнения кэша данными
- **Инвалидация** - удаление кэшированных данных
## Назначение кэшей:
- сокращение responce time сервисов
- сокращение нагрузки на сторонние сервисы
- переиспользование ранее полученных данных
- стабилизация работы приложении при кратковременных отказах систем



## Какие данные кэшировать?

|                                        |                                           |
| -------------------------------------- | ----------------------------------------- |
| Данные часто меняются(секунды)         | нет смысла добавлять такие данные в кэш   |
| Данные меняются нечасто (минуты, часы) | возможно, стоит дабавить эти данные в кэш |
| Меняются редко (дни, недели....)       | можно спокойно кэшировать эти данные      |

Можно кэшировать ошибки. Например, можно кэшировать факт отсутствия пользователя , и далее - просто отбиваться кэшом, а не проходить всякие контроли, как для запросов с валидными данными. 



## Эффективность кэширования


Формула определения среднего времени доступа к кэшу:
```
AverageTime = DBAccessTime *  CacheMissRate + CacheAccessTime
```
Где:
DBAccessTime - время запроса  к БД
CacheMissRate - показатель  промахов кэша
CacheAccessTime - время при обращении к кэшу

Принцип - чем значение у **AverageTime**  меньше **DBAccessTime** - тем лучше

Допустим:
**DBAccessTime** = 100ms
**CacheAccessTime** = 20ms
Тогда при **CacheMissRate** > 0.8 применение кэша будет нецелесообразно. Так как в этом случае **AverageTime** > **DBAccessTime** 


## Фундаментальные принципы эффективности раты кэшей

1. **Пространственная локальность:** Если элемент данных используется, то вероятно, что элементы, расположенные рядом с ним в памяти, также будут использоваться в ближайшее время. Кэши используют это, загружая целые блоки данных (кэш-линии) вместо отдельных элементов.
    
2. **Временная локальность:** Если элемент данных был использован недавно, то велика вероятность, что он будет использован снова в ближайшем будущем. Кэши хранят недавно использованные данные, чтобы их можно было быстро получить.

## Виды кэширования
- **Внутреннее кэширование** - сюда относятся кэши, реализованных в различных структурах самих ЯП, на которых пишется приложение.
	- ### Плюсы:
		- Высокая скорость 
		- Отсутствие сетевых запросов
		- Нет расходов на сериализацию/десериализацию данных
	- ### Минусы
		- Горизонтальное масштабирование затруднительно
		- Прогрев кэша после  падения сервиса
- **Внешнее кэширование** - выделение кэша в отдельный сервис 
	- ### Плюсы
		- Хранение большого объемы данных
		- Простое горизонтальное масштабирование
		- После падения сервиса кэш не теряется
		- Простой прогрев кэша и простая логика инвалидации
	- ### Минусы
		- Скорость работы


## Политики замещения кэша (Cache Replacement Policies)

### LRU (Least Recently Used - Наименее недавно используемый)
- **Принцип:** Удаляет элемент, который не использовался дольше всех.
- **Логика:** Основывается на предположении, что если элемент не использовался в течение длительного времени, то он, скорее всего, не понадобится в ближайшем будущем.
- **Преимущества:** Считается одной из наиболее эффективных политик, так как хорошо использует принцип временной локальности.
- **Недостатки:** Требует отслеживания времени последнего использования для каждого элемента, что может быть вычислительно затратно (например, с помощью счетчиков или связанных списков).

### LFU (Least Frequently Used - Наименее часто используемый) 
- **Принцип:** Удаляет элемент, который использовался наименьшее количество раз.
- **Логика:** Предполагает, что редко используемые элементы менее важны и их можно удалить.
- **Преимущества:** Хорошо подходит для сценариев, где некоторые данные используются очень часто, а другие — очень редко.
- **Недостатки:** Может быть неоптимальной, если элемент был очень популярен в прошлом, но сейчас больше не нужен (например, пик запросов на новость, которая уже устарела). Также требует отслеживания счетчика использования для каждого элемента.

### FIFO (First-In, First-Out - Первый вошел, первый вышел)
- **Принцип:** Удаляет элемент, который был добавлен в кэш первым.
- **Логика:** Работает как очередь — самый старый элемент вытесняется первым.
- **Преимущества:** Проста в реализации.
- **Недостатки:** Не учитывает ни частоту, ни недавность использования. Элемент, который активно используется, но был добавлен давно, может быть вытеснен.

### MRU (Most Recently Used - Наиболее недавно используемый)
- **Принцип:** Удаляет элемент, который использовался совсем недавно.
- **Логика:** Противоположна LRU. В большинстве случаев неэффективна для общего кэширования.
- **Применение:** Может быть полезна в специфических сценариях, например, при циклическом сканировании очень больших наборов данных, где каждый элемент используется только один раз, а затем сразу же вытесняется, чтобы освободить место для следующего.

### Random (Случайный)
- **Принцип:** Случайно выбирает элемент для удаления.
- **Логика:** Отсутствует какая-либо сложная логика предсказания.
- **Преимущества:** Очень проста в реализации.
- **Недостатки:** Неоптимальна, так как не использует принципы локальности, что приводит к низкому коэффициенту попаданий.

### Другие (более сложные или специализированные) политики:
- **ARC (Adaptive Replacement Cache):** Более сложная политика, которая пытается адаптироваться к изменяющимся шаблонам доступа, комбинируя идеи LRU и LFU. Она поддерживает две очереди: одну для недавно использованных элементов и одну для часто используемых.
- **LIRS (Low Inter-reference Recency Set):** Еще более сложная политика, которая фокусируется на "недавности междоступов" (inter-reference recency) для принятия решений о вытеснении.
- **Segmented LRU (SLRU):** Разделяет кэш на сегменты (например, "горячий" и "теплый") и перемещает элементы между ними в зависимости от их использования.



## Способы взаимодействия с кэшом
- **CACHE ASIDE** - кэширование на стороне. Приложение само координирует запросы в кэш и БД и само решает, куда в данный момент обращаться.
 ![[Pasted image 20250516153605.png]]
![[Pasted image 20250516153751.png]] 
- **CACHE THROUGH** - все запросы от приложения улетают в кэш
- Чтение из кэша
	![[Pasted image 20250516155405.png]]
- Запись в кэш ![[Pasted image 20250516161248.png]]
	- 