Двоичная куча (Binary Heap) — это **специализированная абстрактная структура данных на основе дерева или массива**, которая удовлетворяет **свойству кучи**. Она используется для эффективного получения минимального или максимального элемента.

Несмотря на то, что это древовидная структура, ее чаще всего реализуют с помощью **массива**, что делает ее очень эффективной по памяти и скорости доступа.

### Свойства Двоичной Кучи
Чтобы структура данных была двоичной кучей, она должна соответствовать двум основным свойствам:

1. **Свойство формы (Shape Property):** Это **полное двоичное дерево**. Это означает, что все уровни дерева, кроме, возможно, последнего, полностью заполнены, а узлы на последнем уровне смещены как можно левее.
    
2. **Свойство порядка (Heap Property):**
    
    - **Min-Heap (Минимальная куча):** Значение каждого родительского узла **меньше или равно** значению его дочерних узлов. В результате, минимальный элемент всегда находится в корне.
        
    - **Max-Heap (Максимальная куча):** Значение каждого родительского узла **больше или равно** значению его дочерних узлов. В результате, максимальный элемент всегда находится в корне.

### Задачи, решаемые двоичной кучей

Двоичная куча является основой для решения многих важных задач в информатике:

- **Алгоритмы сортировки:** Самый известный пример — **сортировка кучей (Heapsort)**, которая имеет временную сложность O(nlogn).
    
- **Очередь с приоритетом (Priority Queue):** Куча — это наиболее эффективная реализация очереди с приоритетом, где элемент с наивысшим приоритетом (минимальный или максимальный) всегда находится в начале.
    
- **Алгоритмы на графах:** Используется в таких алгоритмах, как **алгоритм Дейкстры** (Dijkstra) для поиска кратчайшего пути и **алгоритм Прима** (Prim) для поиска минимального остовного дерева.


### Методы реализации
Наиболее распространенная и эффективная реализация двоичной кучи — с использованием **массива (Array)**.

- **Как это работает?** Узлы дерева хранятся в массиве по порядку, сверху вниз, слева направо.
    
    - Если узел находится по индексу `i`, то его дочерние узлы будут находиться по индексам `2*i + 1` (левый) и `2*i + 2` (правый).
        
    - Его родительский узел будет находиться по индексу `(i - 1) / 2`.


### Сильные стороны:
- **эффективность по памяти:** Нет необходимости хранить указатели на дочерние и родительские узлы, как в связных структурах.
- **Высокая скорость доступа:** Доступ к элементам по индексу в массиве очень быстрый.
### Слабые стороны:
- **Статический размер:** Если используется статический массив, его размер ограничен.


### Пример
Min-Heap на языке Go включает в себя структуру `MinHeap`, а также методы для добавления элемента (`Insert`), получения и удаления минимального элемента (`ExtractMin`).
```go
package main

import (
	"fmt"
)

// MinHeap - это структура для представления минимальной кучи.
// Она использует срез (slice) для хранения элементов.
type MinHeap struct {
	elements []int
}

// NewMinHeap создает и возвращает новый экземпляр MinHeap.
func NewMinHeap() *MinHeap {
	return &MinHeap{
		elements: []int{},
	}
}

// Insert добавляет новый элемент в кучу, поддерживая свойство кучи.
func (h *MinHeap) Insert(val int) {
	// Добавляем новый элемент в конец.
	h.elements = append(h.elements, val)
	// Восстанавливаем свойство кучи, двигаясь вверх.
	h.heapifyUp(len(h.elements) - 1)
}

// ExtractMin извлекает минимальный элемент (корень кучи).
func (h *MinHeap) ExtractMin() (int, bool) {
	if len(h.elements) == 0 {
		return 0, false
	}
	// Запоминаем корень (минимальный элемент).
	minVal := h.elements[0]
	lastIndex := len(h.elements) - 1
	// Перемещаем последний элемент в корень.
	h.elements[0] = h.elements[lastIndex]
	// Уменьшаем размер кучи.
	h.elements = h.elements[:lastIndex]
	// Восстанавливаем свойство кучи, двигаясь вниз.
	h.heapifyDown(0)
	return minVal, true
}

// heapifyUp перемещает элемент вверх, чтобы восстановить свойство кучи.
func (h *MinHeap) heapifyUp(index int) {
	for index > 0 {
		parentIndex := (index - 1) / 2
		// Если родительский элемент больше дочернего, меняем их местами.
		if h.elements[parentIndex] > h.elements[index] {
			h.swap(parentIndex, index)
			index = parentIndex
		} else {
			break
		}
	}
}

// heapifyDown перемещает элемент вниз, чтобы восстановить свойство кучи.
func (h *MinHeap) heapifyDown(index int) {
	lastIndex := len(h.elements) - 1
	for {
		leftChildIndex := 2*index + 1
		rightChildIndex := 2*index + 2
		smallest := index

		// Находим наименьшего из родителя и его дочерних элементов.
		if leftChildIndex <= lastIndex && h.elements[leftChildIndex] < h.elements[smallest] {
			smallest = leftChildIndex
		}
		if rightChildIndex <= lastIndex && h.elements[rightChildIndex] < h.elements[smallest] {
			smallest = rightChildIndex
		}

		// Если наименьший элемент не родитель, меняем их местами и продолжаем.
		if smallest != index {
			h.swap(index, smallest)
			index = smallest
		} else {
			break
		}
	}
}

// swap меняет местами два элемента в срезе.
func (h *MinHeap) swap(i, j int) {
	h.elements[i], h.elements[j] = h.elements[j], h.elements[i]
}

// main-функция для демонстрации работы кучи.
func main() {
	minHeap := NewMinHeap()
	// Вставляем элементы.
	elements := []int{10, 5, 20, 3, 25, 12, 1}
	for _, val := range elements {
		minHeap.Insert(val)
	}

	fmt.Println("Элементы в куче (неупорядоченно, вид массива):", minHeap.elements)

	// Извлекаем элементы. Они будут извлекаться в отсортированном порядке.
	for {
		minVal, ok := minHeap.ExtractMin()
		if !ok {
			break
		}
		fmt.Printf("Извлечен минимальный элемент: %d\n", minVal)
	}

	fmt.Println("Куча после извлечения всех элементов:", minHeap.elements)
}
```