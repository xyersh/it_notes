
## Важные моменты при использовании хинтов

1. **Синтаксис:** Хинты указываются в виде SQL-комментария сразу после ключевого слова `SELECT`, `UPDATE`, `INSERT` или `DELETE`.
    - **Пример:** `SELECT /*+ FULL(e) */ e.name FROM employees e;`
    - Хинт начинается с `/*+` и заканчивается `*/`.
2. Названия хинтов - регистронезависимы. 
3. **Псевдонимы (Алиасы):** Если вы используете псевдоним (alias) для таблицы, вы **должны** использовать этот псевдоним в хинте. Если вы не используете псевдоним, вы должны использовать фактическое имя таблицы.
4. **Использование:** Хинты следует применять **только в крайнем случае**, когда вы уверены, что оптимизатор выбрал заведомо неоптимальный план, и вы знаете лучший план.


## Таблица наиболее полезных хинтов в Oracle Database

| Категория             | Хинт                                       | Объяснение                                                                                                | Случаи применения                                                                                                                                                                               |
| --------------------- | ------------------------------------------ | --------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Доступ к данным**   | `/*+ FULL(table_alias) */`                 | Принуждает оптимизатор использовать **полное сканирование таблицы (Full Table Scan)**.                    | При работе с большими таблицами, когда требуется обработать **более 5-10%** данных, или если выборка содержит большинство столбцов.                                                             |
|                       | `/*+ INDEX(table_alias index_name) */`     | Принуждает оптимизатор использовать указанный **индекс** для доступа к данным.                            | Когда оптимизатор ошибочно выбирает Full Scan, хотя по статистике и селективности данных выгоднее использовать конкретный индекс (например, для выборки **менее 1-5%** данных).                 |
|                       | `/*+ INDEX_FFS(table_alias index_name) */` | Принуждает использовать **быстрое полное сканирование индекса (Fast Full Index Scan)**.                   | Когда запрос требует только данные из столбцов, включенных в индекс, и нет условия `ORDER BY`, требующего сортировки.                                                                           |
| **Соединение (JOIN)** | `/*+ USE_NL(table_alias) */`               | Принуждает использовать соединение **Nested Loops (Вложенные циклы)**.                                    | Когда одна из соединяемых таблиц очень маленькая, а другая имеет эффективный индекс на столбце соединения. Идеально для **OLTP**.                                                               |
|                       | `/*+ USE_HASH(table_alias) */`             | Принуждает использовать соединение **Hash Join (Хеш-соединение)**.                                        | Идеально для соединения двух **больших** таблиц, когда столбцы соединения не имеют индексов. Используется в **DWH/BI** (OLAP).                                                                  |
|                       | `/*+ USE_MERGE(table_alias) */`            | Принуждает использовать соединение **Sort-Merge Join (Сортировка-Слияние)**.                              | Редко используется, но может быть полезен, когда обе таблицы уже отсортированы по столбцу соединения или требуют сортировки, а для Hash Join не хватает памяти.                                 |
| **Управление планом** | `/*+ LEADING(t1 t2 ...) */`                | Определяет **порядок соединения** таблиц.                                                                 | Критически важен для сложных запросов (много JOIN), когда оптимизатор выбирает неэффективный порядок соединения, что ведет к избыточному промежуточному результату.                             |
|                       | `/*+ OPTIMIZER_ROWS(N) */`                 | Указывает оптимизатору, что он должен выбрать план, который вернет **первые N строк** максимально быстро. | Для интерактивных приложений, где пользователю достаточно получить первые несколько строк немедленно, даже если полное выполнение запроса займет больше времени (альтернатива `FIRST_ROWS(N)`). |
| **Параллелизм**       | `/*+ PARALLEL(table_alias, N) */`          | Принуждает использовать **параллельное выполнение** операций с указанной степенью параллелизма (`N`).     | При работе с очень большими таблицами в окружении DWH/BI, где время ответа важнее, чем загрузка CPU.                                                                                            |



## 1. Хинты для выбора метода доступа (Access Method)

Эти хинты указывают оптимизатору, как следует читать данные из таблицы.

| Хинт                                   | Назначение                                                                                                     | Зона применимости                                                                                                                        |
| -------------------------------------- | -------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------- |
| **`FULL(table_alias)`**                | Принуждает использовать **полное сканирование таблицы** (Full Table Scan).                                     | Для очень больших таблиц, когда требуется обработать бо́льшую часть данных (более 5-10%), или при отсутствии полезных индексов.          |
| **`INDEX(table_alias index_name)`**    | Принуждает использовать указанный **индекс** для доступа к таблице.                                            | Когда требуется выбрать небольшой процент данных (низкая селективность) и оптимизатор ошибочно выбирает `FULL SCAN`.                     |
| **`NO_INDEX(table_alias index_name)`** | Запрещает использование указанного **индекса** (или всех индексов, если имя не указано).                       | Используется для тестирования или когда индекс замедляет выполнение из-за высокого уровня конфликтов или низкой эффективности.           |
| **`INDEX_RS_ASC`**                     | Принуждает использовать сканирование диапазона индекса (Range Scan) **в восходящем порядке**.                  | Для запросов, которым требуется отсортированный по индексу результат, но оптимизатор выбрал неоптимальный путь.                          |
| **`INDEX_FFS`**                        | Принуждает использовать **быстрое полное сканирование индекса** (Fast Full Index Scan).                        | Когда все необходимые столбцы есть в индексе, и не требуется отсортированный результат (экономит ввод-вывод по сравнению с `FULL SCAN`). |
| **`INDEX_COMBINE`**                    | Принуждает использовать **объединение (COMBINE)** нескольких битовых индексов.                                 | При работе с большими таблицами, где эффективно настроены битовые карты (Bitmap Indexes).                                                |
| **`AND_EQUAL`**                        | Принуждает использовать **объединение** результатов нескольких индексов с помощью логического оператора `AND`. | Для очень старых версий Oracle, когда требуется объединить результаты отбора по двум или более индексам.                                 |

## 2. Хинты для методов соединения (Join Method)

Эти хинты определяют, как оптимизатор должен соединять таблицы.

|Хинт|Назначение|Зона применимости|
|---|---|---|
|**`USE_NL(table_alias)`**|Принуждает использовать соединение **Nested Loops** (Вложенные циклы).|Идеально для **OLTP-систем**. Эффективно, когда одна из таблиц маленькая, а на столбце соединения другой таблицы есть эффективный индекс.|
|**`USE_HASH(table_alias)`**|Принуждает использовать соединение **Hash Join** (Хеш-соединение).|Идеально для **OLAP/DWH-систем**. Эффективно для соединения двух больших таблиц.|
|**`USE_MERGE(table_alias)`**|Принуждает использовать соединение **Sort-Merge Join** (Сортировка-Слияние).|Используется редко. Может быть полезен, когда данные уже отсортированы или для больших объемов, где неэффективен `HASH JOIN`.|
|**`NO_USE_NL(table_alias)`**|Запрещает использование соединений **Nested Loops**.|Принуждение к `HASH` или `MERGE` при неэффективности `NL`.|


## 3. Хинты для трансформации запроса и порядка операций

Эти хинты управляют тем, как оптимизатор преобразует SQL-код и в каком порядке выполняются операции.

| Хинт                               | Назначение                                                                                                                                     | Зона применимости                                                                                                                          |
| ---------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------ |
| **`ORDERED`**                      | Принуждает оптимизатор соединять таблицы в том **порядке, в котором они перечислены** в секции `FROM`.                                         | Критически важен для сложных запросов. Используется вместе с `LEADING`.                                                                    |
| **`LEADING(t1 t2 t3...)`**         | Определяет **начальную пару** для соединения таблиц, оставляя дальнейший порядок на усмотрение оптимизатора.                                   | Более гибкая альтернатива `ORDERED`. Помогает избежать неэффективного "распухания" промежуточных результатов.                              |
| **`NO_MERGE(view_alias)`**         | Запрещает оптимизатору "вставлять" (сливать) подзапрос (в представлении) в основной запрос.                                                    | Используется для контроля логики, когда слияние подзапроса приводит к неоптимальному плану (например, к неправильному порядку соединения). |
| **`NO_QUERY_TRANSFORMATION`**      | Запрещает все автоматические трансформации запроса (например, слияние представлений, преобразование `IN` в `EXISTS`).                          | Крайняя мера для отладки или при наличии критической ошибки в оптимизаторе.                                                                |
| **`NO_EXPAND`**                    | Запрещает оптимизатору преобразовывать запросы с `OR` в эквивалентные запросы с `UNION ALL` (техника Cost-Based Query Transformation).         | Принудительное сохранение оригинальной структуры запроса.                                                                                  |
| **`PUSH_SUBQ`**                    | Предписывает оптимизатору выполнить подзапрос (некоррелированный) как можно раньше (Push Predicate).                                           | Ускоряет выполнение за счёт уменьшения объема данных, передаваемых на следующий этап.                                                      |
| **`MATERIALIZE(subquery_alias)`**  | Принуждает оптимизатор сначала **полностью выполнить подзапрос** и сохранить его результат во временном сегменте, а затем использовать его.    | Полезно, когда подзапрос используется несколько раз в основном запросе (фактически кэширование).                                           |
| **`HASH_SJ`, `NL_SJ`, `MERGE_SJ`** | Принуждают использовать конкретный метод соединения для **полу-соединений** (Semi-Join, используемого, например, для `EXISTS`).                | Управление методом соединения в специфических конструкциях.                                                                                |
| **`HASH_AJ`, `NL_AJ`, `MERGE_AJ`** | Принуждают использовать конкретный метод соединения для **анти-соединений** (Anti-Join, используемого, например, для `NOT IN` / `NOT EXISTS`). | Управление методом соединения в специфических конструкциях.                                                                                |


## 4. Хинты для настройки цели оптимизации и статистики

Эти хинты влияют на общую цель оптимизатора и используемые им данные.

| Хинт                                  | Назначение                                                                                        | Зона применимости                                                                                                                               |
| ------------------------------------- | ------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------- |
| **`ALL_ROWS`**                        | Устанавливает цель оптимизатора: **минимизация общего времени выполнения запроса** (Throughput).  | Используется по умолчанию в DWH/OLAP. Игнорируется, если в запросе есть `ROWNUM`.                                                               |
| **`FIRST_ROWS(N)`**                   | Устанавливает цель: **минимизация времени до получения первых N строк**.                          | Идеально для интерактивных приложений (OLTP), где важен быстрый ответ пользователю.                                                             |
| **`DYNAMIC_SAMPLING(table_alias N)`** | Принуждает оптимизатор выполнить **динамическую выборку статистики** во время компиляции запроса. | Используется, когда статистика по таблице неточна или отсутствует, или когда сложные предикаты мешают точному прогнозированию количества строк. |
| **`CARDINALITY(table_alias N)`**      | **Переопределяет прогнозируемую кардинальность** (количество строк) для указанной таблицы.        | Применяется, когда оптимизатор критически ошибается в оценке количества строк после применения фильтров, что приводит к неверному выбору плана. |
| **`RESULT_CACHE`**                    | Указывает Oracle кэшировать результат запроса в **Кэше Результатов**.                             | Для часто выполняемых, но редко изменяющихся запросов. Повышает производительность, но может увеличить потребление памяти.                      |


## 5. Хинты для параллелизма (Parallel Execution)

Эти хинты управляют выполнением операций с использованием нескольких процессов (параллелизм).

| Хинт                                           | Назначение                                                                                                                              | Зона применимости                                                                                                           |
| ---------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------- |
| **`PARALLEL(table_alias N)`**                  | Принуждает использовать **параллельное выполнение** (Parallel Execution) для доступа к таблице с указанной степенью параллелизма (`N`). | Для больших отчетов и задач DWH, где можно задействовать множество ядер CPU.                                                |
| **`PARALLEL_INDEX(table_alias index_name N)`** | Принуждает использовать **параллельное выполнение** для сканирования указанного **индекса**.                                            | Для ускорения операций, где узким местом является сканирование большого индекса.                                            |
| **`NO_PARALLEL_INDEX`**                        | Запрещает параллельное сканирование индекса.                                                                                            | Используется для ограничения загрузки системы или при неэффективности параллелизма.                                         |
| **`APPEND`**                                   | Используется с `INSERT INTO ... SELECT`. Принуждает Oracle к **прямой загрузке** (Direct-path insert), минуя буферный кэш.              | Значительно ускоряет вставку больших объемов данных, но не сохраняет свободное место в блоках (требует блокировки таблицы). |
