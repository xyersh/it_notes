

## Важные моменты и ограничения

- **Циклы**: всегда проверяйте данные на наличие циклов. Используйте `NOCYCLE`, если они возможны.
- **Производительность**: для глубоких иерархий может потребоваться индекс по `manager_id`.
- **Глубина рекурсии**: Oracle по умолчанию ограничивает глубину (обычно 100 уровней). Можно изменить через `MAXRECURSION` в других СУБД, но в Oracle — только через логику запроса.
- **Фильтрация**: условия в `WHERE` применяются **после** построения иерархии. Чтобы фильтровать **до** — используйте подзапрос или CTE.


## Синтаксис Oracle
Использование в запросах `CONNECT BY`, `START WITH`, псевдо-столбцов

#### Основной синтаксис
```sql
SELECT [столбцы]
FROM таблица
[WHERE условия]
START WITH условие_корня
CONNECT BY [PRIOR] родитель = [PRIOR] потомок
[ORDER SIBLINGS BY ...];
```

#### Псевдо-столбцы
|Псевдо-столбец|Назначение|
|---|---|
|`LEVEL`|Уровень вложенности (1 — корень, 2 — дети корня и т.д.)|
|`CONNECT_BY_ISLEAF`|1, если узел — лист (нет потомков), иначе 0|
|`CONNECT_BY_ISCYCLE`|1, если строка участвует в цикле (требуется `NOCYCLE`)|
|`SYS_CONNECT_BY_PATH(col, delim)`|Строка, содержащая путь от корня до текущего узла|


### ПРИМЕРЫ

Предположим, имеется таблица сотрудников:
```sql
CREATE TABLE employees (
    emp_id     NUMBER PRIMARY KEY,
    emp_name   VARCHAR2(50),
    manager_id NUMBER REFERENCES employees(emp_id)
);

INSERT INTO employees VALUES (1, 'CEO', NULL);
INSERT INTO employees VALUES (2, 'CTO', 1);
INSERT INTO employees VALUES (3, 'CFO', 1);
INSERT INTO employees VALUES (4, 'Dev Lead', 2);
INSERT INTO employees VALUES (5, 'Senior Dev', 4);
INSERT INTO employees VALUES (6, 'Junior Dev', 5);
INSERT INTO employees VALUES (7, 'Accountant', 3);
```

#### 1: Вывод иерархии подчинённости
```sql
SELECT 
    LPAD(' ', (LEVEL - 1) * 4) || emp_name AS hierarchy,
    emp_id,
    manager_id,
    LEVEL,
    CONNECT_BY_ISLEAF AS is_leaf
FROM employees
START WITH manager_id IS NULL
CONNECT BY PRIOR emp_id = manager_id
ORDER SIBLINGS BY emp_name;
```

Результат:
```bash
CEO
    CFO
        Accountant
    CTO
        Dev Lead
            Senior Dev
                Junior Dev
```

#### 2: Путь от корня до узла
```sql
SELECT 
    emp_name,
    SYS_CONNECT_BY_PATH(emp_name, ' → ') AS path
FROM employees
START WITH manager_id IS NULL
CONNECT BY PRIOR emp_id = manager_id;
```

Результат:
```sql
CEO                     → CEO
CTO                     → CEO → CTO
Dev Lead                → CEO → CTO → Dev Lead
...
```

#### 3: Обнаружение циклов
Если в данных возможны циклы (например, сотрудник A управляет B, а B — A), используйте `NOCYCLE`:
```sql
SELECT 
    emp_name,
    CONNECT_BY_ISCYCLE AS is_cycle
FROM employees
START WITH manager_id IS NULL
CONNECT BY NOCYCLE PRIOR emp_id = manager_id;
```



## Синтаксис ISO, Рекурсивные CTE (Common Table Expressions)

Начиная с Oracle 11gR2, поддерживается стандарт ANSI SQL для рекурсивных запросов.

Базовый синтаксис:
```sql
WITH имя_cte (столбцы) AS (
    -- якорь (корневой запрос)
    SELECT ... FROM ...
    UNION ALL
    -- рекурсивная часть
    SELECT ... FROM ..., имя_cte WHERE ...
)
SELECT * FROM имя_cte;
```

### ПРИМЕРЫ
#### То же дерево из примера выше через рекурсивный CTE
```sql
WITH emp_hierarchy (emp_id, emp_name, manager_id, lvl, path) AS (
    -- Якорь: корневой элемент
    SELECT emp_id, emp_name, manager_id, 1 AS lvl,
           emp_name AS path
    FROM employees
    WHERE manager_id IS NULL
    
    UNION ALL
    
    -- Рекурсия: потомки
    SELECT e.emp_id, e.emp_name, e.manager_id, eh.lvl + 1,
           eh.path || ' → ' || e.emp_name
    FROM employees e
    JOIN emp_hierarchy eh ON e.manager_id = eh.emp_id
)
SELECT 
    LPAD(' ', (lvl - 1) * 4) || emp_name AS hierarchy,
    lvl,
    path
FROM emp_hierarchy
ORDER BY path;
```


#### получение таблицы со значениями дата-время по рэйнджу  от :date1 до :date2
```sql
with  time_series(date_time) as (
    select :date1
    from dual

    union all

    select date_time + interval '1' hour
    from time_series
    where date_time + interval '1' hour < :date2
)

select*
from time_series
```

