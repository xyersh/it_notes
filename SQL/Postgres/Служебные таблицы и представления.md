
### pg_stat_activity

Представление `pg_stat_activity` показывает информацию о **текущих процессах (сессиях)**, подключенных к базе данных. Это ключевой инструмент для мониторинга активности и диагностики проблем.

#### Полезные столбцы
- `pid`: Идентификатор процесса бэкенда.
- `datname`: Имя базы данных, к которой подключен процесс.
- `usename`: Имя пользователя, подключенного к процессу.
- `client_addr`: IP-адрес клиента, откуда происходит подключение.
- `state`: Текущее состояние процесса (например, `active`, `idle`, `idle in transaction`).
- `query`: Текст текущего выполняющегося запроса (если процесс активен).
- `query_start`: Время начала текущего запроса.
- `wait_event_type` и `wait_event`: Тип и подробное описание события, которого ожидает процесс (например, блокировка - `Lock`).

#### Сценарии использования

- **Мониторинг производительности:** Поиск **медленных** или **долго выполняющихся** запросов, чтобы определить, какие из них требуют оптимизации.
```sql
SELECT pid, age(now(), query_start), usename, query
FROM pg_stat_activity
WHERE state = 'active'
ORDER BY query_start;
```
- **Поиск и устранение взаимоблокировок (Deadlocks):** Идентификация процессов, которые находятся в состоянии ожидания, особенно связанных с блокировками.
- **Управление сессиями:** Просмотр неактивных сессий (`idle`) или сессий в зависшей транзакции (`idle in transaction`) для их принудительного завершения (`pg_terminate_backend(pid)`), если это необходимо.



### information_schema` 
 это набор представлений, стандартизированных в SQL, которые предоставляют информацию о **структуре** базы данных. Они более переносимы между различными СУБД, чем каталоги `pg_catalog`.

#### information_schema.tables
##### Полезные столбцы:
- `table_schema`: Имя схемы (например, `public`).
- `table_name`: Имя таблицы или представления.
- `table_type`: Тип объекта (`BASE TABLE`, `VIEW` и т.д.).

#### information_schema.columns
##### Полезные столбцы:
- `table_name`: Имя таблицы.
- `column_name`: Имя столбца.
- `data_type`: Тип данных столбца.
- `is_nullable`: Может ли столбец содержать `NULL`.

#### Сценарии использования

- **Анализ структуры БД:** Получение списка всех таблиц в определенной схеме.
```sql
SELECT table_name, table_type
FROM information_schema.tables
WHERE table_schema = 'public' 
	AND table_type = 'BASE TABLE';
```


- **Проверка метаданных:** Получение списка столбцов, их типов данных и ограничений для конкретной таблицы.
```sql
SELECT column_name, data_type, is_nullable
FROM information_schema.columns
WHERE table_name = 'название_таблицы' 
	AND table_schema = 'public'
ORDER BY ordinal_position;
```



### pg_class (Системный каталог)

#### Описание

Таблица системного каталога `pg_class` хранит информацию о **отношениях (relations)**, включая таблицы, индексы, представления, последовательности и т.п. Это "сырые" метаданные PostgreSQL, более полные, чем `information_schema`, но специфичные для Postgres.


#### Полезные столбцы
- `relname`: Имя отношения (таблицы, индекса и т.п.).
- `relkind`: Тип отношения (`r` - таблица, `i` - индекс, `v` - представление, `S` - последовательность).
- `reltuples`: **Оценочное** количество строк в таблице.
- `relpages`: **Оценочное** количество страниц на диске, занимаемых отношением. Этот параметр помогает определить, сколько страниц планировщику необходимо просмотреть при выполнении запроса. Если у таблицы много страниц, планировщик может решить использовать последовательный скан вместо индексного. 
- `relallvisible` - это количество страниц, на которых все строки видимы для текущей транзакции. Этот параметр важен для оптимизации операций, таких как `Bitmap Неар Scan`. Если страницы содержат невидимые строки, их обход может быть неэффективным. 

#### Сценарии использования

- **Оценка размера таблицы/индекса:** Объединение `pg_class` с функциями `pg_total_relation_size()` или `pg_relation_size()` для определения занимаемого места на диске.
```sql
SELECT
    relname,
    pg_size_pretty(pg_total_relation_size(oid)) AS total_size
FROM pg_class
WHERE relkind = 'r' -- Только таблицы
ORDER BY pg_total_relation_size(oid) DESC;
```

- **Оценка количества строк:** Быстрое получение приблизительного количества строк (`reltuples`) для целей планировщика запросов, без полного сканирования таблицы.



### pg_settings

Представление `pg_settings` предоставляет доступ к **параметрам конфигурации** сервера в режиме выполнения. Это альтернатива команде `SHOW`.

#### Полезные столбцы
- `name`: Имя параметра (например, `shared_buffers`, `work_mem`).
- `setting`: Текущее активное значение параметра.
- `unit`: Единица измерения (например, `kB`, `ms`).
- `context`: Контекст, в котором может быть изменен параметр (`postmaster`, `superuser`, `user`).
- `source`: Источник текущего значения (например, `configuration file`, `default`).

#### Сценарии использования

- **Проверка настроек:** Проверка, что критически важные параметры, такие как размер буферов (`shared_buffers`) или параметры логирования, установлены правильно.
```sql
SELECT name, setting, unit, context, source
FROM pg_settings
WHERE name IN ('shared_buffers', 'work_mem', 'log_min_duration_statement');
```

- **Аудит и диагностика:** Проверка, откуда берется текущее значение параметра (например, из конфиг-файла или было изменено в рамках сессии).


### pg_locks

#### Описание

Представление `pg_locks` содержит информацию об **активных и ожидающих блокировках** в базе данных. Это важно для диагностики проблем с конкурентным доступом.

#### Полезные столбцы
- `pid`: Идентификатор процесса, владеющего или ожидающего блокировку.
- `locktype`: Тип блокировки (например, `relation`, `transactionid`).
- `relation`: OID (идентификатор объекта) отношения, на котором установлена блокировка.
- `mode`: Режим блокировки (например, `RowExclusiveLock`, `AccessShareLock`, `ExclusiveLock`).
- `granted`: Булево значение: `t` (true) – блокировка получена, `f` (false) – процесс ожидает блокировку.
    

#### Сценарии использования

- **Поиск блокирующего запроса (Blocker):** Идентификация запроса, который удерживает блокировку и заставляет другие запросы ждать.
```sql
SELECT
    t1.pid AS blocked_pid,
    t2.pid AS blocking_pid,
    t2.query AS blocking_query
FROM pg_locks t1
JOIN pg_stat_activity t2 ON t1.pid = t2.pid
WHERE t1.granted = 'f'; -- Показать только ожидающие блокировки
```

- **Анализ конфликтов:** Определение того, на каких таблицах или транзакциях чаще всего возникают конфликты.


### pg_stats

#### Описание
предоставляет **статистику распределения данных по столбцам**, необходимую для **оптимизатора запросов (Query Planner)**.

#### Полезные столбцы
- `schemaname` - название схемы
- `tablename` - название таблицы
- `attname` - наименование столбца
- `avg_width` - среднюю ширину (в байтах) всех значений в столбце опре­делённой таблицы. Этот параметр играет важную роль в планировании запросов, так как помогает планировщику оценить, сколько памяти потребуется для хранения данных, и оптимизировать операции, связанные с выборкой и обра­боткой этих данных. 
- `null_frac` - доля значений в столбце, которые являются NULL
- `n_distinct` - отображает количе­ство уникальных значений в столбце. Если значение n_distinct отрицательное, его абсолютное значение интерпретируется как доля уникальных значений. Например, значение -1 указывает на то, что все значения в столбце уникальны, тогда как -3 говорит о том, что в среднем каждое значение встре­чается в трех строках.
- `most_common_vals` - **Массив наиболее частых значений** в столбце. Помогает планировщику точно оценить селективность для условий, которые сравнивают столбец с одним из этих частых значений (например, `WHERE column = 'частое_значение'`).
- `most_common_freqs` - **Массив частот** (долей от общего числа строк) для значений из `most_common_vals`. Используется планировщиком вместе с `most_common_vals` для точной оценки стоимости.
- `histogram_bounds` - **Гистограмма распределения значений**, разделяющая диапазон значений на группы с примерно равным количеством строк.  Позволяет планировщику оценивать селективность для условий диапазона (например, `WHERE column > X AND column < Y`), если значения не попали в `most_common_vals`.
- `correlation` - **Корреляция** между физическим порядком строк в таблице и логическим порядком значений в столбце (от $-1$ до $+1$). Значения, близкие к $-1$ или $+1$, указывают на то, что данные в таблице физически упорядочены по этому столбцу. Это делает сканирование по индексу более эффективным, так как уменьшает количество случайных обращений к диску.
### pg_stat_user_tables  и  pg_stat_all_indexes

#### Описание

Это представления статистики, которые собирают данные о **поведении таблиц и индексов** после их создания и использования.

#### Полезные столбцы
- **`pg_stat_user_tables`**: 
    - `relname`: Имя таблицы.
    - `seq_scan`: Количество последовательных сканирований таблицы.
    - `idx_scan`: Количество сканирований таблицы с использованием индекса.
    - `n_live_tup`: Количество "живых" строк.
    - `last_vacuum`, `last_autovacuum`, `last_analyze`, `last_autoanalyze`: Время последнего ручного/автоматического `VACUUM`/`ANALYZE`.

##### Отличие pg_stats и pg_stat_user_ta

| **Характеристика**      | **pg_stats**                                                                                                                          | **pg_stat_user_tables**                                                                                                                              |
| ----------------------- | ------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Основное назначение** | **Оптимизация запросов** (Планирование).                                                                                              | **Мониторинг активности** и `VACUUM`.                                                                                                                |
| **Уровень детализации** | **Постолбцовая (Column-level)**. Одна строка на каждый _столбец_.                                                                     | **Потабличная (Table-level)**. Одна строка на каждую _таблицу_.                                                                                      |
| **Содержание**          | Информация о **распределении значений** в столбце (`null_frac`, `n_distinct`, `most_common_vals`, `histogram_bounds`, `correlation`). | Информация о **действиях** с таблицей (`seq_scan`, `idx_scan`, `n_tup_ins`, `n_tup_upd`, `n_live_tup`, `n_dead_tup`, `last_vacuum`, `last_analyze`). |
| **Источник данных**     | Системный каталог **`pg_statistic`**, который обновляется командой **`ANALYZE`**.                                                     | Встроенный **Сборщик статистики (Statistics Collector)**, который обновляется постоянно и асинхронно.                                                |
| **Актуальность**        | Обновляется только при выполнении **`ANALYZE`** или `VACUUM ANALYZE` (вручную или через `autovacuum`).                                | Обновляется **постоянно** в процессе работы сервера (при условии, что включен `track_counts`).                                                       |


- **`pg_stat_all_indexes`**:
    - `relname`: Имя таблицы.
    - `indexrelname`: Имя индекса.
    - `idx_scan`: Количество использований индекса.

#### Сценарии использования

1. **Оптимизация индексов:** Поиск неиспользуемых индексов (где `idx_scan` близко к нулю) для их удаления или, наоборот, таблиц с высоким `seq_scan` и низким `idx_scan` для проверки необходимости добавления индексов.
    
2. **Мониторинг `VACUUM`:** Проверка, как часто запускается `autovacuum` и правильно ли он работает, чтобы избежать проблем с "заворачиванием" транзакций (transaction ID wraparound).