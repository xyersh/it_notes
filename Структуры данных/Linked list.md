
### База

**Связанный список** — это линейная структура данных, где элементы не хранятся в последовательных ячейках памяти (как в массивах). Вместо этого, каждый элемент (называемый **узлом** или **нодой**) содержит:
1. **Данные** (значение, которое мы хотим хранить).
2. **Ссылку (или указатель)** на следующий элемент в списке.

Первый узел списка называется **головой (head)**, а последний узел указывает на `nil` (или на первый узел в случае циклического списка), сигнализируя о конце списка.

**Ключевая идея:** Элементы связаны между собой "ссылками", образуя цепочку.


### Зачем нужны Связанные Списки?

Связанные списки предлагают несколько преимуществ по сравнению с массивами в определённых сценариях:
- **Динамический размер:** Связанные списки могут динамически расти или уменьшаться в размере по мере необходимости. Вам не нужно заранее объявлять их размер.
- **Эффективные вставка и удаление:** Добавление или удаление элемента в середину списка (после нахождения нужного места) занимает постоянное время (O(1)). В массиве это O(N), так как требуется сдвиг элементов.
- **Нет фрагментации памяти:** Элементы списка могут располагаться в памяти несмежно, что делает их более гибкими в управлении памятью по сравнению с массивами.

Однако есть и недостатки:
- **Медленный произвольный доступ:** Чтобы получить доступ к N-му элементу, нам нужно начать с `head` и пройти по всем N−1 элементам. Это O(N), тогда как в массиве это O(1).
- **Дополнительная память:** Каждый узел хранит не только данные, но и указатель на следующий элемент, что требует дополнительной памяти.
- **Отсутствие кэширования:** Из-за несмежного хранения элементов, связанный список может плохо использовать кэш процессора, что потенциально замедляет операции обхода.


### Типы Связанных Списков

#### Односвязный Список (Singly Linked List)
Это самый простой тип связанного списка. Каждый узел содержит данные и ссылку только на **следующий** узел.
```go
type Node[T any] struct {
    Value T
    Next  *Node[T]
}
```
**Преимущества:**
- Простота реализации.
- Меньше потребление памяти по сравнению с двусвязным списком (нужен только один указатель).
    

**Недостатки:**
- Невозможно эффективно двигаться назад по списку. Чтобы найти предыдущий элемент, нужно снова начать с `head`
- Удаление элемента требует знания ссылки на _предыдущий_ узел.


#### Двусвязный Список (Doubly Linked List)
В двусвязном списке каждый узел содержит данные, ссылку на **следующий** узел и ссылку на **предыдущий** узел.
```go
type DoublyNode[T any] struct {
    Value T
    Next  *DoublyNode[T]
    Prev  *DoublyNode[T]
}
```

**Преимущества:**
- Возможность обхода в обоих направлениях (вперёд и назад).
- Более простое удаление элемента, так как есть доступ к предыдущему узлу.
    
**Недостатки:**
- Большее потребление памяти по сравнению с односвязным списком (два указателя на узел)
- Операции добавления/удаления немного сложнее, так как нужно обновлять два указателя.

#### Циклический Связанный Список (Circular Linked List)
В циклическом списке последний узел указывает не на `nil`, а на **первый узел** списка. Он может быть как односвязным, так и двусвязным.

**Преимущества:**
- Можно обойти список, начиная с любого узла и вернуться в исходную точку.
- Удобно для буферов или задач, где элементы обрабатываются циклически (например, по кругу).
    

**Недостатки:**
- Сложнее обнаружить конец списка (нет `nil`).
- При реализации нужно быть внимательным, чтобы не попасть в бесконечный цикл.


### Основные Операции со Связанными Списками
## Основные Операции со Связанными Списками

Независимо от типа, большинство связанных списков поддерживают следующие базовые операции:
- **`AddFront(value)` / `PushFront(value)`:** Добавить элемент в начало списка.
- **`AddBack(value)` / `PushBack(value)`:** Добавить элемент в конец списка.
- **`RemoveFront()` / `PopFront()`:** Удалить элемент из начала списка.
- **`RemoveBack()` / `PopBack()`:** Удалить элемент из конца списка.
- **`Insert(index, value)` / `AddAfter(node, value)`:** Вставить элемент в определённую позицию или после указанного узла.
- **`Remove(value)` / `RemoveAt(index)`:** Удалить элемент по значению или по индексу.
- **`Find(value)`:** Найти элемент по значению и вернуть узел (или его индекс).
- **`IsEmpty()`:** Проверить, пуст ли список.
- **`Size()`:** Вернуть количество элементов в списке.
- **`Traverse()` / `Print()`:** Пройти по всем элементам списка и вывести их.



### ПИРМЕРЫ