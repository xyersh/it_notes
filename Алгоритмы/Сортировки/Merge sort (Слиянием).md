```go
package main  
  
import (  
    "fmt"  
    "sync")  
  
// SequentialMergesort запускает рекурсивную сортировку слиянием.func SequentialMergesort(s []int) {  
    // Базовый случай рекурсии: если в срезе 1 или 0 элементов, он уже отсортирован.  
    if len(s) <= 1 {  
       return  
    }  
    middle := len(s) / 2  
    SequentialMergesort(s[:middle]) // Сортируем левую половину  
    SequentialMergesort(s[middle:]) // Сортируем правую половину  
    merge(s, middle)                // Сливаем две отсортированные половины  
}  
  
func ParallelMergesort(s []int) {  
    // Базовый случай рекурсии: если в срезе 1 или 0 элементов, он уже отсортирован.  
    if len(s) <= 1 {  
       return  
    }  
  
    if len(s) < 4024 {  
       SequentialMergesort(s)  
    } else {  
       var wg sync.WaitGroup  
       wg.Add(2)  
       middle := len(s) / 2  
       go func() {  
          defer wg.Done()  
          ParallelMergesort(s[:middle]) // Сортируем левую половину  
       }()  
       go func() {  
          defer wg.Done()  
          ParallelMergesort(s[middle:]) // Сортируем правую половину  
       }()  
       wg.Wait()  
       merge(s, middle) // Сливаем две отсортированные половины  
    }  
}  
  
// merge сливает две отсортированные части среза s в один отсортированный срез.// Первая часть: s[0...middle-1], вторая часть: s[middle...len(s)-1]  
func merge(s []int, middle int) {  
    // Создаем временный срез для хранения результата слияния.  
    // Его размер равен размеру исходного среза.    helper := make([]int, len(s))  
    copy(helper, s) // Копируем все элементы s в helper  
  
    // Указатели для левой и правой половин во временном срезе (helper)    helperLeft := 0       // Начало левой половины  
    helperRight := middle // Начало правой половины  
  
    // Указатель для текущей позиции в основном срезе (s), куда будем вставлять элементы    current := 0  
  
    // Пока в обеих половинах есть элементы, сравниваем их  
    // и копируем меньший в основной срез s.    for helperLeft < middle && helperRight < len(s) {  
       if helper[helperLeft] <= helper[helperRight] {  
          s[current] = helper[helperLeft]  
          helperLeft++  
       } else {  
          s[current] = helper[helperRight]  
          helperRight++  
       }  
       current++  
    }  
  
    // Если в левой половине остались элементы (правая закончилась),  
    // копируем их остаток в конец основного среза.    remaining := middle - helperLeft  
    for i := 0; i < remaining; i++ {  
       s[current+i] = helper[helperLeft+i]  
    }  
}  
  
func main() {  
    data := []int{9, 4, 3, 6, 1, 2, 10, 5, 7, 8}  
    fmt.Println("Исходный срез:", data)  
    SequentialMergesort(data)  
    fmt.Println("Отсортированный срез:", data)  
  
    // Проверка на вашем примере  
    data2 := []int{9, 4, 3, 6, 1, 2, 10, 5, 7, 8}  
    fmt.Println("\nИсходный срез:", data2)  
    ParallelMergesort(data2)  
    fmt.Println("Отсортированный срез:", data2)  
}
```

### Асимптотическая сложность

- **Лучший случай:** O(n log n)
- **Средний случай:** O(n log n)
- **Худший случай:** O(n log n)

Независимо от исходного порядка элементов, сортировка слиянием всегда имеет временную сложность O(n log n). Это делает ее очень эффективным алгоритмом для больших массивов данных.

### Почему сортировка слиянием эффективна?

- **Гарантированная сложность:** Независимость от исходного порядка элементов делает алгоритм предсказуемым по времени выполнения.
- **Стабильная сортировка:** Равные элементы сохраняют свой относительный порядок в отсортированном массиве.
- **Параллелизм:** Алгоритм легко поддается параллельной реализации, что позволяет эффективно использовать многоядерные процессоры.

### Когда использовать сортировку слиянием?

- **Большие массивы данных:** Алгоритм хорошо масштабируется на больших наборах данных.
- **Стабильность сортировки:** Когда важно сохранить относительный порядок равных элементов.
- **Параллельные вычисления:** При необходимости использовать многопоточность или распределенные вычисления.

### Важные моменты

- **Дополнительная память:** Сортировка слиянием требует дополнительной памяти для хранения промежуточных результатов, что может быть недостатком для ограниченных систем.
- **Рекурсия:** Использование рекурсии может привести к переполнению стека при очень больших массивах.