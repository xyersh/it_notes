Оптимизированный алгоритм для получения слайса из простых чисел в диапазоне натуральных чисел  [0, n]
```go
package main

import (
	"fmt"
)

// SieveOfEratosthenes находит все простые числа до n, используя оптимизированный алгоритм.
func SieveOfEratosthenes(n int) []int {
	// 1. Обработка крайних случаев. Простых чисел меньше 2 не существует.
	if n < 2 {
		return []int{}
	}

	// 2. Создание "решета".
	// composites[i] = true означает, что число i - составное (не простое).
	// Размер n+1, чтобы индекс массива соответствовал числу.
	// Изначально все значения false (по умолчанию в Go), что для нас означает "потенциально простое".
	composites := make([]bool, n+1)

	// 3. Основной цикл с двумя ключевыми оптимизациями.
	//
	// ОПТИМИЗАЦИЯ №1: Внешний цикл идёт только до sqrt(n).
	// Если у составного числа k есть делитель больше sqrt(k),
	// то обязательно есть и делитель меньше sqrt(k).
	// Поэтому все составные числа до n будут "просеяны" простыми числами,
	// которые не превышают sqrt(n).
	for p := 2; p*p <= n; p++ {

		// Если p уже помечено как составное, то все его кратные
		// уже были вычеркнуты ранее меньшими простыми делителями.
		// Например, для p=4 мы ничего не делаем, так как все кратные 4
		// также кратны 2 и уже были вычеркнуты.
		if composites[p] {
			continue
		}

		// ОПТИМИЗАЦИЯ №2: Внутренний цикл начинается с p*p, а не с 2*p.
		// Все меньшие кратные (2*p, 3*p, ...) уже были вычеркнуты ранее.
		// Например, для p=5, числа 2*5, 3*5, 4*5 уже были вычеркнуты
		// на шагах для p=2 и p=3. Первое невычеркнутое кратное - это 5*5=25.
		for i := p * p; i <= n; i += p {
			composites[i] = true
		}
	}

	// 4. Сбор результатов.
	// Проходим по нашему решету и собираем все числа, которые не были
	// помечены как составные.
	var primes []int
	for i := 2; i <= n; i++ {
		if !composites[i] {
			primes = append(primes, i)
		}
	}

	return primes
}
```