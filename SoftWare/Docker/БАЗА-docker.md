[hub.docker.com](https://hub.docker.com/) - дефолтный репозиторий для образов docker

### Глоссарий

- **Docker Client** - любой клиент для управления образами/контейнерами.
- **Docker Deamon** - собственно, выполняет команды от клиента
- **Docker Registry** - хранилище образов Docker. Например: hub.docker.com
- **Образ** -  
- **Контейнер** -  
- **Том** - 
- **Сеть** - 

### Образы



### Контейнеры



### Сети

#### Типы сетей (драйверы)

Docker поддерживает несколько встроенных драйверов для создания сетей:

- **bridge (по умолчанию)**: изолированная внутренняя сеть для контейнеров на одном хосте. Контейнеры могут общаться между собой по имени. Это наиболее распространенный тип.
    
- **host**: контейнер использует сетевой стек хоста, без изоляции. Это обеспечивает высокую производительность, но делает контейнер уязвимым, поскольку он не имеет собственного IP.
    
- **none**: контейнер не имеет сетевого интерфейса. Используется для создания полностью изолированных контейнеров.
    
- **overlay**: используется в Docker Swarm для создания сети, которая охватывает несколько хостов. Это позволяет контейнерам на разных машинах общаться между собой, как если бы они были в одной сети.
    
- **macvlan**: позволяет назначить каждому контейнеру свой собственный MAC-адрес, делая его полноценным участником физической сети.


### Тома
#### ** Bind Mount (Привязка к директории хоста)**

**Bind Mount** — это механизм, при котором директория или файл с хоста (локальной машины) напрямую монтируются в контейнер. При этом данные в контейнере "привязаны" к данным на хосте: изменения, сделанные в файлах на хосте, немедленно отображаются в контейнере, и наоборот.

Пример:

`volumes: - .:/code`

В данном примере:

- `.` указывает на текущую директорию на хосте, откуда запускается `docker-compose`.
- `/code` — это путь внутри контейнера, куда будет смонтирована директория с хоста.

При использовании **Bind Mount** контейнер использует напрямую данные из хостовой файловой системы. Это удобно для разработки, так как любые изменения на хосте (например, в коде) сразу будут видны в контейнере, и не нужно перезапускать контейнер.

Особенности Bind Mount:

- Используется для доступа к данным хоста (например, для работы с кодом приложения или логами).
- Может монтировать как файлы, так и директории.
- Нет управления данными (Docker не управляет сохранением данных).

#### **Volume Mount (Именованные тома Docker)**

**Volume Mount** — это механизм, при котором Docker управляет данными в специальном разделе, создавая тома, которые хранятся вне контейнеров. Эти тома управляются самим Docker, и они могут сохраняться даже после удаления контейнера.

Пример:

`volumes: - logvolume01:/var/log`

В данном примере:
- `logvolume01` — это именованный том, который будет создан Docker и использован для хранения данных.
- `/var/log` — это путь внутри контейнера, куда будет монтироваться этот том.

**Volume Mount** полезен, когда необходимо сохранять данные между запусками контейнеров. Например, логи приложения или база данных могут сохраняться в томе, даже если контейнер был удален.

Особенности Volume Mount:

- Docker управляет сохранением и перемещением данных.
- Данные сохраняются между запусками контейнеров.
- Том может быть легко передан или подключен к другому контейнеру.
- Лучше для производительности и безопасности, чем Bind Mount.


#### Таблица сравнений раздичных видов монтирования

| Характеристика                              | Bind mount                                                                                                       | Volume mount                                                                                                           |
| ------------------------------------------- | ---------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------- |
| Управление данными                          | Данные хранятся в директории хоста                                                                               | Данные хранятся в томах, которыми управляет Docker                                                                     |
| Видимость изменений                         | Изменения на хосте сразу видны в контейнере                                                                      | Изменения сохраняются в отдельном томе Docker                                                                          |
| Производительность                          | Чуть ниже, так как контейнер взаимодействует с файловой системой хоста                                           | Оптимизировано для работы внутри Docker, лучше для производительности                                                  |
| Сохранение данных после удаления контейнера | Данные сохраняются только если они на хосте                                                                      | Данные остаются в томе Docker, даже после удаления контейнера                                                          |
| Примеры использования                       | Полезно для разработки, где нужно обновление файлов в реальном времени                                           | Для сохранения данных, баз данных, логов и данных, которые важны между запусками контейнеров                           |
| Заключение                                  | используется для монтирования локальных директорий или файлов в контейнеры, что особенно полезно для разработки. | используется для хранения данных, которые должны быть доступны между запусками контейнеров или даже после их удаления. |
```yml
version: "3.8"   
services:     
	web:       
		build: .       
		volumes:         
			- .:/code   # Bind Mount - текущая директория хоста в /code контейнера         
			- logvolume01:/var/log # Volume Mount - именованный том для логов в /var/log   
volumes:     
	logvolume01: {}  # Определение именованного тома для использования
```


### Примеры команд

- Запуск веб-сервера nginx из образа
docker run -d -p 80:80 --name mynginx nginx

docker run -d -p 5432:5432 --name mypostgres -e POSTGRES_USER=demo -e POSTGRES_PASSWORD=demo postgres:15

