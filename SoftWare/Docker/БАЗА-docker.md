[hub.docker.com](https://hub.docker.com/) - дефолтный репозиторий для образов docker

### Глоссарий

- **Docker Client** - любой клиент для управления образами/контейнерами.
- **Docker Deamon** - собственно, выполняет команды от клиента
- **Docker Registry** - хранилище образов Docker. Например: hub.docker.com
- **Образ** -  
- **Контейнер** -  
- **Том** - 
- **Сеть** - 

### Образы



### Контейнеры



### Сети

#### Типы сетей (драйверы)

Docker поддерживает несколько встроенных драйверов для создания сетей:

- **bridge (по умолчанию)**: изолированная внутренняя сеть (172.17.0.0/16) для контейнеров на одном хосте.  Контейнеры могут общаться между собой по имени, а также доступ наружу(доступ к внешним серверам, интернету и тд). Чтобы подключиться к контейнеру находящемуся  в такой сети, нужно использовать IP-хоста  и проброшенного порта. 
- **host**: контейнер использует IP-адрес самого  хоста, без изоляции. Контейнеры в такой сети также могут выходить наружу. Сеть **host**  обеспечивает высокую производительность, но делает контейнер уязвимым, поскольку он не имеет собственного IP.  
  Для установки данного типа сети при запуске `docker run` необходим параметр `--network=host`.
  Чтобы подключиться из вне к контейнеру в сети типа **host** необходимо использовать IP-адрес самого хоста, а также порт, используемый внутри работающего контейнера.
- **none**: контейнер не имеет сетевого интерфейса. Используется для создания полностью изолированных для сетевых интерфейсов контейнеров.  Для установки данного типа сети при запуске `docker run` необходим параметр `--network=none`.
- **overlay**: используется в Docker Swarm для создания сети, которая охватывает несколько хостов. Это позволяет контейнерам на разных машинах общаться между собой, как если бы они были в одной сети.
- **macvlan**: позволяет назначить каждому контейнеру свой собственный MAC-адрес, делая его полноценным участником физической сети.
- **ipvlan**: 

#### Bridge VS Host
При подключении **извне** (с другой машины) в обоих случаях (`bridge` и `host`) вы используете **IP-адрес хост-машины** (Docker Host).
Основная разница для внешнего пользователя заключается в используемом **номере порта** и в том, как Docker управляет изоляцией и перенаправлением трафика.
##### Режим `bridge` (Мост)

Это режим **по умолчанию**, обеспечивающий сетевую изоляцию.

| **Характеристика** | **Описание**                                                                                                                                                           | **Влияние на внешнего пользователя**                                                                                                                                                                                                                                                                |
| ------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Изоляция**       | Контейнер находится в собственной сетевой песочнице (namespace) и имеет свой **внутренний IP** (например, `172.17.0.2`).                                               | Контейнер **не виден** извне по его внутреннему IP.                                                                                                                                                                                                                                                 |
| **Доступ**         | Для доступа извне требуется **публикация порта** (`-p` или `--publish`). Docker настраивает NAT/iptables, чтобы перенаправить трафик с порта хоста на порт контейнера. | Вы используете **порт хоста**, который может отличаться от порта контейнера (например, `IP_хоста:8080` -> контейнер: `80`). Это позволяет **избежать конфликтов** портов, запуская несколько контейнеров на одном порту (например, Nginx) и публикуя их на разных портах хоста (8080, 8081 и т.д.). |
| **Команда**        | `docker run -d -p 8080:80 my_app`                                                                                                                                      | Внешний пользователь обращается по `http://<IP_хоста>:8080`                                                                                                                                                                                                                                         |

##### Режим `host` (Хост)

Этот режим **удаляет сетевую изоляцию** между контейнером и хостом.

| **Характеристика** | **Описание**                                                                                                                             | **Влияние на внешнего пользователя**                                                                                                                                    |
| ------------------ | ---------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Изоляция**       | Контейнер **использует сетевой стек хоста** напрямую. У него **нет** собственного внутреннего IP-адреса.                                 | Контейнер виден извне точно так же, как если бы приложение было запущено **непосредственно на хосте**.                                                                  |
| **Доступ**         | **Не требуется публикация порта** (`-p` не используется и игнорируется). Контейнер слушает тот же самый порт, который доступен на хосте. | Вы **обязаны** использовать **порт контейнера** (например, `IP_хоста:80`). Если на хосте уже что-то слушает этот порт, контейнер не сможет запуститься из-за конфликта. |
| **Команда**        | `docker run -d --network host my_app` (если приложение в контейнере слушает порт 80)                                                     | Внешний пользователь обращается по `http://<IP_хоста>:80`                                                                                                               |


Создать сеть **bridge**
 `--drive bridge` равноценно отсутствию указанного параметра `drive` - в любом случае будет создана сеть типа `bridge`
```bash
docker network create --drive bridge <network_name>
```


В случае если при создании контейнеров сеть не указывать - контейнеры будут находиться в дефолтной сети. В этом случае контейнеры могут общаться друг с другом только посредством их внутренних IP-адресам.
Если контейнеры создавались с указанием общей сети - они могут общаться друг с другом также посредством их DNS-имен (то что указано параметром `--name` при создании контейнера, или по дефолтному имении присвоенному докером при создании контейнера )


### Тома
#### ** Bind Mount (Привязка к директории хоста)**

**Bind Mount** — это механизм, при котором директория или файл с хоста (локальной машины) напрямую монтируются в контейнер. При этом данные в контейнере "привязаны" к данным на хосте: изменения, сделанные в файлах на хосте, немедленно отображаются в контейнере, и наоборот.

Пример:
`-v /home/user/app/data:/app/data`

В данном примере:

- `/home/user/app/data` указывает на  директорию на хосте, откуда запускается.
- `/app/data` — это путь внутри контейнера, куда будет смонтирована директория с хоста.

При использовании **Bind Mount** контейнер использует напрямую данные из хостовой файловой системы. Это удобно для разработки, так как любые изменения на хосте (например, в коде) сразу будут видны в контейнере, и не нужно перезапускать контейнер.

Особенности Bind Mount:
- Используется для непосредственного доступа к данным хоста (например, для работы с кодом приложения, конфигами, или логами).
- Может монтировать как файлы, так и директории.
- Нет управления данными (Docker не управляет сохранением данных).
- Удобно на этапе разработке и тестирования

#### **Volume Mount (Именованные тома Docker)**

**Volume Mount** — это механизм, при котором Docker управляет данными в специальном разделе, создавая тома, которые хранятся вне контейнеров. Эти тома управляются самим Docker, и они могут сохраняться даже после удаления контейнера.
- Для случая  хостовой среды Linux - данные хранятся в в директории, управляемой Docker (например, `/var/lib/docker/volumes/` на Linux)
- Для случая хостовой среды Windows - внутри файловой системы Linux-машины (VM), которую использует Docker Desktop (WSL 2 или Hyper-V). (VHDX-файл)


Пример:
`-v my-data:/app/data`

В данном примере:
- `my-data:` — это именованный том, который будет создан Docker и использован для хранения данных.
- `/app/data` — это путь внутри контейнера, куда будет монтироваться этот том.

ВАЖНО!
Перед непосредственным использованием тома необходимо его предварительное создание.


##### Операции с томами
- Просмотр списка имеющихся томов
```
docker volume ls
```
- Создание тома
```bash
docker volume create <volume_name>
```
- Удаление тома
```bash
docker volume rm <volume_name>
```



##### Особенности Volume Mount:
- можно подключать более 1 тома в контейнеру
- Docker управляет сохранением и перемещением данных.
- Данные сохраняются между запусками контейнеров.
- Том может быть легко передан или подключен к другому контейнеру.
- Лучше для производительности и безопасности, чем Bind Mount.
- Используется, когда изменение монтируемых файлов вручную не приветствуется (файлы БД)
- Подходит для хранения постоянных данных на проде

#### Таблица сравнений различных видов монтирования

| Характеристика                              | Bind mount                                                                                                       | Volume mount                                                                                                           |
| ------------------------------------------- | ---------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------- |
| Управление данными                          | Данные хранятся в директории хоста                                                                               | Данные хранятся в томах, которыми управляет Docker                                                                     |
| Видимость изменений                         | Изменения на хосте сразу видны в контейнере                                                                      | Изменения сохраняются в отдельном томе Docker                                                                          |
| Производительность                          | Чуть ниже, так как контейнер взаимодействует с файловой системой хоста                                           | Оптимизировано для работы внутри Docker, лучше для производительности                                                  |
| Сохранение данных после удаления контейнера | Данные сохраняются только если они на хосте                                                                      | Данные остаются в томе Docker, даже после удаления контейнера                                                          |
| Примеры использования                       | Полезно для разработки, где нужно обновление файлов в реальном времени                                           | Для сохранения данных, баз данных, логов и данных, которые важны между запусками контейнеров                           |
| Заключение                                  | используется для монтирования локальных директорий или файлов в контейнеры, что особенно полезно для разработки. | используется для хранения данных, которые должны быть доступны между запусками контейнеров или даже после их удаления. |
```yml
version: "3.8"   
services:     
	web:       
		build: .       
		volumes:         
			- .:/code   # Bind Mount - текущая директория хоста в /code контейнера         
			- logvolume01:/var/log # Volume Mount - именованный том для логов в /var/log   
volumes:     
	logvolume01: {}  # Определение именованного тома для использования
```


### Примеры команд

- Запуск веб-сервера nginx из образа
```bash
docker run -d -p 80:80 --name mynginx nginx
```

- запуск mySQL
```bash
docker run -d -p 5432:5432 --name mypostgres -e POSTGRES_USER=demo -e POSTGRES_PASSWORD=demo postgres:15
```


