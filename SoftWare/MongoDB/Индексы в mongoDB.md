Индексы в MongoDB играют ключевую роль в оптимизации производительности запросов. Они работают так же, как и индексы в традиционных базах данных: создают специальную структуру данных, которая позволяет быстро находить документы по определенному полю или набору полей без необходимости сканировать всю коллекцию.

### 1. Зачем нужны индексы?

Без индексов, чтобы выполнить запрос, MongoDB приходится сканировать каждый документ в коллекции. Этот процесс называется **сканированием коллекции** (Collection Scan) и очень неэффективен, особенно на больших наборах данных.

Индексы значительно ускоряют операции чтения, так как позволяют MongoDB найти необходимые документы, просматривая только небольшую часть данных.

### 2. Типы индексов

MongoDB поддерживает различные типы индексов, каждый из которых предназначен для решения определенных задач:

- **Индекс по одному полю (Single Field Index):** Самый простой тип индекса. Создается на одном поле и может быть восходящим (1) или нисходящим (-1).
    
- **Составной индекс (Compound Index):** Индекс на нескольких полях. Порядок полей в составном индексе имеет значение, так как MongoDB использует его для сортировки и фильтрации.
    
- **Индексы массивов (Multikey Index):** Создаются, когда индексируемое поле содержит массив. MongoDB создает отдельную запись в индексе для каждого элемента массива.
    
- **Текстовые индексы (Text Index):** Используются для поиска по строкам. Они поддерживают поиск по словам и фразам в тексте.
    
- **Геопространственные индексы (Geospatial Index):** Используются для эффективных запросов к геопространственным данным, например, для поиска объектов в определенном радиусе.
    
- **Уникальные индексы (Unique Index):** Обеспечивают уникальность значений в индексированном поле. Если вы попытаетесь вставить документ с уже существующим значением, операция завершится с ошибкой.

### 3. Основные операции с индексами

#### Создание индекса
Для создания индекса используется метод `db.collection.createIndex()`.

**Синтаксис:**
```js
db.collection.createIndex({ <поле1>: <порядок>, <поле2>: <порядок> ... });
```

**Пример:** Создание восходящего индекса на поле `name`.
```js
db.users.createIndex({ "name": 1 });
```

**Пример (составной индекс):** Создание индекса на полях `age` (восходящий) и `score` (нисходящий).
```js
db.users.createIndex({ "age": 1, "score": -1 });
```

> **Важно:** Порядок полей в составном индексе имеет значение. MongoDB может использовать этот индекс для запросов по `age` и `age + score`, но не только по `score`.

#### Просмотр индексов
Чтобы увидеть, какие индексы существуют в коллекции, используйте метод `db.collection.getIndexes()`.
```js
db.users.getIndexes();
```

#### Удаление индекса
Для удаления индекса используется метод `db.collection.dropIndex()`.
```js
db.users.dropIndex({ "name": 1 });
```

> **Совет:** Чтобы удалить все индексы, кроме стандартного `_id`, используйте `db.collection.dropIndexes()`.

### 4. Практическое применение и оптимизация

- **Правило `ESR` (Equality, Sort, Range):** При создании составных индексов, поля, используемые в запросах на равенство (`$eq`, `$in`), должны идти первыми. Затем следуют поля для сортировки (`$sort`), и только потом — для диапазона (`$gt`, `$lt`).
    
- **Проверка производительности запроса:** Используйте метод `db.collection.explain("executionStats")` для анализа, как MongoDB выполняет запрос. Если в выводе вы видите `COLLSCAN`, это означает, что MongoDB сканирует всю коллекцию, и, вероятно, нужно создать или изменить индекс.
        
```js
    db.users.find({ "age": { $gt: 25 } }).explain("executionStats");
```
    

### 5. Ограничения и компромиссы

- **Индексы занимают место на диске** и потребляют оперативную память.    
- **Индексы замедляют операции записи** (insert, update, delete), так как при каждом изменении документа MongoDB должен также обновлять соответствующие индексы.
    
Создание индексов — это всегда компромисс между производительностью чтения и затратами на запись. Поэтому следует создавать индексы только для тех полей, по которым часто выполняются запросы.


### Правило ESR
Правило **ESR** (Equality, Sort, Range) используется для создания составных индексов в MongoDB, чтобы оптимизировать запросы, которые одновременно фильтруют, сортируют и используют диапазон значений.

### Пример применения правила ESR

Предположим, у нас есть коллекция `orders` с документами, содержащими информацию о заказах:

```js
{
  "_id": ObjectId("..."),
  "customer_id": "cust123",
  "status": "completed",
  "order_date": ISODate("2024-01-15T10:00:00Z"),
  "amount": 250
}
```

Мы хотим выполнить следующий запрос: Найти все **завершенные** (`status: "completed"`) заказы, отсортировать их по **дате** (`order_date`) и найти те, где сумма заказа (`amount`) находится в диапазоне от **100 до 500**.

#### Запрос
```js
db.orders.find({
  "status": "completed",
  "amount": { $gte: 100, $lte: 500 }
}).sort({ "order_date": -1 });
```

#### Создание индекса по правилу ESR
Согласно правилу ESR, поля в составном индексе должны располагаться в следующем порядке:
1. **E** (Equality): Поля, используемые в запросах на равенство. В нашем случае это `status`.
2. **S** (Sort): Поля, используемые для сортировки. Это `order_date`.
3. **R** (Range): Поля, используемые для запросов по диапазону. Это `amount`.
    
Следовательно, правильный индекс будет выглядеть так:
```js
db.orders.createIndex({
  "status": 1,
  "order_date": -1,
  "amount": 1
});
```

#### Объяснение:
- `"status": 1` - ставим на первое место, так как это поле используется для точного соответствия (`"status": "completed"`).
- `"order_date": -1` - ставим на второе место, так как по этому полю происходит сортировка. Направление (-1) должно совпадать с запросом, чтобы MongoDB мог использовать индекс для сортировки напрямую.
- `"amount": 1` - ставим на последнее место, так как это поле используется для запроса по диапазону (`$gte`, `$lte`).
    
Этот индекс позволит MongoDB выполнить запрос максимально эффективно: сначала он найдет все документы со `status: "completed"`, затем отсортирует их по `order_date`, и в конце отфильтрует по диапазону `amount`, при этом сканируя только необходимые данные. Без такого индекса, MongoDB пришлось бы сканировать всю коллекцию.