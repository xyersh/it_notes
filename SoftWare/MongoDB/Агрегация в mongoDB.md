Агрегация в MongoDB — это процесс обработки данных для получения вычисленных результатов. Она позволяет анализировать и трансформировать документы, объединяя данные из нескольких документов в один результат. В отличие от простых запросов `find()`, агрегация дает вам возможность выполнять сложные операции, аналогичные `GROUP BY`, `SUM`, `AVG` и `JOIN` в SQL.

### Что такое `Aggregation Pipeline` (Конвейер агрегации)?

Основной инструмент для агрегации в MongoDB — это **Aggregation Pipeline** (конвейер агрегации). Это фреймворк, состоящий из стадий (stages), которые последовательно обрабатывают документы. Каждый этап берет на вход результаты предыдущего и передает свой результат следующему.

Структура конвейера выглядит так: `[ { <стадия1> }, { <стадия2> }, { <стадия3> }, ... ]`

Такой подход позволяет создавать гибкие и мощные запросы, выполняя сложную обработку данных за один проход.

---


### Основные стадии (Stages) конвейера

Каждая стадия выполняет определенную операцию над данными. Вот наиболее часто используемые:

- **`$match`**: Фильтрует документы, оставляя только те, которые соответствуют заданным условиям. Это похоже на операцию `find()`. Рекомендуется использовать эту стадию в самом начале конвейера, чтобы уменьшить объем данных для последующих операций.
- **`$group`**: Группирует входящие документы по указанному выражению. Эта стадия используется для вычисления агрегированных значений для каждой группы.
- **`$project`**: Формирует новые документы. С помощью `$project` можно добавлять, удалять или переименовывать поля, а также создавать вычисляемые поля.
- **`$sort`**: Сортирует документы на основе указанных полей.
- **`$limit`**: Ограничивает количество документов, передаваемых на следующий этап.    
- **`$skip`**: Пропускает указанное количество документов.

---

### Практический пример
  
Предположим, у нас есть коллекция `sales` с данными о продажах:
```js
{ "_id": 1, "product": "T-shirt", "category": "apparel", "quantity": 10, "price": 15 }
{ "_id": 2, "product": "Jeans", "category": "apparel", "quantity": 5, "price": 50 }
{ "_id": 3, "product": "Phone", "category": "electronics", "quantity": 2, "price": 400 }
{ "_id": 4, "product": "T-shirt", "category": "apparel", "quantity": 8, "price": 15 }
```

Наша задача: **подсчитать общее количество проданных товаров для каждой категории и отсортировать результат.**

Для этого нам понадобится конвейер из трех стадий: `$group`, `$project` и `$sort`.

#### 1. Стадия `$group`

Мы хотим сгруппировать документы по полю `category`. Внутри каждой группы мы посчитаем общую сумму поля `quantity`.

JSON

```
{
  $group: {
    _id: "$category",
    totalQuantity: { $sum: "$quantity" }
  }
}
```

- `_id`: Это поле-идентификатор для группы. Мы указываем `"$category"`, что означает группировку по уникальным значениям поля `category`.
    
- `totalQuantity`: Это новое поле, которое мы создаем. С помощью оператора `$sum` мы суммируем значения поля `quantity` для всех документов в группе.
    

#### 2. Стадия `$project`

Эта стадия не является обязательной в этом примере, но она полезна для того, чтобы сделать вывод более читаемым, например, переименовать `_id` в `category`.

JSON

```
{
  $project: {
    _id: 0, // Исключаем поле _id из результата
    category: "$_id", // Переименовываем _id в category
    totalQuantity: 1 // Включаем поле totalQuantity
  }
}
```

#### 3. Стадия `$sort`

Теперь отсортируем результат по общему количеству по убыванию.

JSON

```
{
  $sort: { "totalQuantity": -1 }
}
```

#### Полный запрос

Объединяя все стадии, получаем полный запрос агрегации:

JavaScript

```
db.sales.aggregate([
  {
    $group: {
      _id: "$category",
      totalQuantity: { $sum: "$quantity" }
    }
  },
  {
    $project: {
      _id: 0,
      category: "$_id",
      totalQuantity: 1
    }
  },
  {
    $sort: { "totalQuantity": -1 }
  }
]);
```

**Ожидаемый результат:**

JSON

```
[
  { "category": "apparel", "totalQuantity": 18 },
  { "category": "electronics", "totalQuantity": 2 }
]
```

Таким образом, агрегация позволяет вам проводить сложный анализ данных прямо на сервере базы данных, что значительно эффективнее, чем извлекать все данные и обрабатывать их на стороне приложения.