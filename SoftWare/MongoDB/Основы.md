
### Глоссарий
- **База данных** — это физический контейнер для коллекций. Один экземпляр MongoDB может содержать несколько баз данных, каждая из которых имеет свой собственный набор коллекций и прав доступа.
- **Коллекция** — это группа документов. Она похожа на таблицу в реляционной базе данных. Коллекция не требует строгой схемы, что позволяет хранить в ней документы с разными наборами полей.
- **Документ** — это основная единица данных в MongoDB. По сути, это набор пар "ключ-значение", аналогичный строке в реляционной базе данных. Документы обладают гибкой схемой, что означает, что поля могут быть разными в разных документах одной коллекции.
- **BSON** (Binary JSON) — это бинарный формат сериализации, который MongoDB использует для хранения документов. Он похож на JSON, но более эффективен и поддерживает больше типов данных, например, `Date` и `Binary data`.
- **\_id** — это уникальный идентификатор каждого документа в коллекции. Если вы не укажете его при вставке документа, MongoDB автоматически сгенерирует `_id` для вас.
- **Индексы** — это специальные структуры данных, которые улучшают производительность запросов. Они работают аналогично индексам в реляционных базах данных, позволяя быстро находить документы по определенным полям.
- **Встроенные документы и массивы** -В MongoDB можно вкладывать документы друг в друга и использовать массивы. Это позволяет моделировать сложные иерархические отношения в одном документе, что часто удобнее, чем использование нескольких таблиц и `JOIN` в реляционных БД. Например, документ `order` может содержать массив `items`.
- **Агрегация** - это процесс обработки данных для получения вычисленных результатов. В MongoDB для этого используется **фреймворк агрегации** (`Aggregation Framework`), который позволяет выполнять сложные операции, такие как группировка, фильтрация и трансформация данных, похожие на `GROUP BY` в SQL.
- **Схемы и валидация** - Хотя MongoDB является **NoSQL** базой данных без строгой схемы, можно использовать **валидацию схемы** для обеспечения определенной структуры данных в коллекции. Это позволяет настраивать правила для полей, чтобы убедиться, что они имеют ожидаемый тип и формат.
- **Операторы** - идентификаторы начинающиеся с символа **$** и служащие для нужд поиска, обновления, агрегации, в зависимости от контекста их использования

### Установка  из  docker-образа и первичный запуск
`docker run -d --name <MONGO_CONTAINER> -p 27017:27017 -v <NEW_VOLUME> --network <DOCKER_NETWORK> -e MONGO_INITDB_ROOT_USERNAME=<USER> -e MONGO_INITDB_ROOT_PASSWORD=<PASWORD> <MONGO_IMAGE>`


### Запуск контейнера
`docker exec -it <MONGO_CONTAINER> mongosh "mongodb://<USER>:<PASSWORD>@127.0.0.1:27017"`

### Система сипользуемых типов
MongoDB использует **BSON (Binary JSON)** как свой основной формат хранения данных. BSON — это расширенный бинарный формат, который похож на JSON, но включает в себя больше типов данных, что делает его более универсальным и эффективным для работы с базой данных. В отличие от JSON, который поддерживает только ограниченный набор типов (строки, числа, булевы значения, массивы, объекты и `null`), BSON добавляет такие типы, как `Date`, `ObjectID`, `Binary data` и другие.

| Тип             | Описание                                                                                           | Пример                                 |
| --------------- | -------------------------------------------------------------------------------------------------- | -------------------------------------- |
| **Null**        | Отсутствие значения.                                                                               | `null`                                 |
| **String**      | Строки UTF-8.                                                                                      | `"Hello, World!"`                      |
| **Number**      | Целые числа (32-битные и 64-битные) и числа с плавающей запятой (64-битные).                       | `42`, `3.14`                           |
| **Boolean**     | Логические значения `true` или `false`.                                                            | `true`                                 |
| **Object**      | Вложенные документы.                                                                               | `{ "city": "Paris" }`                  |
| **Array**       | Массивы значений.                                                                                  | `["apple", "banana", "cherry"]`        |
| **ObjectID**    | Уникальный 12-байтовый идентификатор, используемый в качестве первичного ключа `_id`.              | `ObjectId("60c72b2f9b2d8c3f4e91f1a5")` |
| **Binary data** | Бинарные данные (например, изображения, видео).                                                    | `BinData(0, "MTIzNDU2NzgwYQ==")`       |
| **Date**        | Даты и время. Хранится в виде 64-битного целого числа (миллисекунды с начала эпохи Unix).          | `ISODate("2025-09-24T12:00:00Z")`      |
| **Timestamp**   | 64-битное значение для временных меток, обычно используется для внутреннего использования MongoDB. | `Timestamp(1632512000, 1)`             |
| **Decimal128**  | Десятичные числа с высокой точностью, полезны для финансовых вычислений.                           | `NumberDecimal("99.99")`               |

#### Примеры использования и объяснения
##### **Объект и строка**
Документ о пользователе может содержать строку для имени и вложенный объект для адреса. Это демонстрирует гибкость схемы:
```js
{
  "_id": ObjectId("60c72b2f9b2d8c3f4e91f1a5"),
  "name": "Иван Петров",
  "contact": {
    "email": "ivan.p@example.com",
    "phone": "123-456-7890"
  }
}
```
**Объяснение:** Поле `name` имеет тип **String**, а поле `contact` — тип **Object**, содержащий другие поля.

##### **Дата и число**
Документ о заказе часто использует тип **Date** для отметки времени создания и **Number** для количества и цены.
```js
{
  "_id": ObjectId("60c72b3b9b2d8c3f4e91f1a6"),
  "product_id": 101,
  "quantity": 2,
  "price": 49.99,
  "order_date": ISODate("2025-09-24T18:30:00Z")
}
```
**Объяснение:** `price` — это **Number** (с плавающей запятой), а `order_date` — это **Date**, что позволяет выполнять запросы по времени, например, искать заказы, сделанные в определенный день.

##### **Массив**
Поле, которое может содержать несколько значений, например, теги или список навыков, идеально подходит для типа **Array**.
```js
{
  "_id": ObjectId("60c72b4c9b2d8c3f4e91f1a7"),
  "title": "Урок по MongoDB",
  "tags": ["database", "nosql", "mongodb"]
}
```
**Объяснение:** Поле `tags` является **Array** со строковыми элементами. MongoDB создает **multikey-индекс** на таких полях, позволяя эффективно искать документы, содержащие определенный элемент в массиве.

##### **ObjectID**
Это стандартный тип для уникального идентификатора документа. Он создается автоматически, если не указано другое значение.
```js
{
  "_id": ObjectId("60c72b2f9b2d8c3f4e91f1a5")
}
```
**Объяснение:** `ObjectID` уникален во всех коллекциях и базах данных и включает в себя метку времени, идентификатор машины и другие данные, что обеспечивает его высокую уникальность.

##### **Binary data (`BinData`)**
Тип `BinData` используется для хранения бинарных данных, таких как изображения, аудиофайлы, видео или зашифрованные данные, непосредственно в документе MongoDB. Это полезно, когда размер файла невелик, и его удобнее хранить вместе с метаданными.
```js
    {
      "_id": ObjectId("..."),
      "user_name": "Anna",
      "profile_picture": BinData(0, "R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==")
    }
```
**Объяснение:** В поле `profile_picture` хранятся бинарные данные, закодированные в формате Base64, вместе с подтипом `0` (Generic), который указывает на тип данных.

##### **Date (`ISODate`)**
Тип `Date` хранит дату и время в формате Unix Epoch (количество миллисекунд с 1 января 1970 года). Это обеспечивает универсальный и независимый от часового пояса способ хранения времени.
```js
    {
      "_id": ObjectId("..."),
      "title": "Новая статья",
      "created_at": ISODate("2024-09-24T12:00:00Z")
    }
```
**Объяснение:** `ISODate` позволяет эффективно выполнять запросы по диапазонам времени, например, найти все статьи, опубликованные за последний месяц.

##### **Timestamp**
Тип `Timestamp` используется для внутреннего контроля MongoDB. Он состоит из двух частей: времени (в секундах) и инкрементального значения. Он **не предназначен** для хранения обычных дат и времени, так как его значение не зависит от часового пояса и может быть непредсказуемым. Главное его назначение — отслеживать последовательность операций, что важно для репликации и восстановления.
```js
    {
      "oplog_entry": Timestamp(1632512000, 1)
    }
```
**Объяснение:** Этот тип используется в журналах операций (oplog) для отслеживания порядка изменений в репликасете.

##### **Decimal128**
Тип `Decimal128` используется для хранения чисел с высокой точностью. Он идеален для финансовых и денежных данных, так как позволяет избежать проблем с точностью, которые могут возникнуть при использовании чисел с плавающей запятой (`Double`).
```js
    {
      "_id": ObjectId("..."),
      "product_name": "Luxury Watch",
      "price": NumberDecimal("9999.99")
    }
```
**Объяснение:** Использование `NumberDecimal` гарантирует точное представление числа `9999.99`, что предотвращает ошибки округления при расчетах.


### **Основные команды**
- `db.<collection_name>.insertOne(<JSON_OBJ>)`: вставляет **один** документ в коллекцию. Если коллекции нет - она будет создана неявно.
- `db.<collection>.insertMany(<JSON_ARR>)`: вставляет **несколько** документов. Если коллекции нет - она будет создана неявно.
- `db.<collection_name>.find([<CONDITION>])`: выполняет поиск документов. Можно использовать без параметров для получения всех документов в коллекции или с запросами для фильтрации.
	- `db.<collection_name>.find({age: 40})` - искать документы, у которых ключ "age" = 40
	- `db.<collection_name>.find({age: {$lt: 40}})` - искать документы, у которых ключ "age" < 40
	-  `db.<collection_name>.find({age: {$lte: 40}})` - искать документы, у которых ключ "age" <= 40
	-  `db.<collection_name>.find({age: {$gt: 40}})` - искать документы, у которых ключ "age" > 40
	-  `db.<collection_name>.find({age: {$gte: 40}})` - искать документы, у которых ключ "age" >= 40
	- `db.<collection_name>.find({age: 40},{name: 1})` - показать только поле "name" + спецполе  `"_id"`
	- `db.<collection_name>.find({age: 40},{name: 1, _id: 0})` - показать только поле "name" без спецполя  `"_id"`
	- `db.<collection_name>.find({age: {$in: [40, 38]})` -  показать документы, у ноторых значения поля `age` имеют значения из списка (37, 40)
	- `db.<collection_name>.find({age: {$gte: 18, $lte: 60})` - поиск с фильтрацией по значению age относящегося к диапазону от 18 до 60 лет.
	- `db.<collection_name>.find({$and: {age: {$gt: 20}}, {email: {$exist: false}}})` - демотстрация AND. поиск записей у которых возраст юольше 20 И отсутствует почтовый ящик. В случае AND `$and:` омжно не писать и перечислить всем условия через запятую. 
	- `db.<collection_name>.find({$or: {age: {$gt: 20}}, {email: {$exist: false}}})` - демотстрация OR. поиск записей у которых возраст юольше 20 ИЛИ отсутствует почтовый ящик.
	- `db.collection.find({$not: {name: "Dmitriy"}})` - демонстрация НЕ. поиск записей, у которых поле `name` != "Dmitriy". 
- `db.<collection_name>.find([<CONDITION>]).sort(<PARAM>)` - сортировка найденных документов. В него передаётся объект, где `1` означает **сортировку по возрастанию**, а `-1` — **по убыванию**.
-  `db.collection.find().sort({name: 1})` — сортирует документы по полю `name` в алфавитном порядке.
		- `db.collection.find().sort({date: -1})` — сортирует по полю `date` от самого нового к самому старому.
- `db.<collection_name>.find([<CONDITION>]).limit(<SIZE>)` используется для ограничения количества возвращаемых документов. В него передаётся число, указывающее, сколько документов нужно получить.
		- `db.collection.find().limit(10)` — возвращает только первые `10` документов.
		- `db.collection.find().sort({views: -1}).limit(5)` — находит `5` самых просматриваемых документов.
- `db.<collection_name>.find([<CONDITION>]).skip(<ROWS>)` используется для пропуска определённого количества документов в выборке. Он часто применяется вместе с `limit()` для реализации пагинации.
		- `db.collection.find().skip(5)` — пропускает первые `5` документов и возвращает все остальные.
			- `db.collection.find().limit(10).skip(10)` — используется для получения второй "страницы" из `10` документов (пагинация).
- `db.getCollection("COLLECTION_NAME").find({})` - аналогична предыдущей функции
- `db.<collection_name>.findOne(<CONDITION>)`: возвращает **первый** найденный документ.
- `db.<collection_name>.updateOne()`: изменяет **один** документ, соответствующий условию.
- `db.<collection_name>.updateMany()`: изменяет **все** документы, соответствующие условию.
- `db.<collection_name>.deleteOne()`: удаляет **один** документ.
- `db.<collection_name>.deleteMany()`: удаляет **все** документы, соответствующие условию.
- `db.<collection_name>.aggregate()`: используется для выполнения сложных операций, таких как группировка, фильтрация и агрегация данных.


### **Команды для управления базой данных и коллекциями**

- `show dbs`: показывает список всех баз данных.
- `use <database_name>`: переключает контекст на указанную базу данных. Если базы данных нет, она создаётся.
- `db.createCollection(<collection_name>)` - явно создать коллекцию в активной БД.
- `show collections`: показывает список всех коллекций в текущей базе данных.
- `db.<collection_name>.drop()`: удаляет коллекцию.
- `db.dropDatabase()`: удаляет текущую базу данных.

### **Дополнительные команды**
- `db.<collection_name>.countDocuments([CONDITION])`: подсчитывает количество документов, соответствующих условию.
- `db.<collection_name>.estimatedDocumentCount()`: возвращает приблизительное количество документов в коллекции, что быстрее, чем `countDocuments()`, но менее точное.
- `db.<collection_name>.createIndex({ <поле1>: <порядок>, <поле2>: <порядок> ... })`: создаёт индекс для поля или нескольких полей, что значительно ускоряет поиск.
- `db.<collection_name>.getIndexes()` - просмотр всех индексов в коллекции.
- `db.<collection_name>.dropIndex({<поле>: <порядок>})` - удалить индекс по полю и порядку.
- `db.<collection_name>.dropIndexes()` - удалить все индексы коллекции, кроме `_id`
- `db.<collection_name>.distinct()`: возвращает массив уникальных значений для указанного поля.


### Операторы

####  Операторы запросов (Query Operators)

Эти операторы используются для фильтрации документов в запросах. Они позволяют сравнивать значения полей, проверять их наличие и работать с массивами.

 ##### **Операторы сравнения (Comparison)**
- `$eq` (equal): Соответствует значениям, которые равны указанному.
- `$ne` (not equal): Соответствует всем значениям, кроме указанного.
- `$gt` (greater than): Соответствует значениям, которые больше указанного.
- `$gte` (greater than or equal): Соответствует значениям, которые больше или равны указанному.
- `$lt` (less than): Соответствует значениям, которые меньше указанного.
- `$lte` (less than or equal): Соответствует значениям, которые меньше или равны указанному.
- `$in`: Соответствует значениям, которые находятся в указанном массиве.
- `$nin` (not in): Соответствует значениям, которые не находятся в указанном массиве.

**пример:**
```js
db.products.find({ "price": { $gte: 100, $lt: 200 } });
```
**Объяснение:** Этот запрос находит все документы в коллекции `products`, где значение поля `price` находится в диапазоне от 100 до 199.

##### **Логические операторы (Logical)**
- `$and`: Объединяет несколько условий запроса `AND` (логическое «и»). 
- `$or`: Объединяет несколько условий запроса `OR` (логическое «или»).
- `$not`: Инвертирует результат выражения запроса.
- `$nor`: Объединяет несколько условий запроса `NOR` (логическое «ни то, ни другое»).

**пример**
```js
db.users.find({ $or: [{ "status": "active" }, { "role": "admin" }] });
```
**Объяснение:** Запрос возвращает пользователей, у которых либо `status` "active", либо `role` "admin".


##### **Операторы элементов (Element)**
- `$exists`: Соответствует документам, содержащим указанное поле. 
- `$type`: Выбирает документы, где значение поля имеет указанный тип BSON.
    
**Пример:**
```js
db.users.find({ "phone": { $exists: true } });
```
**Объяснение:** Запрос находит всех пользователей, у которых есть поле `phone`.

##### **Операторы массивов (Array)**
- `$all`: Соответствует массивам, которые содержат все указанные элементы. 
- `$size`: Соответствует массивам, имеющим указанное количество элементов.
- `$elemMatch`: Соответствует документам, если хотя бы один элемент массива соответствует всем указанным условиям.
**Пример:**

```js
db.tags.find({ "tags": { $all: ["mongodb", "database"] } });
```
**Объяснение:** Этот запрос находит документы, в которых поле `tags` является массивом и содержит и "mongodb", и "database".

#### Операторы обновлений (Update Operators)

Эти операторы используются для изменения документов, не заменяя их целиком.
##### **Операторы полей (Field)**
- `$set`: Устанавливает значение поля.
- `$unset`: Удаляет указанное поле из документа.
- `$inc`: Увеличивает или уменьшает значение поля на указанное число.
- `$mul`: Умножает значение поля на указанное число.
- `$rename`: Переименовывает поле.
**Пример:**

```js
db.users.updateOne({ "username": "johndoe" }, { $set: { "status": "inactive" } });
```
**Объяснение:** Запрос обновляет документ пользователя "johndoe", устанавливая значение поля `status` на "inactive".

#### Операторы агрегации (Aggregation Operators)

Эти операторы используются в рамках Aggregation Framework для обработки и анализа данных.
- `$match`: Фильтрует документы, чтобы передать только те, которые соответствуют условиям, на следующий этап.
- `$group`: Группирует входные документы по указанному выражению идентификатора и применяет к каждой группе операторы-аккумуляторы.
- `$project`: Формирует новые документы, включая, исключая или переименовывая поля.
- `$sum`: Вычисляет общую сумму числовых значений.
- `$avg`: Вычисляет среднее значение числовых значений.
    
**Пример:**

```js
db.orders.aggregate([
  { $match: { "status": "completed" } },
  { $group: { _id: "$customer_id", total_spent: { $sum: "$amount" } } }
]);
```
**Объяснение:** Этот конвейер агрегации сначала фильтрует заказы по статусу "completed", а затем группирует их по `customer_id` и вычисляет общую сумму (`total_spent`) для каждого клиента.
>>>>>>> origin/main
