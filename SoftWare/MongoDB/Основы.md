
### Глоссарий
- **База данных** — это физический контейнер для коллекций. Один экземпляр MongoDB может содержать несколько баз данных, каждая из которых имеет свой собственный набор коллекций и прав доступа.
- **Коллекция** — это группа документов. Она похожа на таблицу в реляционной базе данных. Коллекция не требует строгой схемы, что позволяет хранить в ней документы с разными наборами полей.
- **Документ** — это основная единица данных в MongoDB. По сути, это набор пар "ключ-значение", аналогичный строке в реляционной базе данных. Документы обладают гибкой схемой, что означает, что поля могут быть разными в разных документах одной коллекции.
- **BSON** (Binary JSON) — это бинарный формат сериализации, который MongoDB использует для хранения документов. Он похож на JSON, но более эффективен и поддерживает больше типов данных, например, `Date` и `Binary data`.
- **\_id** — это уникальный идентификатор каждого документа в коллекции. Если вы не укажете его при вставке документа, MongoDB автоматически сгенерирует `_id` для вас.
- **Индексы** — это специальные структуры данных, которые улучшают производительность запросов. Они работают аналогично индексам в реляционных базах данных, позволяя быстро находить документы по определенным полям.
- **Встроенные документы и массивы** -В MongoDB можно вкладывать документы друг в друга и использовать массивы. Это позволяет моделировать сложные иерархические отношения в одном документе, что часто удобнее, чем использование нескольких таблиц и `JOIN` в реляционных БД. Например, документ `order` может содержать массив `items`.
- **Агрегация** - это процесс обработки данных для получения вычисленных результатов. В MongoDB для этого используется **фреймворк агрегации** (`Aggregation Framework`), который позволяет выполнять сложные операции, такие как группировка, фильтрация и трансформация данных, похожие на `GROUP BY` в SQL.
- **Схемы и валидация** - Хотя MongoDB является **NoSQL** базой данных без строгой схемы, можно использовать **валидацию схемы** для обеспечения определенной структуры данных в коллекции. Это позволяет настраивать правила для полей, чтобы убедиться, что они имеют ожидаемый тип и формат.
- **Операторы** - идентификаторы начинающиеся с символа **$** и служащие для нужд поиска, обновления, агрегации, в зависимости от контекста их использования

### Установка  из  docker-образа и первичный запуск
`docker run -d --name <MONGO_CONTAINER> -p 27017:27017 -v <NEW_VOLUME> --network <DOCKER_NETWORK> -e MONGO_INITDB_ROOT_USERNAME=<USER> -e MONGO_INITDB_ROOT_PASSWORD=<PASWORD> <MONGO_IMAGE>`


### Запуск контейнера
`docker exec -it <MONGO_CONTAINER> mongosh "mongodb://<USER>:<PASSWORD>@127.0.0.1:27017"`



### **Основные команды**
- `db.<collection_name>.insertOne(<JSON_OBJ>)`: вставляет **один** документ в коллекцию. Если коллекции нет - она будет создана неявно.
- `db.<collection>.insertMany(<JSON_ARR>)`: вставляет **несколько** документов. Если коллекции нет - она будет создана неявно.
- `db.<collection_name>.find([<CONDITION>])`: выполняет поиск документов. Можно использовать без параметров для получения всех документов в коллекции или с запросами для фильтрации.
	- `sort(<PARAM>)` - сортировка найденных документов. В него передаётся объект, где `1` означает **сортировку по возрастанию**, а `-1` — **по убыванию**.
		-  `db.collection.find().sort({name: 1})` — сортирует документы по полю `name` в алфавитном порядке.
		- `db.collection.find().sort({date: -1})` — сортирует по полю `date` от самого нового к самому старому.
	- `limit()` используется для ограничения количества возвращаемых документов. В него передаётся число, указывающее, сколько документов нужно получить.
		- `db.collection.find().limit(10)` — возвращает только первые `10` документов.
		- `db.collection.find().sort({views: -1}).limit(5)` — находит `5` самых просматриваемых документов.
	- `skip()` используется для пропуска определённого количества документов в выборке. Он часто применяется вместе с `limit()` для реализации пагинации.
		- `db.collection.find().skip(5)` — пропускает первые `5` документов и возвращает все остальные.
			- `db.collection.find().limit(10).skip(10)` — используется для получения второй "страницы" из `10` документов (пагинация).
- `db.getCollection("COLLECTION_NAME").find({})` - аналогична предыдущей функции
- `db.<collection_name>.findOne(<CONDITION>)`: возвращает **первый** найденный документ.
- `db.<collection_name>.updateOne()`: изменяет **один** документ, соответствующий условию.
- `db.<collection_name>.updateMany()`: изменяет **все** документы, соответствующие условию.
- `db.<collection_name>.deleteOne()`: удаляет **один** документ.
- `db.<collection_name>.deleteMany()`: удаляет **все** документы, соответствующие условию.
- `db.<collection_name>.aggregate()`: используется для выполнения сложных операций, таких как группировка, фильтрация и агрегация данных.


### **Команды для управления базой данных и коллекциями**

- `show dbs`: показывает список всех баз данных.
- `use <database_name>`: переключает контекст на указанную базу данных. Если базы данных нет, она создаётся.
- `db.createCollection(<collection_name>)` - явно создать коллекцию в активной БД.
- `show collections`: показывает список всех коллекций в текущей базе данных.
- `db.<collection_name>.drop()`: удаляет коллекцию.
- `db.dropDatabase()`: удаляет текущую базу данных.

### **Дополнительные команды**
- `db.<collection_name>.countDocuments()`: подсчитывает количество документов, соответствующих условию.
- `db.<collection_name>.estimatedDocumentCount()`: возвращает приблизительное количество документов в коллекции, что быстрее, чем `countDocuments()`, но менее точное.
- `db.<collection_name>.createIndex({ <поле1>: <порядок>, <поле2>: <порядок> ... })`: создаёт индекс для поля или нескольких полей, что значительно ускоряет поиск.
- `db.<collection_name>.getIndexes()` - просмотр всех индексов в коллекции.
- `db.<collection_name>.dropIndex({<поле>: <порядок>})` - удалить индекс по полю и порядку.
- `db.<collection_name>.dropIndexes()` - удалить все индексы коллекции, кроме `_id`
- `db.<collection_name>.distinct()`: возвращает массив уникальных значений для указанного поля.


### Операторы

####  Операторы запросов (Query Operators)

Эти операторы используются для фильтрации документов в запросах. Они позволяют сравнивать значения полей, проверять их наличие и работать с массивами.

 ##### **Операторы сравнения (Comparison)**
- `$eq` (equal): Соответствует значениям, которые равны указанному.
- `$ne` (not equal): Соответствует всем значениям, кроме указанного.
- `$gt` (greater than): Соответствует значениям, которые больше указанного.
- `$gte` (greater than or equal): Соответствует значениям, которые больше или равны указанному.
- `$lt` (less than): Соответствует значениям, которые меньше указанного.
- `$lte` (less than or equal): Соответствует значениям, которые меньше или равны указанному.
- `$in`: Соответствует значениям, которые находятся в указанном массиве.
- `$nin` (not in): Соответствует значениям, которые не находятся в указанном массиве.

**пример:**
```js
db.products.find({ "price": { $gte: 100, $lt: 200 } });
```
**Объяснение:** Этот запрос находит все документы в коллекции `products`, где значение поля `price` находится в диапазоне от 100 до 199.

##### **Логические операторы (Logical)**
- `$and`: Объединяет несколько условий запроса `AND` (логическое «и»). 
- `$or`: Объединяет несколько условий запроса `OR` (логическое «или»).
- `$not`: Инвертирует результат выражения запроса.
- `$nor`: Объединяет несколько условий запроса `NOR` (логическое «ни то, ни другое»).

**пример**
```js
db.users.find({ $or: [{ "status": "active" }, { "role": "admin" }] });
```
**Объяснение:** Запрос возвращает пользователей, у которых либо `status` "active", либо `role` "admin".


##### **Операторы элементов (Element)**
- `$exists`: Соответствует документам, содержащим указанное поле. 
- `$type`: Выбирает документы, где значение поля имеет указанный тип BSON.
    
**Пример:**
```js
db.users.find({ "phone": { $exists: true } });
```
**Объяснение:** Запрос находит всех пользователей, у которых есть поле `phone`.

##### **Операторы массивов (Array)**
- `$all`: Соответствует массивам, которые содержат все указанные элементы. 
- `$size`: Соответствует массивам, имеющим указанное количество элементов.
- `$elemMatch`: Соответствует документам, если хотя бы один элемент массива соответствует всем указанным условиям.
**Пример:**

```js
db.tags.find({ "tags": { $all: ["mongodb", "database"] } });
```
**Объяснение:** Этот запрос находит документы, в которых поле `tags` является массивом и содержит и "mongodb", и "database".

#### Операторы обновлений (Update Operators)

Эти операторы используются для изменения документов, не заменяя их целиком.
##### **Операторы полей (Field)**
- `$set`: Устанавливает значение поля.
- `$unset`: Удаляет указанное поле из документа.
- `$inc`: Увеличивает или уменьшает значение поля на указанное число.
- `$mul`: Умножает значение поля на указанное число.
- `$rename`: Переименовывает поле.
**Пример:**

```js
db.users.updateOne({ "username": "johndoe" }, { $set: { "status": "inactive" } });
```
**Объяснение:** Запрос обновляет документ пользователя "johndoe", устанавливая значение поля `status` на "inactive".

#### Операторы агрегации (Aggregation Operators)

Эти операторы используются в рамках Aggregation Framework для обработки и анализа данных.
- `$match`: Фильтрует документы, чтобы передать только те, которые соответствуют условиям, на следующий этап.
- `$group`: Группирует входные документы по указанному выражению идентификатора и применяет к каждой группе операторы-аккумуляторы.
- `$project`: Формирует новые документы, включая, исключая или переименовывая поля.
- `$sum`: Вычисляет общую сумму числовых значений.
- `$avg`: Вычисляет среднее значение числовых значений.
    
**Пример:**

```js
db.orders.aggregate([
  { $match: { "status": "completed" } },
  { $group: { _id: "$customer_id", total_spent: { $sum: "$amount" } } }
]);
```
**Объяснение:** Этот конвейер агрегации сначала фильтрует заказы по статусу "completed", а затем группирует их по `customer_id` и вычисляет общую сумму (`total_spent`) для каждого клиента.