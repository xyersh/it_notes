Полиморфизм (от греч. «много форм») — это способность программы обрабатывать объекты разных типов через единый интерфейс. Является одним из принципов ООП 
В компьютерных науках выделяют три основных вида полиморфизма.

## Основные виды полиморфизма

### Полиморфизм подтипов (Subtype Polymorphism)

Часто называется **полиморфизмом включения** или **динамическим полиморфизмом**.

- **Суть:** Возможность использовать объект производного типа (потомка) вместо объекта базового типа (родителя). Это основа классического ООП. Метод вызывается в зависимости от реального типа объекта во время выполнения (runtime).
- **Механизм:** Наследование классов или реализация интерфейсов.
- **Пример (псевдокод/Java-like):**
```java
class Animal { void speak() { print("..."); } }
class Dog extends Animal { void speak() { print("Bark"); } }
class Cat extends Animal { void speak() { print("Meow"); } }

// Полиморфизм: переменная типа Animal хранит объект Dog
Animal a = new Dog();
a.speak(); // Выведет "Bark", хотя переменная типа Animal
```

### Параметрический полиморфизм (Parametric Polymorphism)
Часто называется **Дженериками (Generics)**.

- **Суть:** Написание кода, который работает одинаково для любого типа данных. Тип указывается как параметр. Проверка типов происходит на этапе компиляции.
- **Механизм:** Шаблоны (C++), Дженерики (Java, C#, Go 1.18+).
- **Пример:**
```typescript
// Функция работает с любым типом T
function identity<T>(arg: T): T {
    return arg;
}
let output1 = identity<string>("myString");
let output2 = identity<number>(100);
```

### Специальный полиморфизм (Ad-hoc Polymorphism)
Часто называется **перегрузкой (Overloading)**.

- **Суть:** Существование нескольких функций с одним именем, но с разными типами или количеством аргументов. Компилятор выбирает нужную функцию в зависимости от контекста вызова.
- **Механизм:** Перегрузка функций или операторов.
- **Пример:**
```cpp
void print(int i) { ... }
void print(double d) { ... }
void print(string s) { ... }

print(5);      // Вызовет первую
print(3.14);   // Вызовет вторую
```


## Полиморфизм в языке Golang
### Полиморфизм подтипов в Go
Реализован через интерфейсы. В случае с Go интерфейс считается реализованным автоматически, если совпадают сигнатуры методов.
В Go нет наследования структур, но есть **интерфейсы**. Полиморфизм достигается за счет того, что типы реализуют интерфейсы **неявно** (duck typing: «если оно ходит как утка и крякает как утка, значит это утка»).

- **Суть:** Если структура реализует все методы интерфейса, она считается этим интерфейсом.
- **Пример:**
```go
package main

import "fmt"

// 1. Объявляем интерфейс
type Speaker interface {
    Speak() string
}

// 2. Создаем структуры
type Dog struct{}
type Cat struct{}

// 3. Реализуем методы (неявная реализация интерфейса)
func (d Dog) Speak() string {
    return "Bark"
}

func (c Cat) Speak() string {
    return "Meow"
}

// 4. Функция принимает интерфейс (полиморфизм)
func MakeItSpeak(s Speaker) {
    fmt.Println(s.Speak())
}

func main() {
    animals := []Speaker{Dog{}, Cat{}}
    for _, a := range animals {
        MakeItSpeak(a) // Работает и с Dog, и с Cat
    }
}
```


### Параметрический полиморфизм в Go

Реализован начиная с версии 1.18
До выхода Go 1.18 (2022 год) в языке не было настоящих дженериков. Разработчики использовали `interface{}` (пустой интерфейс), что приводило к потере типобезопасности и необходимости в type assertions (приведении типов).

- **Суть:** Теперь в Go есть синтаксис для обобщенных типов.
- **Пример (Go 1.18+):**
```go
package main

import "fmt"

// Функция работает с любым типом, поддерживающим сложение (числа)
func Sum[T int | float64](a, b T) T {
    return a + b
}

// Функция работает с любым типом вообще
func PrintAny[T any](v T) {
    fmt.Println(v)
}

func main() {
    fmt.Println(Sum[int](10, 20))       // 30
    fmt.Println(Sum[float64](1.5, 2.5)) // 4.0
    PrintAny[string("Hello")            // Hello
}
```


### Специальный полиморфизм (Перегрузка) в Go

**В GOLANG ДАННЫЙ ТИП ПОЛИМОРФИЗМА НЕ РЕАЛИЗОВАН !!!**

В Go **нельзя** создавать функции с одинаковым именем в одном пакете, даже если у них разные аргументы.

- **Почему:** Создатели языка считали, что перегрузка усложняет чтение кода и навигацию. Имя функции должно однозначно указывать на её действие.
- **Как обходят:**
    1. **Разные имена:** Вместо `printInt` и `printString` пишут `PrintInt` и `PrintString` (или используют префиксы/суффиксы).
    2. **Вариативные функции:** Функция, принимающая разное количество аргументов одного типа.
    3. **Опциональные параметры через конфигурацию:** Передача структуры настроек.
    4. **Полиморфизм интерфейсов:** Иногда вместо перегрузки методов используют разные реализации интерфейса.
- **Пример (как делают в Go вместо перегрузки):**
```go
// Плохо (не скомпилируется):
// func Draw(x int) {}
// func Draw(x int, y int) {}

// Хорошо (принято в Go):
func DrawCircle(radius int) {}
func DrawRect(width, height int) {}

// Или использование вариативности:
func Sum(nums ...int) int { ... } // Принимает 0, 1 или 100 аргументов
```


## Сводная таблица

|Вид полиморфизма|Суть|Поддержка в Go|Особенности в Go|
|---|---|---|---|
|**Подтипов (Subtype)**|Объект потомка как объект родителя|**Да**|Через **интерфейсы**. Реализация неявная. Нет наследования структур.|
|**Параметрический (Generics)**|Код для любого типа `<T>`|**Да (с v1.18)**|Строгая типизация. До 1.18 использовали `interface{}` (небезопасно).|
|**Специальный (Ad-hoc)**|Перегрузка функций|**Нет**|Запрещено. Используют разные имена функций или вариативные аргументы.|
