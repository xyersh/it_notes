### алгоритмы
- **mark and sweep collection** - состоит из 2х фаз: маркировки и очистки 
- **copying collection** - помечает живые объекты в области памяти **A**; копирует их в область  памяти **B**(объекты при этом располагаются плотно); ссылки переназначаются на объекты в области памяти **B**; область памяти **A** очищается; следующая итерация очистки проходит так же, но области памяти **A** и **B** меняются местами. 
- **mark compact collection** - работает так же как и **mark & sweep**, но дополнительно делает кучу компактной, что позволяет избежать фрагментации. 
- **reference counting** - подсчет ссылок. Производится подсчет ссылок на каждый из имеющихся объектов. Если ссылок на объект <1 то объект удаляется, как ненужный.
  Проблема метода - при циклических ссылках алгоритм рассматривает такие объекты как действительные, даже  если объекты просто ссылаются друг на друга  и не участвуют в полезной работе программы.


### Реализация в Goalng
`Golang` использует алгоритм **concurent mark and sweep** 
Используется трех-цветное маркирование объектов - условно:
- **черные** - живые объекты. 
- **белые** - объекты на удаление
- **серые** - необходимо исследовать объект


#### Принцип поиска
- Mark
	1. Поиск начинается с корня. Корень всегда живой (это глобальная переменная, или объект на стеке)
	2. далее отбираются все объекты на которые ссылается корень. 
	3. найденные объекты помечаются серым.
	4. далее поиск начинается с найденных серых объектов. Все они помечаются черным
	5. все объекты, на которые ссылаются новоиспеченные черные, помечаются серым.
	6. поиск циклично повторяется с пункта 4. до тех пор, пока не останутся только черные и белые объекты. На этом этап маркировки заканчивается

- Sweep
	- 