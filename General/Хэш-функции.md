Хэширование — это фундаментальная концепция в информатике и криптографии. Оно заключается в преобразовании входных данных произвольной длины (сообщения, файла, пароля) в строку фиксированной длины, называемую **хэшем**, **хэш-кодом** или **дайджестом сообщения**.


### Принципы Хэширования

1. **Детерминированность:** Для одних и тех же входных данных всегда должен получаться один и тот же хэш.
2. **Быстрота вычисления:** Вычисление хэша должно происходить быстро.
3. **Необратимость (для криптографических хэшей):** Должно быть вычислительно невозможно восстановить исходные данные по их хэшу. Это называется свойством **односторонней функции**.
4. **Стойкость к коллизиям:** Должно быть очень сложно найти две разные входные строки, которые дают одинаковый хэш (слабая коллизионная стойкость). Должно быть практически невозможно найти вторую входную строку, которая даст тот же хэш, что и заданная первая строка (сильная коллизионная стойкость).

### Назначение Хэширования

Хэширование используется для различных целей:
- **Проверка целостности данных:** Сравнение хэшей позволяет быстро проверить, не был ли файл или сообщение изменены. Если хэш изменился, данные были модифицированы.
- **Хранение паролей:** Вместо того чтобы хранить пароли в открытом виде, хранят их хэши. При проверке пароля хэшируют введенный пароль и сравнивают с сохраненным хэшем. (Используются **криптографически стойкие хэш-функции**, часто с добавлением "соли" (salt)).
- **Индексация данных (Хэш-таблицы/Maps):** Хэш-функции используются для быстрого поиска данных, преобразуя ключ в индекс в массиве (например, встроенный тип `map` в Golang использует хэширование).
- **Цифровые подписи:** Хэш сообщения подписывается для обеспечения его аутентичности и целостности.

### Виды Хэширования

| **Вид Хэширования**      | **Основное Назначение**                     | **Характеристики**                                                        | **Примеры**              |
| ------------------------ | ------------------------------------------- | ------------------------------------------------------------------------- | ------------------------ |
| **Криптографическое**    | Безопасность (пароли, подписи, целостность) | Необратимость, высокая коллизионная стойкость.                            | SHA-256, Argon2, bcrypt. |
| **Не-криптографическое** | Индексация данных, быстрое сравнение        | Быстрота, низкая вероятность коллизий для хэш-таблиц.                     | CRC32, FNV-1a.           |
| **Функции для паролей**  | Хранение паролей                            | Медленное вычисление (для противодействия подбору), использование "соли". | Argon2, bcrypt, scrypt.  |

### Требования к Хэш-функциям

Требования зависят от целей использования:
1. **Для Хэш-таблиц (`map`):**
    - **Скорость:** Быстрое вычисление хэша.
    - **Равномерное распределение:** Хэш-значения должны быть распределены равномерно, чтобы минимизировать коллизии в таблице.
2. **Для Криптографии (например, SHA-256):**
    - **Стойкость к первому прообразу (Preimage Resistance):** Трудно найти исходное сообщение по его хэшу.
    - **Стойкость ко второму прообразу (Second Preimage Resistance):** Трудно найти другое сообщение, которое имеет тот же хэш, что и заданное.
    - **Коллизионная стойкость (Collision Resistance):** Трудно найти любую пару разных сообщений, которые имеют одинаковый хэш.
3. **Для Хэширования Паролей (например, Argon2):**
    - **Вычислительная сложность (Cost-Factor):** Должна быть возможность настроить функцию так, чтобы ее вычисление занимало ощутимое время (сотни миллисекунд), что замедляет атаки методом перебора (brute-force).


### Популярные Библиотеки для Хэширования в Golang

В Go большинство необходимых функций для криптографического хэширования встроено в стандартную библиотеку, что является лучшей практикой.
1. **`crypto/sha256` и `crypto/sha512` (Стандартная библиотека):** Используются для обеспечения целостности данных, цифровых подписей.
2. **`golang.org/x/crypto/bcrypt` (Внешний пакет Go):** Самый популярный и рекомендуемый способ для хэширования паролей благодаря встроенной "соли" и регулируемой вычислительной сложности.
3. **`golang.org/x/crypto/argon2` (Внешний пакет Go):** Считается самым современным и стойким алгоритмом для хэширования паролей.


### Рабочие Примеры на Golang
#### Использование SHA-256 для проверки целостности данных
```go
package main

import (
	"crypto/sha256"
	"encoding/hex"
	"fmt"
)

func main() {
	data := "Привет, мир! Это данные для хэширования."

	// 1. Создаем новый объект хэш-функции SHA-256
	h := sha256.New() 

	// 2. Записываем данные в хэш-функцию (она обрабатывает байты)
	h.Write([]byte(data)) 

	// 3. Получаем итоговый хэш-дайджест (в виде слайса байтов)
	hashBytes := h.Sum(nil) 

	// 4. Преобразуем байты хэша в читаемую шестнадцатеричную строку
	hashString := hex.EncodeToString(hashBytes)

	fmt.Println("Исходные данные:", data)
	fmt.Println("Хэш SHA-256:", hashString) 
    // Хэш всегда будет 64 символа (256 бит)

	// Пример: быстрое хэширование строки в одну строку
	hQuick := sha256.Sum256([]byte(data))
	fmt.Println("Хэш SHA-256 (быстрый способ):", hex.EncodeToString(hQuick[:]))
}
```



#### Использование bcrypt для хэширования пароля (Рекомендуется для паролей)
```go
package main

import (
	"fmt"
	"log"
	"golang.org/x/crypto/bcrypt"
)

func main() {
	password := "securePassword123" 

	// --- 1. Хэширование пароля ---

	// bcrypt.DefaultCost - это стандартная вычислительная сложность (рекомендуется)
	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
	if err != nil {
		log.Fatal(err)
	}

	// Хэш bcrypt включает в себя информацию об алгоритме, "соли" и сложности
	fmt.Println("Исходный пароль:", password)
	fmt.Println("Хэшированный пароль (bcrypt):", string(hashedPassword))
	
	// --- 2. Проверка пароля ---
	
	inputPassword := "securePassword123" // Пароль, введенный пользователем при входе
	wrongPassword := "wrongPassword456"

	// Сравниваем введенный пароль с сохраненным хэшем
	// bcrypt.CompareHashAndPassword возвращает nil, если пароли совпадают
	err = bcrypt.CompareHashAndPassword(hashedPassword, []byte(inputPassword))
	if err == nil {
		fmt.Println("\nПроверка пароля:", inputPassword, "-> Пароль совпал!")
	} else {
		fmt.Println("\nПроверка пароля:", inputPassword, "-> Пароль не совпал. Ошибка:", err)
	}
	
	err = bcrypt.CompareHashAndPassword(hashedPassword, []byte(wrongPassword))
	if err == nil {
		fmt.Println("Проверка пароля:", wrongPassword, "-> Пароль совпал!")
	} else {
		// Ожидаемый результат: ErrMismatchedHashAndPassword
		fmt.Println("Проверка пароля:", wrongPassword, "-> Пароль не совпал. Ошибка:", err)
	}
}
```


### Получение 32-битного и 64-битного хэша из строки с помощью murmur3

```go
package main

import (
	"fmt"
	"io"
	"strconv"

	// Импортируем библиотеку MurmurHash3
	"github.com/spaolacci/murmur3"
)

func main() {
	data := "Быстрый хэш для кэша или map"
	
	// --- 1. Вычисление 32-битного хэша (uint32) ---
	
	// Используем murmur3.New32() для 32-битного хэша.
	// При желании можно передать seed (начальное значение), 
	// но для простоты мы используем значение по умолчанию.
	hasher32 := murmur3.New32() 

	// io.WriteString позволяет удобно записать строку в хэшер
	_, err := io.WriteString(hasher32, data)
	if err != nil {
		fmt.Println("Ошибка при записи данных:", err)
		return
	}
	
	// Sum32() возвращает 32-битное хэш-значение
	hash32 := hasher32.Sum32()
	
	fmt.Println("--- MurmurHash3 (32-бит) ---")
	fmt.Printf("Исходные данные: \"%s\"\n", data)
	fmt.Printf("Хэш-значение (uint32): %d\n", hash32)
	fmt.Printf("Хэш-значение (шестн.): %x\n", hash32)
	fmt.Println("Длина хэша: 8 символов / 4 байта\n")


	// --- 2. Вычисление 64-битного хэша (uint64) ---
	
	// Используем murmur3.New64() для 64-битного хэша.
	hasher64 := murmur3.New64()

	// Записываем те же данные
	_, err = io.WriteString(hasher64, data)
	if err != nil {
		fmt.Println("Ошибка при записи данных:", err)
		return
	}
	
	// Sum64() возвращает 64-битное хэш-значение
	hash64 := hasher64.Sum64()

	fmt.Println("--- MurmurHash3 (64-бит) ---")
	fmt.Printf("Хэш-значение (uint64): %d\n", hash64)
	fmt.Printf("Хэш-значение (шестн.): %s\n", strconv.FormatUint(hash64, 16))
	fmt.Printf("Длина хэша: 16 символов / 8 байт\n")
}
```

##### Вывод
```bash
--- MurmurHash3 (32-бит) ---
Исходные данные: "Быстрый хэш для кэша или map"
Хэш-значение (uint32): 2035252621
Хэш-значение (шестн.): 792b3a4d
Длина хэша: 8 символов / 4 байта

--- MurmurHash3 (64-бит) ---
Хэш-значение (uint64): 13446077227499648937
Хэш-значение (шестн.): bb9ab0397576d1e9
Длина хэша: 16 символов / 8 байт
```

##### Сводка по использованию MurmurHash3

1. **Создание хэшера:** Используйте `murmur3.New32()` или `murmur3.New64()` для создания объекта хэш-функции.
2. **Запись данных:** Используйте метод `Write` (или удобный `io.WriteString`) для передачи данных в хэш-функцию в виде слайса байтов (`[]byte`).
3. **Получение результата:** Используйте методы `Sum32()` или `Sum64()` для получения окончательного хэш-значения в виде целого числа (`uint32` или `uint64`).