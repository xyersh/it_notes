
### УРОВНИ ИЗОЛИРОВАННОСТИ по стандарту SQL

Уровни изолированности — это область видимости параллельно исполняемых транзакций. Рассмотренные аномалии чтения и записи можно допустить или запретить при определении разных уровней изоляции. Всего их 4: Read Uncommitted, Read Committed, Repeatable Read, Serializable. Каждый следующий уровень является надстройкой над предыдущим, расширяя его функционал. 
В контексте распределенных систем и баз данных уровни изоляции — это компромисс между **производительностью** (скоростью работы) и **консистентностью** (точностью данных). Они определяют, насколько изменения, сделанные одной транзакцией, видимы для других параллельных транзакций.
#### **Read Uncommited**
Это самый  низкий уровень изолированности, он  подразумевает полное отсутствие изоляции: видим незафиксированные изменения других транзакций
- **Проблема:** Полное отсутствие защиты.
- **Пример:** Счетчик просмотров статьи в блоге или лайков. Если данные чуть-чуть разойдутся на долю секунды — никто не умрет. Зато это очень быстро.


#### **Read Commited**
Получаем возможность видеть только зафиксированные изменения, но вспоминаем про аномалию Nonrepeatable read — невоспроизводимость одинаковых SELECT запросов в рамках одной транзакции
- **Решает:** Грязное чтение.
- **Оставляет:** Неповторяющееся чтение.
- **Пример:** Выгрузка отчета по продажам. Пока вы листаете страницы отчета, кто-то может изменить цену товара на первой странице, и если вы вернетесь назад — цена будет уже другой.


#### **Repeatable Read**
Гарантирует, что если вы прочитали строку, она не изменится до конца транзакции. Это возможность появляется из-за строгих ограничений воспроизводимости SELECT запросов: на результат SELECT могут повлиять только незафиксированные изменения текущей транзакции. При этом сохраняется возможность появления аномалии Phantom Read
- **Решает:** Неповторяющееся чтение.
- **Оставляет:** Фантомное чтение (в классическом SQL).
- **Пример:** Редактирование профиля пользователя. Вы открыли данные, начали их менять, и база гарантирует, что пока вы не закончите, никто другой не подменит эти же поля «под капотом».



#### **Serializable**
Этот уровень эмулирует последовательное выполнение транзакций, которые на самом деле выполняются параллельно. В отличие от уровня Repeatable Read, Serializable проверяет отсутствие условий несовместимости выполнения параллельных транзакций
- **Решает:** Все вышеперечисленные проблемы.
- **Цена:** Огромное падение производительности из-за блокировок или частых откатов транзакций.4
- **Пример:** Перевод денег между счетами. Если А переводит Б 100$, а в это время начисляется процент на остаток, система должна гарантировать, что баланс сойдется до цента, без каких-либо аномалий.


#### Особенности в Postgres
В отличие от стандарта SQL, PostgreSQL предлагает более строгие гарантии при менее строгих уровнях изолированности. Фактически, уровень изолированности Read Uncommitted отсутствует — по умолчанию в PostgreSQL сразу Read Committed.
Например, Dirty Read невозможен даже при самом слабом уровне, а Phantom Read невозможно при уровне Repeatable Read, хотя стандарт SQL это допускает. Это достигается благодаря использованию механизма MVCC. Уровень изолированности Serializable достигается не через глобальные блокировки, а с помощью алгоритмов отслеживания конфликтов Serializable Snapshot Isolation, тем самым сохраняя высокую производительность при обеспечении сильнейших гарантий.


![[Pasted image 20260104214412.png]]



### Аномалии чтения в БД 

Стандарт SQL обращает внимание на возможные аномалии чтения при выполнении параллельных транзакций. Всего их 4: 
- **dirty read**, 
- nonrepeatable read, 
- phantom read, 
- serialization anomaly.

**Транзакция** — последовательность атомарно выполняющихся операций.
`t1` и `t2` — параллельно исполняемые транзакции

#### Dirty Read ("грязное" чтение) 



 Это возможность t1 видеть незафиксированные изменения t2
```
t1, t2 begin 

t1 update row 17
t2 read row 17 // read uncommited data

t1 rollback
t2 commit
```

t2 считала незафиксированные изменения t1, после чего t1 откатила свои изменения, а t2 зафиксировала
Откат изменений транзакции будет рассмотрен в следующих постах

#### Nonrepeatable Read ("неповторяемое" чтение) 
Это изменение прочитанных строк
```
t1, t2 begin

t2 read single row 17 (1)
t1 update row 17

t1 commit

t2 read single row 17 (2) // read updated row 17 after t1 commit

t2 commit
```

	
t2 считала данные строки 17 первый раз (1), после чего t1 обновила полученную строку. При следующем считывании данных в t2 тем же запросом (2) получим результат, отличный от результата первого запроса.

#### Phantom Read  ("фантомные" чтения) 
Это появление новых строк или исчезновение старых
```
t1, t2 begin

t2 read many rows 17, 18, 19 (1) // read 3 rows
t1 delete row 17

t1 commit

t2 read many rows 18, 19 (2) // read 2 rows (without row 17) after t1 commit

t2 commit
```

t2 считала данные строк 17, 18, 19 первый раз (1), после чего t1 удалила строку 17, входящую в диапазон запроса t2. При следующем считывании данных в t2 тем же запросом (2) получим результат, отличный от результата первого запроса

#### Serialization Anomaly (аномалия сериализации) 
Это логическое противоречие
Каждая транзакция читает данные, принимает решение на их основе и меняет данные. Параллельное выполнение приводит к логическому противоречию, которого не было бы при последовательном выполнении.

 Уровни изоляции транзакций: Read Uncommitted, Read Committed, Repeatable Read, Serializable как раз и нужны для того, чтобы контролировать, какие из этих аномалий допустимы, а какие — нет. 


### Аномалии записи в БД 
Полезно знать и про возможные аномалии записи, они имеют схожую семантику с аномалиями чтения: 
- lost updates, 
- dirty write, 
- write skew

t1 и t2 — параллельно исполняемые транзакции

#### Lost Updates (потерянные обновления) 
Это возможность t2 перезаписать t1
```
t1, t2 begin

t1 update row 17
t1 commit

t2 update row 17
t2 commit // t2 over t1
```

Если обеим транзакциям разрешено совершить фиксацию, то последняя транзакция (t2) перекроет изменения предыдущей (t1). Это возможно потому что t1 и t2 не знают о существовании друг друга

#### Dirty Write ("грязная" запись) 
Это изменение незафиксированных данных
```
t1, t2 begin

t1 read row 17
t1 update row 17

t2 read row 17
t2 update row 17

t2 commit // based on uncommited t1
t1 rollback
```

t2 читает незафиксированные изменения t1 — "грязное" чтение. На основе этих данных t2 выполняет запись - "грязная" запись. Изменения t2 будет на основе t1, которая откатилась

#### Write Skew (искажение записи) 

Существует 2 банковских счета: C1 и C2, принадлежащих одному пользователю. На балансе C1 500 условных единиц, а на балансе C2 - 1000

t1 и t2 хотят списать 1000 условных единиц с баланса пользователя, и проверяют суммарный баланс: 1000 + 500 = 1500
t1 списывает 1000 с C1: 500 - 1000 = -500
t2 списывает 1000 с C2: 1000 - 1000 = 0
По завершению транзакций фиксируем отрицательный баланс на счете C1‼️ Каждая отдельно взятая транзакция соблюдала условие недопущения отрицательного баланса, но их комбинация смогла это допустить, так как синхронизация между t1 и t2 отсутствовала

