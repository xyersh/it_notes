
В контексте архитектуры программного обеспечения (особенно в рамках Domain-Driven Design — DDD) термины «анемичная» и «богатая» модели описывают два принципиально разных подхода к распределению бизнес-логики.

Основное различие заключается в том, **где живет логика**: внутри объектов данных или в отдельных сервисах.

## 1. Анемичная модель (Anemic Domain Model)

В этой модели объекты предметной области (сущности) представляют собой простые структуры данных — «мешки со свойствами» (POJO/POCO).
- **Как выглядит:** Классы содержат только данные (поля) и методы доступа к ним (геттеры и сеттеры).
- **Где логика:** Все бизнес-правила, расчеты и валидация вынесены во внешние классы, обычно называемые **Сервисами** (Services) или **Менеджерами**.
- **Мнение экспертов:** Мартин Фаулер считает этот подход «антипаттерном», так как он противоречит самой сути объектно-ориентированного программирования (ООП) — объединению данных и поведения.
    

 > **Пример:** Чтобы изменить статус заказа в анемичной модели, вы  вызываете `OrderService.changeStatus(order, NEW_STATUS)`. Сам объект `Order` не знает, можно ли сейчас менять статус и какие правила при этом должны соблюдаться.

---

## 2. Богатая модель (Rich Domain Model)

Это классический ООП-подход, где сущности не только хранят данные, но и управляют своим поведением.
- **Как выглядит:** Объекты имеют закрытые (private) поля и публичные методы, которые выражают бизнес-действия. Сеттеры часто скрыты, чтобы нельзя было привести объект в некорректное состояние.
- **Где логика:** Бизнес-правила, которые касаются конкретного объекта, находятся внутри этого объекта.
- **Преимущества:** Высокая инкапсуляция. Объект сам гарантирует свою целостность (инварианты).
    

> **Пример:** У объекта `Order` есть метод `order.cancel()`. Внутри этого метода сам объект проверяет: «А не был ли я уже доставлен?». Если все хорошо, он меняет свой статус. Внешний код просто отдает команду, не заботясь о деталях реализации.