**CQRS (Command Query Responsibility Segregation)** — это архитектурный паттерн, суть которого заключается в разделении операций чтения (Query) и операций записи (Command).

В традиционных архитектурах мы обычно используем одну и ту же модель данных для того, чтобы обновлять базу и чтобы выводить данные на экран. CQRS утверждает, что это должны быть **две разные модели**.


## 1. Какие проблемы решает CQRS?

В сложных системах стандартный подход (CRUD) часто сталкивается с трудностями:
- **Конфликты представления данных:** Для записи нам нужна нормализованная база (чтобы избежать дублирования), а для чтения — сложные выборки с множеством `JOIN`, что замедляет систему.
- **Производительность:** Нагрузка на чтение обычно в десятки раз выше, чем на запись. Если модель одна, вы не можете масштабировать их по отдельности.
- **Безопасность и валидация:** Логика проверки прав на изменение данных смешивается с простой логикой отображения.
- **Сложность бизнес-логики:** Когда одна и та же сущность (например, `User`) должна содержать методы и для сложных расчетов, и для вывода в профиль, код становится «спагетти».
    

## 2. Как это работает?

Паттерн разделяет поток данных на два независимых плеча:
### Commands (Команды)
- **Цель:** Изменить состояние системы.
- **Особенности:** Не возвращают данные (обычно только статус успеха или ID созданного объекта).
- **Пример:** `ChangeUserAddress`, `PlaceOrder`.
    

### Queries (Запросы)
- **Цель:** Получить данные.
- **Особенности:** Не изменяют состояние (Side-effect free). Возвращают DTO (Data Transfer Object), максимально удобный для фронтенда.
- **Пример:** `GetOrderById`, `GetCustomerList`.


## 3. Уровни реализации

CQRS можно реализовать на разных уровнях сложности:

### Вариант А: Разделение в коде (Single DB)

Вы используете одну базу данных, но создаете разные объекты в коде.
- **Commands:** Используют тяжелую ORM (например, Entity Framework или Hibernate) для сохранения бизнес-правил.
- **Queries:** Используют быстрый "голый" SQL или легкие мапперы (Dapper), чтобы быстро достать данные.
    

### Вариант Б: Разделение баз данных

Это «настоящий» CQRS для высоконагруженных систем.
- **Write DB:** Оптимизирована для записи (нормализованная, часто реляционная).
- **Read DB:** Оптимизирована для чтения (денормализованная, часто NoSQL, например, MongoDB или ElasticSearch).
    
> **Синхронизация:** Когда данные меняются в Write DB, через шину событий (RabbitMQ, Kafka) отправляется уведомление, и Read DB обновляется. Это создает **Eventual Consistency** (согласованность в конечном счете) — данные в поиске могут обновиться с задержкой в доли секунды.


## Преимущества и риски

| **Преимущества**                                                                       | **Риски (Минусы)**                                                                                            |
| -------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------- |
| **Независимое масштабирование:** Чтение можно вынести на 10 серверов, а запись — на 1. | **Сложность:** Больше кода, больше сущностей.                                                                 |
| **Оптимизированные схемы:** Поиск работает мгновенно по готовым таблицам.              | **Проблема согласованности:** Пользователь может не увидеть изменения сразу после нажатия кнопки «Сохранить». |
| **Упрощение модели:** Код записи не засорен логикой отображения.                       | **Инфраструктура:** Нужно настраивать обмен сообщениями между базами.                                         |


## ПРИМЕР РЕАЛИЗАЦИИ CQRS В GOLANG
Рассмотрим пример системы управления пользователями.

### 1. Модель данных и разделение
В CQRS мы разделяем «доменную» модель (для логики) и «проекцию» (для чтения).
```go
// Domain Model (для записи)
type User struct {
    ID       string
    Email    string
    Password string // Хранится в БД для записи
}

// Read Model / DTO (для чтения)
type UserView struct {
    ID    string `json:"id"`
    Email string `json:"email"`
    // Пароля здесь нет — это безопасно и эффективно
}
```

### 2. Команды (Write Side)

Команды описывают **намерение** изменить состояние. Для каждой команды создается свой обработчик (Handler).
```go
// Команда на создание
type CreateUserCommand struct {
    Email    string
    Password string
}

// Обработчик команды
type UserCommandHandler struct {
    repo UserRepository // Интерфейс к БД (Write)
}

func (h *UserCommandHandler) Handle(cmd CreateUserCommand) error {
    // Здесь бизнес-логика: валидация, хеширование пароля
    user := &User{Email: cmd.Email, Password: hash(cmd.Password)}
    return h.repo.Save(user)
}
```

### 3. Запросы (Read Side)

Запросы возвращают данные максимально быстро, часто в обход сложной логики.
```go
// Запрос на получение
type GetUserQuery struct {
    ID string
}

// Обработчик запроса
type UserQueryHandler struct {
    db ReadDatabase // Может быть другой БД или просто Read-only соединение
}

func (h *UserQueryHandler) Handle(query GetUserQuery) (*UserView, error) {
    // Мы достаем сразу готовую структуру для API
    return h.db.FindUserView(query.ID)
}
```


### 4. Собираем всё вместе в API

В Go удобно использовать структуру `Application`, которая объединяет все команды и запросы.
```go
type Application struct {
    Commands Commands
    Queries  Queries
}

type Commands struct {
    CreateUser UserCommandHandler
}

type Queries struct {
    GetUser UserQueryHandler
}

// Пример использования в HTTP обработчике
func (s *Server) CreateUserHandler(w http.ResponseWriter, r *http.Request) {
    cmd := CreateUserCommand{Email: "test@example.com", Password: "123"}
    
    // Выполняем командуw
    err := s.app.Commands.CreateUser.Handle(cmd)
    
    if err != nil {
        http.Error(w, "Error", 500)
        return
    }
    w.WriteHeader(http.StatusCreated)
}
```