## Готовая реализация ретрая
https://github.com/avast/retry-go

## Принцип действия
Когда операция (например, HTTP-запрос или запрос к БД) завершается **неудачей**, вместо немедленного провала система **автоматически повторяет её через некоторое время** — обычно ограниченное количество раз.

## Основные параметры:

1. **Максимальное число попыток** (например, 3)
2. **Стратегия задержки между попытками**:
    - **Фиксированная задержка**: всегда ждать 1 секунду
    - **Экспоненциальная отсрочка (Exponential Backoff)**: 100 мс → 200 мс → 400 мс → ...
    - **Случайная составляющая (Jitter)**: чтобы избежать «гребёнки» одновременных повторов от множества клиентов

> Пример:  
> Попытка 1 → ошибка → ждём 100 мс  
> Попытка 2 → ошибка → ждём 200 мс  
> Попытка 3 → успех → возвращаем результат


## Мотивация использования паттерна
- **Временные сбои (Transient Failures)**  
    Многие ошибки носят временный характер:
    - Кратковременная сетевая проблема
    - Перегрузка удалённого сервиса (503 Service Unavailable)
    - Таймаут из-за пиковой нагрузки
    - Временная недоступность БД
    
    Такие сбои часто **исчезают сами собой** через доли секунды — Retry даёт системе шанс восстановиться.

- **Повышение устойчивости без изменения логики вызывающего кода**  
    Вызывающий код может работать так, будто сбой — редкость, а Retry обрабатывает «шум» прозрачно.

- **Снижение нагрузки на поддержку и мониторинг**  
    Меньше «ложных» алертов из-за временных сетевых глюков.



## Важные моменты, которые нужно учитывать

- **Идемпотентность:** Паттерн применим **ТОЛЬКО** к операциям, многократное выполнение которых приводит к тому же результату, что и однократное (например, запрос на получение данных). Повторение неидемпотентных операций (как "списать $10 со счета") может привести к нежелательным последствиям.
- **Количество попыток:** Необходимо ограничивать максимальное число повторов, чтобы не попасть в бесконечный цикл, если ошибка является постоянной, а не временной.
- **Логирование:** Важно логировать неудачные попытки и окончательные сбои, чтобы иметь возможность анализировать проблемы в системе.
- **Комбинация с другими паттернами:** Паттерн Retry часто используется вместе с паттерном **Circuit Breaker ("Предохранитель")**. Если после нескольких попыток операция все равно завершается неудачей, Circuit Breaker "размыкает цепь" и на некоторое время полностью прекращает попытки вызова сбойного сервиса, чтобы не тратить ресурсы и дать сервису время на восстановление.
-  При **перманентных ошибках**, например, `401 Unauthorized` или `404 Not Found` — повтор не поможет.
- Агрессивный Retry без экспоненциальной задержки может **усугубить перегрузку** (эффект «лавины»).



## ПРИМЕР РЕАЛИЗАЦИИ ПАТТЕРНА
```go

type RetryConfig struct {  
    MaxAttempts  int  
    InitialDelay time.Duration  
    MaxDelay     time.Duration  
}  
  
func Retry[T any](  
    ctx context.Context,  
    config RetryConfig,  
    operation func() (T, error),  
) (T, error) {  
    var result T  
    var err error  
    currentDelay := config.InitialDelay  
  
    for attempt := 1; attempt <= config.MaxAttempts; attempt++ {  
       if ctx.Err() != nil {  
          return result, ctx.Err()  
       }  
  
       result, err = operation()  
       if err == nil {  
          return result, nil  
       }  
  
       if attempt == config.MaxAttempts {  
          return result, err  
       }  
  
       jitter := time.Duration(rand.Float64() * float64(currentDelay))  
       currentDelay += jitter  
       if currentDelay > config.MaxDelay {  
          currentDelay = config.MaxDelay  
       }  
  
       select {  
       case <-ctx.Done():  
          return result, ctx.Err()  
       case <-time.After(currentDelay):  
          currentDelay *= 2  
       }  
    }  
  
    return result, err  
}
```