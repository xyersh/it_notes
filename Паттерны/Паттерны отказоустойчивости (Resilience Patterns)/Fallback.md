Fallback позволяет системе оставаться частично функциональной даже при сбое внешней зависимости.

## Принцип действия

Когда вызов к внешнему сервису (БД, API, микросервису и т.д.) **не удаётся** — вместо того чтобы возвращать ошибку или падать, система **активирует альтернативный сценарий**:

- Возвращает **кэшированные данные**
- Использует **упрощённую логику**
- Отдаёт **заглушку / дефолтное значение**
- Переключается на **резервный источник данных**
- Логирует ошибку и продолжает работу


## Типичные стратегии Fallback

- **Возврат кэшированного значения**
```go
if err := callUserService(); err != nil {
    return getFromCache("user_profile")
}
```

- **Дефолтное/статическое значение**
```go
// Если не удалось получить курс валюты — использовать вчерашний
rate, err := fetchExchangeRate()
if err != nil {
    rate = lastKnownRate
}
```

- **Упрощённая логика**  
    Например: вместо персонализированной рекомендации — показать «топ-10 популярных».
- **Резервный сервис**  
    Вызвать `PrimaryRecommendationService` → если ошибка → вызвать `BackupRecommendationService`.
- **Заглушка (stub)**  
    Вернуть пустой список, но не сломать UI.


## Важные ограничения использования паттерна
- **Не подходит для критически важных операций**  
    Например: нельзя «подставить» фейковый баланс при списании денег.
- **Требует чёткой семантики**  
    Fallback должен быть **безопасным** и **предсказуемым**. Лучше вернуть «я не знаю» (`nil`, `empty list`), чем неверные данные.
- **Часто требует идемпотентности и согласованности**  
    Особенно если используется кэш или резервный источник.



## Пример применения паттерна
```go
package main

import (
    "context"
    "fmt"
    "time"
)

// Имитация основного сервиса (иногда падает)
func primaryService() (string, error) {
    if time.Now().Unix()%3 == 0 {
        return "", fmt.Errorf("primary service недоступен")
    }
    return "Данные из основного сервиса", nil
}

// Резервный источник
func fallbackService() string {
    return "Данные из резервного источника (кэш / упрощённая логика)"
}

func getDataWithFallback() string {
    if data, err := primaryService(); err == nil {
        return data
    }
    // Fallback срабатывает при ошибке
    return fallbackService()
}

func main() {
    for i := 0; i < 5; i++ {
        result := getDataWithFallback()
        fmt.Printf("[%d] %s\n", i+1, result)
        time.Sleep(1 * time.Second)
    }
}
```