

## Принцип действия

Паттерн **Timeout** устанавливает **максимально допустимое время ожидания** ответа от внешней зависимости (сервиса, базы данных, API и т.д.). Если за это время ответ не получен — операция **принудительно прерывается**, и система переходит к обработке ошибки или альтернативному поведению.

> Вместо бесконечного ожидания — чёткий временной лимит.

## Мотивация использования
1. **Бесконечные ожидания (hangs)**  
    Без таймаута вызывающий код может «зависнуть» навсегда, если удалённый сервис не отвечает (например, из-за deadlock, перегрузки или сетевого разрыва).
2. **Исчерпание ресурсов**  
    Каждый зависший запрос потребляет:
    - Goroutine / поток
    - Память
    - Сокеты
    - Пул соединений  
        → При большом числе таких запросов — **полный отказ системы** (out of memory, thread exhaustion).
3. **Плохой пользовательский опыт**  
    Пользователь ждёт ответа 30 секунд — вместо быстрого сообщения «сервис временно недоступен».
4. **Каскадные сбои**  
    Один медленный сервис может «потянуть за собой» всю цепочку вызовов (например: UI → Service A → Service B → завис).  
    Timeout **локализует проблему**.

## Как реализуется:

- На уровне **сетевых вызовов**: HTTP-клиент, gRPC, TCP-соединение.
- Через **контекст с таймаутом** (в Go — `context.WithTimeout`).
- Иногда — на уровне **бизнес-логики** (например, «ждать результат не дольше 2 секунд»).


## Важные моменты использования паттерна
-  **Выбор значения таймаута**
	- Слишком **маленький** → ложные срабатывания при нормальной нагрузке.
	- Слишком **большой** → не спасает от зависаний.
	- Рекомендация: основываться на **P95/P99 latency** целевого сервиса + запас (например, `P99 * 2`).
-  **Комбинирование с другими паттернами**
	- **Retry + Timeout**: каждая попытка имеет свой таймаут.
	- **Circuit Breaker + Timeout**: если много таймаутов — Circuit Breaker «размыкается».
	- **Fallback**: при таймауте вернуть кэшированный результат или заглушку.