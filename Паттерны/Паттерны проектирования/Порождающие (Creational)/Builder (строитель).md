Это порождающий паттерн проектирования, который позволяет пошагово конструировать сложные объекты. Он особенно полезен, когда у объекта много опциональных или обязательных параметров, и создание через конструктор становится неудобным или непонятным.	

## **Мотивация использования**

1. **Избежать "телескопических" конструкторов**  
    Когда у объекта много полей, особенно с разными комбинациями обязательных и необязательных параметров, приходится создавать множество конструкторов — это трудно читать и поддерживать.
2. **Улучшить читаемость и гибкость кода**  
    Builder позволяет явно указывать, какие параметры задаются, делая код самодокументируемым.
3. **Обеспечить неизменяемость финального объекта**  
    Часто объект, созданный через Builder, является immutable (неизменяемым), что полезно в многопоточных средах.
4. **Разделение логики построения и представления**  
    Можно использовать один и тот же процесс построения для создания разных представлений объекта.


## **Когда применять**

- Объект имеет **много полей**, часть из которых **опциональна**.
- Нужно гарантировать **валидность объекта** на этапе построения.
- Требуется **гибкость** в порядке и способе задания параметров.
- Объект должен быть **immutable** после создания.


## Пример

Допустим, у нас есть структура `User`, у которой есть обязательные поля (`Email`, `Name`) и опциональные (`Age`, `Phone`).
```go
package main

import "fmt"

// User — неизменяемый объект
type User struct {
	Email string
	Name  string
	Age   int
	Phone string
}

// UserBuilder помогает строить User
type UserBuilder struct {
	email string
	name  string
	age   int
	phone string
}

// NewUserBuilder создаёт новый билдер с обязательными полями
func NewUserBuilder(email, name string) *UserBuilder {
	return &UserBuilder{
		email: email,
		name:  name,
	}
}

// SetAge добавляет возраст (опционально)
func (b *UserBuilder) SetAge(age int) *UserBuilder {
	b.age = age
	return b // возвращаем тот же билдер для цепочки вызовов
}

// SetPhone добавляет телефон (опционально)
func (b *UserBuilder) SetPhone(phone string) *UserBuilder {
	b.phone = phone
	return b
}

// Build создаёт финальный объект User
func (b *UserBuilder) Build() (*User, error) {
	if b.email == "" || b.name == "" {
		return nil, fmt.Errorf("email and name are required")
	}
	return &User{
		Email: b.email,
		Name:  b.name,
		Age:   b.age,
		Phone: b.phone,
	}, nil
}

// Пример использования
func main() {
	user, err := NewUserBuilder("alice@example.com", "Alice").
		SetAge(30).
		SetPhone("+123456789").
		Build()
	if err != nil {
		panic(err)
	}
	fmt.Printf("%+v\n", user)
}
```
 
 Преимущества в этом примере:
- Чёткое разделение обязательных( **email**, **name**) и опциональных параметров (все прочие атрибуты).
- Цепочка вызовов делает код выразительным.
- Финальный `User` — неизменяемый (нет сеттеров, все поля приватные или инициализируются один раз).
- Валидация выполняется в `Build()`.