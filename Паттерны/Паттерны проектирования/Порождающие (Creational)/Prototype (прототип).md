Используется, если требуется оздание новых объектов путём клонирования существующего объекта-прототипа а не через конструкторы или фабрики.

## **Мотивация использования**
1. **Избежать сложной инициализации**  
    Когда создание объекта требует дорогостоящих операций (например, загрузка данных из БД, сетевых вызовов, сложных вычислений), удобнее скопировать уже инициализированный экземпляр.
2. **Гибкость в создании объектов**  
    Позволяет создавать объекты без привязки к конкретным классам — клиент работает с интерфейсом, а не с реализацией.
3. **Динамическая настройка прототипов**  
    Можно настроить набор "образцовых" объектов один раз, а затем клонировать их по мере необходимости.
4. **Упрощение иерархии классов**  
    Вместо множества подклассов с разными параметрами можно использовать один класс с разными экземплярами-прототипами.

## Суть преализации паттрерна
- Создание оригинального объекта, как правило - ресурсоемкое
- Создание нового объекта через клониирование оригинального. Клонирование модет быть как поверхностным так и глубоким в зависимости от контекста.
- Далее, состояние нового объекта меняется в зависимости от нужд.

## **Когда применять?**

- Когда система должна быть независимой от способа создания и компоновки продуктов.
- Когда классы, которые нужно инстанцировать, задаются динамически (например, через конфигурацию).
- Когда создание объекта требует значительных ресурсов, но последующие копии могут быть сделаны дешевле.
- Когда нужно избежать множества подклассов, предназначенных только для создания объектов с разными состояниями.

## Преимущества подхода

- Быстрое создание объектов без повторной инициализации.
- Гибкость: можно менять прототипы во время выполнения.
- Снижение зависимости от конкретных типов.

##  Недостатки

- Необходимость корректной реализации клонирования (особенно при наличии вложенных ссылок).
- Может усложнить код, если объекты имеют сложную структуру.

## Пример
```go
package main

import (
	"fmt"
)

// Cloneable — интерфейс для клонирования
type Cloneable interface {
	Clone() Cloneable
}

// Document — структура, которую будем клонировать
type Document struct {
	Title   string
	Content string
	Tags    []string
}

// Clone создаёт глубокую копию Document
func (d *Document) Clone() Cloneable {
	// Копируем срез, чтобы избежать shared state
	tagsCopy := make([]string, len(d.Tags))
	copy(tagsCopy, d.Tags)

	return &Document{
		Title:   d.Title,
		Content: d.Content,
		Tags:    tagsCopy,
	}
}

func main() {
	// Создаём прототип
	prototype := &Document{
		Title:   "Шаблон документа",
		Content: "Это базовое содержимое.",
		Tags:    []string{"draft", "template"},
	}

	// Клонируем
	doc1 := prototype.Clone().(*Document)
	doc1.Title = "Отчёт за январь"
	doc1.Tags = append(doc1.Tags, "january")

	doc2 := prototype.Clone().(*Document)
	doc2.Title = "Спецификация API"
	doc2.Tags = append(doc2.Tags, "api", "spec")

	fmt.Printf("Прототип: %+v\n", prototype)
	fmt.Printf("Документ 1: %+v\n", doc1)
	fmt.Printf("Документ 2: %+v\n", doc2)
}
```

> ⚠️  реализовано **глубокое копирование** для среза `Tags`, чтобы изменения в одном экземпляре не влияли на другие.


