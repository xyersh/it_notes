Паттерн гарантирует, что у класса (или структуры в Go) есть **только один экземпляр**, и предоставляет **глобальную точку доступа** к этому экземпляру.


## **Мотивация использования**

Основные причины использовать Singleton:

1. **Контроль над количеством экземпляров**: Некоторые компоненты системы должны существовать в единственном экземпляре — например, менеджер конфигурации, логгер, пул соединений с базой данных.
2. **Глобальный доступ без глобальных переменных**: Позволяет избежать разброса глобального состояния по кодовой базе, инкапсулируя его в одном месте.
3. **Ленивая инициализация**: Экземпляр создаётся только при первом обращении, а не при старте программы.


##  Важные замечания использования Singleton

**Использовать Singleton**, если:
- Точно нужен **один и только один** экземпляр.
- Глобальный доступ оправдан (например, корневой логгер).
- Вы контролируете побочные эффекты и обеспечиваете потокобезопасность.

**Избегать Singleton**, если:
- Можно решить задачу через DI.
- Планируешь писать unit-тесты.
- Возможны разные конфигурации компонента в будущем.

## Примеры

### Реализация с использованием sync.Once
```go 
package main

import (
    "fmt"
    "sync"
)

// singleton — приватная структура
type singleton struct {
    data string
}

// instance — единственный экземпляр
var instance *singleton
var once sync.Once

// GetInstance — потокобезопасный способ получения экземпляра
func GetInstance() *singleton {
    once.Do(func() {
        instance = &singleton{ "I am singleton!"}
    })
    return instance
}

func (s *singleton) GetData() string {
    return s.data
}

func main() {
    s1 := GetInstance()
    s2 := GetInstance()

    fmt.Println(s1.GetData()) // I am singleton!
    fmt.Println(s2.GetData()) // I am singleton!
    fmt.Println(s1 == s2)     // true — один и тот же экземпляр
}
```

 Пояснение:
- `sync.Once` гарантирует, что инициализация произойдёт **ровно один раз**, даже в многопоточной среде.
- Структура `singleton` — приватная (начинается с маленькой буквы), поэтому её нельзя создать извне пакета.
- Все вызовы `GetInstance()` возвращают один и тот же указатель.


### Реализация с использованием init()
```go
package main

import "fmt"

type config struct {
    Port int
}

var globalConfig *config

func init() {
    globalConfig = &config{Port: 8080}
}

func GetConfig() *config {
    return globalConfig
}

func main() {
    fmt.Println(GetConfig().Port) // 8080
}
```