арантирует, что у класса (или структуры в Go) есть **только один экземпляр**, и предоставляет **глобальную точку доступа** к этому экземпляру.

## **Мотивация использования**

Основные причины использовать Singleton:
1. **Контроль над количеством экземпляров**: Некоторые компоненты системы должны существовать в единственном экземпляре — например, менеджер конфигурации, логгер, пул соединений с базой данных.
2. **Глобальный доступ без глобальных переменных**: Позволяет избежать разброса глобального состояния по кодовой базе, инкапсулируя его в одном месте.
3. **Ленивая инициализация**: Экземпляр создаётся только при первом обращении, а не при старте программы.

## Условия использования

**Используй Singleton**, если:
- Точно нужен **один и только один** экземпляр.
- Глобальный доступ оправдан (например, корневой логгер).
- Вы контролируете побочные эффекты и обеспечиваете потокобезопасность.

**Избегай Singleton**, если:
- Можно решить задачу через DI.
- Планируешь писать unit-тесты.
- Возможны разные конфигурации компонента в будущем.

## **Типичные ситуации применения**

- Логирование: один логгер для всей системы.
- Конфигурация приложения: чтение настроек один раз и их использование везде.
- Кэш или пул ресурсов: например, пул подключений к БД.
- Управление состоянием: например, состояние игры или сессии пользователя.

> ⚠️ **Важно**: Singleton часто критикуют за усложнение тестирования и нарушение принципов инверсии зависимостей (SOLID). Используйте его осознанно — иногда лучше передавать зависимости явно через конструктор.


## Пример реализации 
### С применением sync.Once
```go
package main

import (
    "fmt"
    "sync"
)

// singleton — приватная структура
type singleton struct {
    data string
}

// instance — единственный экземпляр
var instance *singleton
var once sync.Once

// GetInstance — потокобезопасный способ получения экземпляра
func GetInstance() *singleton {
    once.Do(func() {
        instance = &singleton{ "I am singleton!"}
    })
    return instance
}

func (s *singleton) GetData() string {
    return s.data
}

func main() {
    s1 := GetInstance()
    s2 := GetInstance()

    fmt.Println(s1.GetData()) // I am singleton!
    fmt.Println(s2.GetData()) // I am singleton!
    fmt.Println(s1 == s2)     // true — один и тот же экземпляр
} 
```

#### Пояснение:
- `sync.Once` гарантирует, что инициализация произойдёт **ровно один раз**, даже в многопоточной среде.
- Структура `singleton` — приватная (начинается с маленькой буквы), поэтому её нельзя создать извне пакета.
- Все вызовы `GetInstance()` возвращают один и тот же указатель.

### С использованием init()
экземпляр  **Одиноччки**  создается  сразу при запуске программы:
```go
package main

import "fmt"

type config struct {
    Port int
}

var globalConfig *config

func init() {
    globalConfig = &config{Port: 8080}
}

func GetConfig() *config {
    return globalConfig
}

func main() {
    fmt.Println(GetConfig().Port) // 8080
}
```
*  **Плюсы:** простота, гарантия инициализации до `main`.
* **Минусы:** нет ленивой загрузки; инициализация происходит даже если не нужна.