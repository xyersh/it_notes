## Пространственная локальность (Spatial Locality)

**Тезис:** Максимально используйте последовательный доступ к данным, поскольку ЦПУ загружает данные в кэш не по одному элементу, а целыми блоками (**кэш-линиями**, обычно 64 байта). Последовательный доступ гарантирует, что уже загруженная кэш-линия содержит следующий необходимый элемент, избегая промаха кэша (cache miss).

**Пример кода (Эффективный vs. Неэффективный доступ к 2D-массиву):**

В Golang (как и в C/C++), двумерные массивы хранятся в памяти по строкам (Row-Major Order).

```go
// Матрица 1000x1000
const N = 1000
var matrix [N][N]int64

// ✅ Эффективно: Последовательный доступ по строкам
func sumRows() int64 {
    var sum int64
    for i := 0; i < N; i++ {
        for j := 0; j < N; j++ {
            sum += matrix[i][j] // Читаем matrix[i][0], matrix[i][1], ...
        }
    }
    return sum
}

// ❌ Неэффективно: Доступ с большим шагом (Strided Access) по столбцам
func sumColumns() int64 {
    var sum int64
    for j := 0; j < N; j++ {
        for i := 0; i < N; i++ {
            sum += matrix[i][j] // Читаем matrix[0][j], matrix[1][j], ...
            // При переходе от [i][j] к [i+1][j] мы "прыгаем" в памяти
            // на N*sizeof(int64) байт, что почти всегда вызывает промах кэша.
        }
    }
    return sum
}
```