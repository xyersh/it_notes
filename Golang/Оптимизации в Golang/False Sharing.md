## Выравнивание и Ложный доступ (False Sharing)

**Тезис:** В многопоточных программах (например, использующих Go routines), переменные, которые часто обновляются разными ядрами ЦПУ, должны быть расположены на **разных кэш-линиях**. Если две независимые переменные находятся в одной кэш-линии, их одновременное изменение разными ядрами вызывает **ложный доступ (False Sharing)** — ядрам приходится постоянно синхронизировать/обновлять одну и ту же кэш-линию, что сильно замедляет работу.

**Решение:** Используйте **заполнение (Padding)**, чтобы разнести переменные. Кэш-линия обычно составляет 64 байта.

**Пример кода (Предотвращение False Sharing):**
```go
// ❌ Проблема False Sharing: Count1 и Count2, вероятно, находятся в одной кэш-линии.
// Если разные горутины обновляют Count1 и Count2 одновременно, происходит False Sharing.
type UnsafeCounters struct {
    Count1 int64 // 8 байт
    Count2 int64 // 8 байт
}

// ✅ Решение с Padding: Добавление неиспользуемых полей для заполнения кэш-линии.
type SafeCounters struct {
    Count1 int64          // 8 байт
    Pad    [7]int64       // 7 * 8 = 56 байт
    Count2 int64          // 8 байт
    // Итог: Count1 (0-7 байт) и Count2 (64-71 байт) гарантированно
    // находятся в разных кэш-линиях (0-63 и 64-127).
}
```