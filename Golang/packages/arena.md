
### Назначение 

Арены позволяют размещать множество мелких объектов в одном большом блоке памяти (span). Это снижает нагрузку на сборщик мусора (GC), так как он работает с одним блоком, а не с каждым объектом по отдельности.
    
### Управление

Жизненный цикл объектов в арене управляется вручную. Освобождение памяти происходит одним вызовом метода `Free()` для всей арены, что делает ее идеальной для временных данных, используемых в рамках одного запроса.

### Производительность

Использование арен может значительно сократить время аллокации и количество системных вызовов, особенно при работе с большим количеством объектов.  Также за  счёт меньшего числа операций GC и ручного управления памятью, использование арен может снизить задержки (latency) и увеличить пропускную способность (throughput) в высоконагруженных приложениях.


### Когда использовать арены

- Для обработки больших объемов временных данных в рамках одного запроса.
- Для создания временных буферов.
- Для аллокации большого количества объектов разного размера, чтобы не использовать `sync.Pool`.
    

### Когда не использовать арены

- Для объектов, которые должны существовать дольше одного запроса.
- Арены не являются потокобезопасными, поэтому их нельзя использовать для одновременной работы в нескольких горутинах без дополнительных механизмов синхронизации.


### Как включить и использовать арены

1. **Включить флаг**: Арены — это экспериментальная функция. Чтобы их использовать, при сборке проекта необходимо добавить флаг `GOEXPERIMENT=arenas`. Например:
```bash
GOEXPERIMENT=arenas go build .
```

2. **Включать необходимый импорт**
 ```go
   import "arena"
   ```

### Основные функции
Основные функции находятся в пакете `arena` и позволяют создавать арены, выделять в них память для структур и слайсов, а также освобождать её.

- `arena.NewArena()`: Создает новую **арену**. Это главная функция, с которой начинается работа.
    
- `arena.New[T](a *Arena)`: Выделяет память в указанной арене `a` для **одиночного объекта типа `T`**. Эта функция возвращает указатель на созданный объект.
    
- `arena.MakeSlice[T](a *Arena, len, cap int)`: Выделяет память в арене `a` для **слайса типа `T`** с указанными длиной (`len`) и ёмкостью (`cap`).
    
- `a.Free()`: **Освобождает всю память**, выделенную в арене `a`. После вызова этой функции все объекты в арене становятся недействительными. Обычно `Free()` вызывается в `defer`.
    
- `arena.Clone[T](a *Arena, val T)`: Создает **копию объекта** `val` из арены в обычной куче Go. Это полезно, если вы хотите, чтобы объект «пережил» освобождение арены.


### Пример
```go
package main

import (
    "arena"
    "fmt"
)

// Пользовательская структура, которую мы будем создавать в арене.
type User struct {
    ID   int
    Name string
}

func main() {
    // Чтобы запустить этот код, используйте команду:
    // GOEXPERIMENT=arenas go run main.go
    // Создаем новую арену.
    // arena.NewArena() - это основная функция для инициализации арены.

    a := arena.NewArena()

    // Гарантируем, что память освободится после завершения функции.
    // a.Free() освобождает всю память, выделенную в арене, одним махом.

    defer a.Free()

    // --- 1. Выделение памяти для одного объекта ---
    // arena.New[T](a) выделяет память для одной структуры в арене.
    user1 := arena.New[User](a)
    user1.ID = 1
    user1.Name = "Alice"
    fmt.Printf("Создан пользователь в арене: %+v\n", *user1)

  

    // --- 2. Выделение памяти для слайса ---
    // arena.MakeSlice[T](a, len, cap) создает слайс в арене.
    // Это полезно для временных буферов.
    numbers := arena.MakeSlice[int](a, 5, 10)

    for i := 0; i < len(numbers); i++ {
        numbers[i] = (i + 1) * 10
    }

    fmt.Printf("Создан слайс в арене: %v\n", numbers)

    // --- 3. Клонирование объекта из арены в обычную кучу ---
    // arena.Clone(a, val) копирует данные из арены в обычную кучу Go.
    // Это нужно, если объект должен "пережить" вызов a.Free().
    user2 := arena.New[User](a)
    user2.ID = 2
    user2.Name = "Bob"
  
    // Клонируем user2. После вызова a.Free() оригинальный user2 будет удален,
    // но его клон в обычной куче останется.
    user2Clone := arena.Clone(user2)
    fmt.Printf("Клон пользователя в обычной куче: %+v\n", user2Clone)

    // Память, выделенная для user1, user2 и слайса numbers,
    // будет автоматически освобождена в конце функции благодаря defer a.Free().

}
```