### проверка на доступность интернета
```go
func isOnline(ctx context.Context) bool {
  const url = "http://google.com/generate_204"

  req, err := http.NewRequestWithContext(ctx, http.MethodGet, url, nil)
  if err != nil {
    return false
  }

  resp, err := http.DefaultClient.Do(req)
  if err != nil {
    return false
  }

  defer resp.Body.Close()
  return resp.StatusCode == http.StatusNoContent
}
```

### Снятие  статистики по памяти
```go

var m runtime.MemStats
...
runtime.ReadMemStats(&m)
...
printMemStats(m)
...

func printMemStats(m runtime.MemStats) {  
    fmt.Printf("Выделено (Alloc): %d байт\n", m.Alloc)  
    fmt.Printf("Всего выделено (TotalAlloc): %d байт\n", m.TotalAlloc)  
    fmt.Printf("Системная память (Sys): %d байт\n", m.Sys)  
    fmt.Printf("Количество объектов heap (HeapObjects): %d\n", m.HeapObjects)  
    fmt.Printf("Количество освобожденных объектов heap (HeapReleased): %d\n", m.HeapReleased)  
    fmt.Printf("Количество сборок мусора (NumGC): %d\n", m.NumGC)  
    fmt.Printf("Пауза GC (LastGC): %s\n", time.Unix(0, int64(m.LastGC)).String())  
    fmt.Printf("Суммарное время GC (PauseTotalNs): %s\n", time.Duration(m.PauseTotalNs).String())  
}
```

### Создание слайса без заполнения нулям
создание таких слайсов обходится гораздо дешевле чем с использованием стандартного make()
```go
package main  
  
import (  
    "fmt"  
    "strings"    "unsafe")  
  
func MakeDirty(size int) []byte {  
    var sb strings.Builder  
    sb.Grow(size)  
  
    pointer := unsafe.StringData(sb.String())  
    return unsafe.Slice(pointer, size)  
}  
  
func main() {  
    slice := MakeDirty(1000_000)  
    fmt.Println(string(slice))  
}
```


### Mutable string
```go
package main  
  
import (  
    "fmt"  
    "unsafe")  
  
func main() {  
  
    hello := "hello world"  
  
    data := []byte(hello)  
    pointer := (*byte)(unsafe.SliceData(data))  
    str := unsafe.String(pointer, len(data))  
  
    fmt.Println(str)  
    data[0] = '#'  
    fmt.Println(str)  
}
```


### []byte -> string без  копирования
```go
func Convert(data []byte) string {
	if len(data) == 0 {
		return ""
	}
	return unsafe.String(unsafe.SliceData(data), len(data))
}
```
Такое преобразование ГОРАЗДО быстрее стандартного `str := string(data)` так как нет копирования.


### string -> []byte без копирования 
```go 
func Convert(str string) []byte {
	if len(str) == 0 {
		return nil
	}
	return unsafe.Slice(unsafe.StringData(str), len(str))
}
```
Такое преобразование ГОРАЗДО быстрее стандартного `data := []byte(str)`, так как нет копирования.


### Шардированная мапа
```go
package main

import (
    "fmt"
    "hash/fnv"
    "runtime"
    "strconv"
    "sync"
)

  

// shard represents a single shard with its own mutex and data map
type shard struct {
    sync.RWMutex
    data map[int]Employee
}

// ShardedMap represents a thread-safe map with sharding for improved concurrent access
type ShardedMap struct {
    shards     []shard
    shardCount int
}

// NewShardedMap creates a new ShardedMap with an appropriate number of shards
// based on the number of CPU cores
func NewShardedMap() *ShardedMap {
    shardCount := getShardCount()
    shards := make([]shard, shardCount)
  
    for i := range shards {
        shards[i] = shard{
            data: make(map[int]Employee),
        }
    }

    return &ShardedMap{
        shards:     shards,
        shardCount: shardCount,
    }
}

// getShardCount determines the appropriate number of shards based on CPU cores
func getShardCount() int {
    numCores := runtime.NumCPU()

    // Determine shard count based on CPU cores
    switch {
    case numCores <= 2:
        return 4
    case numCores <= 4:
        return 16
    default:
        return 32
    }
}

  

// getShard returns the shard responsible for the given key
func (m *ShardedMap) getShard(key int) *shard {
    h := fnv.New32a()
    h.Write([]byte(strconv.Itoa(key)))
    return &m.shards[h.Sum32()%uint32(m.shardCount)]
}

  

// Get retrieves an employee by ID
func (m *ShardedMap) Get(id int) (Employee, error) {
    shard := m.getShard(id)
    shard.RLock()
    defer shard.RUnlock()
  
    employee, exists := shard.data[id]
    if !exists {
        return Employee{}, fmt.Errorf("employee with id %d not found", id)
    }

    return employee, nil
}

  

// Set inserts or updates an employee in the map
func (m *ShardedMap) Set(id int, employee Employee) {
    shard := m.getShard(id)
    shard.Lock()
    defer shard.Unlock()

    shard.data[id] = employee
}

  

// Delete removes an employee from the map

func (m *ShardedMap) Delete(id int) {
    shard := m.getShard(id)
    shard.Lock()
    defer shard.Unlock()

    delete(shard.data, id)
}

  

// GetAll returns all employees in the map

func (m *ShardedMap) GetAll() []Employee {

    var employees []Employee

  

    // Lock all shards for reading to ensure consistency
    for i := range m.shards {
        m.shards[i].RLock()
    }

    // Collect all employees
    for i := range m.shards {
        for _, employee := range m.shards[i].data {
            employees = append(employees, employee)
        }
    }
  
    // Unlock all shards
    for i := range m.shards {
        m.shards[i].RUnlock()
    }

    return employees
}

  

// Len returns the total number of employees in the map
func (m *ShardedMap) Len() int {
    total := 0

    // Lock all shards for reading to ensure consistency
    for i := range m.shards {
        m.shards[i].RLock()
    }

    // Count all employees
    for i := range m.shards {
        total += len(m.shards[i].data)
    }
  
    // Unlock all shards
    for i := range m.shards {
        m.shards[i].RUnlock()
    }

    return total
}
```