
### go run
Компилирует и сразу запускает одну или несколько Go программ.
Команда создает временный исполняемый файл, запускает его, а затем удаляет. Отлично подходит для быстрой проверки небольших программ или скриптов. 
**Ключевое отличие от `go build`**: `go run` — это "компилировать и запустить", в то время как `go build` только "компилирует".
```shell
go run main.go #запуск файла

go run . #запуск проекта
```





### go build
Компилирует пакеты и их зависимости.
- Если вы находитесь в директории `main` пакета (где есть функция `main()`), `go build` создаст исполняемый файл в текущей директории. Имя файла по умолчанию — имя директории (или имя .go файла, если указан).
- Если это не `main` пакет, `go build` скомпилирует пакет, но не создаст исполняемый файл (результат компиляции кэшируется).
-  Основные опции:
		-  `-o /путь/к/выходному/файлу/имя_файла`- компиляция проекта с сохранением статического бинарника по указанному пути
		- `-v:` Включает подробный вывод о процессе компиляции.
		- `-work:` Указывает директорию для временных файлов.
		- `-gcflags:` Передает  компилятору флаги сборки мусора:
			- `-m` - Печатает информацию о вызовах функций. Это может дать нам информацию об аллокациях в хип (провести  escape-анализ). Это полезно при оптимизации.
			- `-l` - Отключает встроенные функции. Это может быть полезно для анализа производительности или для создания более простых исполняемых файлов.
			- `-N` - Отключает оптимизацию. Это может быть полезно для отладки, так как упрощает код.
			- `-S`: Печатает ассемблерный код. Полезно для понимания, как компилятор преобразует ваш код в машинные инструкции.
			- `-dwarf`: Включает поддержку отладки с помощью DWARF. Это позволяет использовать отладчик для пошагового выполнения вашего кода.
	
	```shell
	go build -gcflags='-S -N' mypackage
	```
	
		- `-ldflags:`Передает флаги компоновщику.
- Опции оптимизации:
		- `-O:`Включает оптимизацию. Доступны уровни оптимизации:
			- 0 (без оптимизации), 
			- 1 (базовая оптимизация)  
			- 2 (агрессивная оптимизация).
		- `-s:` Удаляет неиспользуемые символы из итогового файла, уменьшая его размер.
		- `-w:` Удаляет информацию об отладке.
- Опции для создания библиотек:
		- `-buildmode=c-archive:` Создает статическую библиотеку в формате C-архива.
		- `-buildmode=c-shared:` Создает динамическую библиотеку в формате, совместимом с C.
	- `-mod=vendor` - компиляция проекта с использованием зависимостей из директории вендора локально. 
- Опции для кросс-компиляции:
		- `GOOS:` Определяет целевую операционную систему (например, linux, windows, darwin).
		- `GOARCH:` Определяет целевую архитектуру (например, amd64, arm64).
		### примеры:
	```shell
	# Собрать исполняемый файл в директорию bin
	go build -o bin/myprogram
	
	# Собрать с максимальной оптимизацией и без информации об отладке
	go build -o myprogram -O2 -w
	
	# Создать статическую библиотеку
	go build -buildmode=c-archive -o libmylib.a
	
	# Собрать для системы Linux на архитектуре ARM64
	GOOS=linux GOARCH=arm64 go build
	```


### go clean
Команда go clean используется для удаления временных файлов, созданных во время компиляции Go-проекта. Это помогает поддерживать чистоту в проекте и предотвращает накопление ненужных файлов.
Зачем нужна:
 * Освобождение места: Удаляет промежуточные файлы, которые больше не нужны.
 * Устранение ошибок: Иногда временные файлы могут мешать процессу сборки. Их удаление может помочь решить некоторые проблемы.
 * Подготовка к новой сборке: Удаление старых файлов гарантирует, что новая сборка будет выполнена с нуля.
Основные параметры:
 * -i: Удаляет соответствующий установленный архив или исполняемый файл.
 * -r: Применяется рекурсивно ко всем зависимостям указанных пакетов.
 * -cache: Удаляет весь кэш сборки Go.
 * -testcache: Удаляет все результаты тестов из кэша сборки Go.
 * -modcache: Удаляет весь кэш модулей, включая распакованный исходный код версионных зависимостей.
 * -fuzzcache: Удаляет файлы, хранящиеся в кэше сборки Go для фаззи-тестирования.
Когда использовать:
 * Перед коммитом: Чтобы не засорять репозиторий временными файлами.
 * Перед релизом: Чтобы убедиться, что в дистрибутив не попадут лишние файлы.
 * При возникновении ошибок: Иногда удаление временных файлов помогает решить проблемы со сборкой.
 * При переходе на новую версию Go: Чтобы очистить кэш и начать сборку с нуля.
Пример использования:
```shell
go clean -r
```

Эта команда удалит все временные файлы во всех подкаталогах текущего проекта.
Дополнительные сведения:
Для получения более подробной информации о команде go clean и других параметрах, используйте команду go help clean.
Важно: Будьте осторожны при использовании параметра -i, так как он удаляет установленные файлы.
Дополнительные советы:
 * Автоматизация: Добавьте команду go clean в скрипт сборки или используйте инструменты для автоматизации.
 * Игнорирование файлов: Добавьте временные файлы в .gitignore, чтобы они не попадали в систему контроля версий.

### go help <команда>
 вызов помощи по команде

### go install
Компилирует и устанавливает пакеты и зависимости.
Похоже на `go build`, но исполняемые файлы помещаются в директорию `$GOPATH/bin` (или `$GOBIN`, если установлена). Библиотеки устанавливаются в `$GOPATH/pkg`. Это делает команды доступными из любого места, если `$GOPATH/bin` добавлен в `PATH` вашей системы.


### go mod
Управление  зависимостями

#### go mod init  <module_path>
Инициализирует новый модуль в текущей директории. 
Создает файл `go.mod`. `module_path` обычно соответствует URL вашего репозитория
```go
go mod init github.com/myuser/myproject
```

#### go mod tidy
"Приводит в порядок" зависимости.
Удаляет неиспользуемые зависимости из `go.mod` и `go.sum` и добавляет недостающие, которые используются в коде. Это команда, которую вы будете использовать часто.
```go
go mod tidy
```

#### go mod download
Загружает зависимости, перечисленные в `go.mod`, в локальный кэш модулей. Полезна для предварительной загрузки зависимостей, например, в CI/CD системах.

#### go mod edit -require=<путь_к_модулю>@<версия>
Устанавливает конкретную версию зависимости.

#### go mod edit -replace=<путь_к_модулю>=<локальный_путь>
Заменяет зависимость на локальную копию.

#### go mod graph
Отображает граф зависимостей в виде дерева.

#### go mod vendor
Создает директорию `vendor` в вашем проекте и копирует туда все зависимости.
позволяет проекту иметь локальную копию всех зависимостей. Сборка с флагом `-mod=vendor` будет использовать пакеты из этой директории.
```go
go mod vendor 
go build -mod=vendorf
```

#### go mod verify 
Проверяет, соответствуют ли скачанные модули их описаниям в `go.mod`


#### go mod why \<path\>
Объясняет, почему определенный пакет включен в зависимости.
```go
go mod why golang.org/x/text
```




### go get
В режиме модулей `go get` используется для изменения версий зависимостей в вашем `go.mod` или для добавления новых.
`go get example.com/pkg`: Добавит последнюю версию пакета.
`go get example.com/pkg@v1.2.3`: Добавит или обновит пакет до конкретной версии.
`go get -u example.com/pkg`: Обновит пакет до последней минорной или патч-версии.
`go get -u=patch example.com/pkg`: Обновит пакет до последней патч-версии.
`go get -u` - Обновляет все зависимости.
Раньше (до Go Modules) `go get` был основным способом загрузки пакетов. Сейчас его роль несколько изменилась, и для повседневной работы с зависимостями часто достаточно `go mod tidy`.




### go fmt
Автоматически форматирует Go код согласно стандартным правилам Go.
```bash
# Форматировать текущую директорию 
go fmt ./... 

# Форматировать конкретный файл 
go fmt main.go
```


### go vet
Анализирует исходный код Go и сообщает о подозрительных конструкциях, которые могут быть ошибками, но не нарушают синтаксис (например, неправильное использование `Printf` аргументов).
Не гарантирует отсутствие ошибок, но помогает выявить распространенные проблемы.
```bash
go vet ./...
```

##### Внешние линтеры (например, `golangci-lint`)
- Хотя `go vet` полезен, сообщество Go часто использует более мощные инструменты статического анализа, такие как `golangci-lint`. Он объединяет множество линтеров и предоставляет гибкую конфигурацию.
- **Установка (пример)**: `go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest`
- **Использование**: `golangci-lint run`


### go test
Запускает тесты.
Ищет файлы с суффиксом `_test.go` и запускает функции, начинающиеся с `Test` (для юнит-тестов), `Benchmark` (для бенчмарков) или `Example` (для примеров).
```bash
# Запустить все тесты в текущем пакете 
go test 

# Запустить тесты во всех пакетах текущего модуля 
go test ./... 

# Запустить тесты с подробным выводом 
go test -v 

# Запустить конкретный тест по имени (регулярное выражение) 
go test -run TestMyFunction 

# Запустить бенчмарки 
go test -bench . 

# Показать покрытие кода тестами 
go test -cover 
go test -coverprofile=coverage.out && go tool cover -html=coverage.out # Сгенерировать HTML отчет
```


### go doc
Отображает документацию для пакета или символа (функции, переменной и т.д.).
Извлекает комментарии к коду.

```bash
# Документация для пакета 
fmt go doc fmt 

# Документация для функции Println в пакете fmt 
go doc fmt.Println
```


### godoc \<веб-сервер\>
Запускает локальный веб-сервер, который предоставляет документацию в браузере, аналогично pkg.go.dev.
```bash
# Установка (если еще не установлен)
# go get golang.org/x/tools/cmd/godoc (может измениться, проверяйте актуальную команду)
# или go install golang.org/x/tools/cmd/godoc@latest

# Запуск
godoc -http=:6060
```
Затем откройте `http://localhost:6060` в браузере.

### go list
Выводит информацию о пакетах или модулях в различных форматах.
```bash
# Показать все пакеты в текущем модуле
go list ./...

# Показать путь импорта и зависимости пакета fmt
go list -f '{{.ImportPath}} {{.Deps}}' fmt

# Выводит список всех модулей в проекте
go list -m all
```


### go env
Выводит информацию о переменных окружения Go.
```go
go env
go env GOROOT # Показать значение конкретной переменной
```

### go version
Показывает текущую версию Go.


### go work
Появился в Go 1.18, позволяет работать с несколькими модулями одновременно, не требуя изменения их `go.mod` файлов для указания локальных путей. Создает файл `go.work`.
```bash
go work init ./module1 ./module2
go work use ./module3 # Добавить еще один модуль
```


### Delve отладка
Хотя Go не включает отладчик в стандартный набор команд `go ...`, **Delve** является де-факто стандартом для отладки Go программ.
Установка
```bash
go install github.com/go-delve/delve/cmd/dlv@latest
```

