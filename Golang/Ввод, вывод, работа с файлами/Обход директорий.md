В Go для обхода содержимого директорий (файловой системы) есть несколько основных способов, каждый из которых подходит для разных сценариев:

### os.ReadDir() 
- рекомендуется для получения содержимого одной директории
- Это наиболее современный и рекомендуемый способ для получения списка элементов (файлов и поддиректорий) **внутри одной заданной директории**. Она возвращает срез объектов `fs.DirEntry`, каждый из которых содержит информацию о записи (имя, тип, является ли это директорией или символической ссылкой). Это эффективнее, чем `os.ReadDir` (старый `io/ioutil` пакет), так как избегает лишних вызовов `os.Stat` для каждого элемента.
    
```go
package main

import (
	"fmt"
	"io/fs" // Импортируем fs для fs.DirEntry
	"log"
	"os"
)

func main() {
	dirPath := "." // Текущая директория

	entries, err := os.ReadDir(dirPath)
	if err != nil {
		log.Fatalf("Ошибка при чтении директории %s: %v", dirPath, err)
	}

	fmt.Printf("Содержимое директории %s:\n", dirPath)
	for _, entry := range entries {
		if entry.IsDir() {
			fmt.Printf("  [ДИРЕКТОРИЯ] %s\n", entry.Name())
		} else {
			fmt.Printf("  [ФАЙЛ]      %s\n", entry.Name())
		}
	}
}
```

**Когда использовать:** Когда вам нужен только непосредственный список файлов и папок в одной директории, без рекурсивного спуска.


### filepath.WalkDir() 
- рекомендуется для рекурсивного обхода 
- Это наиболее эффективный и предпочтительный способ для **рекурсивного обхода всей структуры директорий**, начиная с заданной корневой директории. Она итерирует по всем файлам и поддиректориям, вызывая для каждого из них функцию обратного вызова (`walkFn`).
    
```go
package main

import (
	"fmt"
	"io/fs"
	"log"
	"path/filepath"
)

func main() {
	root := "." // Начать обход с текущей директории

	fmt.Printf("Рекурсивный обход директории %s:\n", root)
	err := filepath.WalkDir(root, func(path string, d fs.DirEntry, err error) error {
		if err != nil {
			// Если произошла ошибка доступа к элементу (например, нет прав)
			fmt.Printf("Ошибка при доступе к %q: %v\n", path, err)
			// Вы можете вернуть filepath.SkipDir, чтобы пропустить эту директорию
			// или err, чтобы остановить весь обход
			return err
		}

		// Игнорируем скрытые директории или файлы, если нужно
		if d.Name() == ".git" { // Пример: пропустить директорию .git
			return filepath.SkipDir
		}

		// Отступы для визуализации иерархии
		indent := ""
		depth := len(filepath.SplitList(path)) - len(filepath.SplitList(root))
		for i := 0; i < depth; i++ {
			indent += "  "
		}


		if d.IsDir() {
			fmt.Printf("%s[ДИРЕКТОРИЯ] %s\n", indent, path)
		} else {
			info, _ := d.Info() // Получаем FileInfo для размера файла
			fmt.Printf("%s[ФАЙЛ]      %s (Размер: %d байт)\n", indent, path, info.Size())
		}
		return nil // Продолжаем обход
	})

	if err != nil {
		log.Fatalf("Ошибка при обходе: %v", err)
	}
}
```
    
    **Когда использовать:** Когда вам нужно обработать все файлы и поддиректории в сложной структуре каталогов. Это идеальный выбор для поиска файлов, построения списка файлов проекта, создания дерева директорий и т.п.
    
### os.Open() и (\*File).Readdir() 
- устаревший способ для содержимого одной директории:
- Этот метод является более старым способом чтения содержимого директории. Вы открываете директорию как файл, а затем используете метод `Readdir()` для получения списка `os.FileInfo`.
```go
package main

import (
	"fmt"
	"log"
	"os"
)

func main() {
	dirPath := "."

	f, err := os.Open(dirPath)
	if err != nil {
		log.Fatalf("Не удалось открыть директорию %s: %v", dirPath, err)
	}
	defer f.Close()

	// Readdir(n int)
	// n > 0: возвращает не более n FileInfo
	// n <= 0: возвращает все FileInfo
	files, err := f.Readdir(-1)
	if err != nil {
		log.Fatalf("Ошибка при чтении содержимого директории: %v", err)
	}

	fmt.Printf("Содержимое директории %s (с помощью Readdir):\n", dirPath)
	for _, file := range files {
		if file.IsDir() {
			fmt.Printf("  [ДИРЕКТОРИЯ] %s\n", file.Name())
		} else {
			fmt.Printf("  [ФАЙЛ]      %s (Размер: %d байт)\n", file.Name(), file.Size())
		}
	}
}
```
    
    **Когда использовать:** В новых проектах обычно не рекомендуется, так как `os.ReadDir` и `filepath.WalkDir` предлагают более эффективные и современные API. Может встречаться в старом коде.
    
### filepath.Walk() 
- более старый рекурсивный обход:
- Это предшественник `filepath.WalkDir`. Он также рекурсивно обходит директории, но его функция обратного вызова получает `os.FileInfo` вместо `fs.DirEntry`. Получение `os.FileInfo` для каждого элемента может быть менее производительным, чем `fs.DirEntry`, особенно для очень больших директорий, так как `fs.DirEntry` содержит базовую информацию без необходимости выполнять дополнительные системные вызовы.

```
// Использование очень похоже на WalkDir, но с os.FileInfo вместо fs.DirEntry
// ... см. документацию или примеры для более детального сравнения
```
   
**Когда использовать:** Если вы работаете с устаревшим кодом или если у вас есть очень специфическая причина, по которой вам нужен полный `os.FileInfo` на каждом шаге без возможности избежать его получения. В новых проектах предпочитайте `filepath.WalkDir`.



| Способ                | Назначение              | Рекомендация                                        | Особенности                                                                  |
| --------------------- | ----------------------- | --------------------------------------------------- | ---------------------------------------------------------------------------- |
| `os.ReadDir()`        | Содержимое 1 директории | **Да, предпочтительно**                             | Возвращает `[]fs.DirEntry`, избегает лишних `Stat` вызовов.                  |
| `filepath.WalkDir()`  | Рекурсивный обход       | **Да, предпочтительно**                             | Коллбэк получает `fs.DirEntry`, эффективен, позволяет пропускать директории. |
| `os.Open().Readdir()` | Содержимое 1 директории | **Нет, устаревший**                                 | Возвращает `[]os.FileInfo`, может быть менее производительным.               |
| `filepath.Walk()`     | Рекурсивный обход       | **Нет, устаревший** (заменен на `filepath.WalkDir`) | Коллбэк получает `os.FileInfo`, менее эффективен, чем `WalkDir`.             |


