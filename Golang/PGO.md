**PGO (Profile-Guided Optimization)** — это технология оптимизации компиляции, которая использует данные о работе приложения в реальных условиях (профиль) для того, чтобы сделать итоговый бинарный файл еще быстрее.
В Go эта поддержка стала стабильной начиная с версии **1.21**.

### Зачем это нужно?

Обычный компилятор оптимизирует код «вслепую», полагаясь на общие алгоритмы. Однако он не знает, какие части вашего кода выполняются чаще всего. PGO позволяет компилятору сосредоточиться на «горячих» участках кода.

**Основные преимущества:**

- **Inlining (Подстановка функций):** Компилятор встраивает тело часто вызываемой функции прямо в место вызова, убирая накладные расходы на сам вызов.  При этом растет размер получаемого бинарника.
- **Devirtualization (Девиртуализация):** Если интерфейс почти всегда вызывает одну и ту же конкретную структуру, PGO заменяет косвенный вызов через таблицу интерфейса на прямой вызов метода.
- **Прирост производительности:** По разным оценкам (и официальным данным Google), PGO дает ускорение от **2% до 14%** без изменения кода.


### Как это реализуется (процесс)

Процесс использования PGO в Go выглядит как цикл:
1. **Сборка без PGO:** Вы компилируете приложение обычным способом. 
2. **Сбор профиля:** Вы запускаете приложение под нагрузкой (на стейджинге или в продакшене) и собираете данные о производительности в файл `default.pgo` (обычно через `pprof`).
3. **Сборка с PGO:** Вы пересобираете приложение, передавая этот файл компилятору. Он использует данные для оптимизации.

### Рекомендации

- **Имя файла:** Если вы назовете файл `default.pgo` и положите его в директорию с `main`, вам не нужно менять скрипты сборки — `go build` применит его автоматически.  
- **Актуальность:** Профиль нужно периодически обновлять. Если код сильно изменился, старый профиль станет менее эффективным (но он не «сломает» сборку, Go просто проигнорирует несовпадающие части).
- **Source of truth:** Профиль лучше собирать с реального «боевого» трафика, так как синтетические тесты часто не отражают реальную нагрузку.

### Пример использования PGO
Предположим, у нас есть сервис, который интенсивно использует интерфейсы или маленькие функции.

#### 1. Подготовка кода
Добавьте поддержку `net/http/pprof` в ваше приложение, чтобы можно было снять профиль на лету.
```go
package main

import (
	"net/http"
	_ "net/http/pprof"
	"fmt"
)

func main() {
	// Запускаем pprof сервер для снятия метрик
	go func() {
		http.ListenAndServe("localhost:6060", nil)
	}()

	// Ваша бизнес-логика
	for {
		work()
	}
}

func work() {
    // Какая-то интенсивная работа
    fmt.Sprint("CPU heavy task")
}
```


#### 2. Сбор профиля (CPU Profile)

Запустите приложение. Пока оно работает под нагрузкой, выполните команду в терминале, чтобы собрать данные в течение 30 секунд:
```bash
curl -o cpu.pprof "http://localhost:6060/debug/pprof/profile?seconds=30"
```


#### 3. Сборка с оптимизацией

Теперь нужно переименовать полученный файл в `default.pgo` и положить его в корень вашего пакета (Main package). Go автоматически подхватит его при сборке.
```bash
# Переименовываем профиль
mv cpu.pprof default.pgo

# Собираем приложение (Go 1.21+ увидит default.pgo сам)
go build -o my_app_optimized .
```

Если файл профиля не переименовывали в `default.pgo` то поступаем так:
```bash
# Если файл называется иначе, можно указать явно:
go build -pgo=cpu.pprof -o my_app_optimized .
```

