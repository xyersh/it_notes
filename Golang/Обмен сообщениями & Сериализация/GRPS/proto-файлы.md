
### Структура и Требования к .proto файлам


#### поддерживаемые типы данных

##### Встроенные типы данных

|              |          |             |                   |              |                                                   |
| ------------ | -------- | ----------- | ----------------- | ------------ | ------------------------------------------------- |
| Тип в .proto | Тип в Go | Тип в C++   | Тип в Java/Kotlin | Тип в Python | Описание                                          |
| double       | float64  | double      | double            | float        | 64-битное число с плавающей точкой.               |
| float        | float32  | float       | float             | float        | 32-битное число с плавающей точкой.               |
| int32        | int32    | int32_t     | int               | int          | 32-битное целое число.                            |
| int64        | int64    | int64_t     | long              | int          | 64-битное целое число.                            |
| uint32       | uint32   | uint32_t    | int               | int          | 32-битное беззнаковое целое.                      |
| uint64       | uint64   | uint64_t    | long              | int          | 64-битное беззнаковое целое.                      |
| sint32       | int32    | int32_t     | int               | int          | 32-битное целое (эффективное кодирование ZigZag). |
| sint64       | int64    | int64_t     | long              | int          | 64-битное целое (эффективное кодирование ZigZag). |
| fixed32      | uint32   | uint32_t    | int               | int          | 32-битное число, всегда 4 байта.                  |
| fixed64      | uint64   | uint64_t    | long              | int          | 64-битное число, всегда 8 байт.                   |
| sfixed32     | int32    | int32_t     | int               | int          | 32-битное число со знаком, всегда 4 байта.        |
| sfixed64     | int64    | int64_t     | long              | int          | 64-битное число со знаком, всегда 8 байт.         |
| bool         | bool     | bool        | boolean           | bool         | Логическое значение true или false.               |
| string       | string   | std::string | String            | str          | Строка в кодировке UTF-8.                         |
| bytes        | []byte   | std::string | ByteString        | bytes        | Последовательность произвольных байтов.           |
##### Перечисления (Enums)
**`enum`**: Позволяет создать свой собственный тип данных с набором именованных констант. Каждой константе должна быть присвоена уникальная числовая метка (тег). Первая константа должна иметь нулевую метку и является значением по умолчанию.
```protobuf
enum Corpus {
  UNIVERSAL = 0;
  WEB = 1;
  IMAGES = 2;
  LOCAL = 3;
}
```

##### Составные типы (Composite Types)
Это основной способ структурирования данных. Вы можете использовать один тип сообщения в качестве типа поля для другого, создавая вложенные структуры. В Go каждому сообщению будет соответствовать сгенерированная структура (`struct`).
```protobuf
message SearchResponse {
  repeated Result results = 1; // Поле results является массивом сообщений типа Result
}

message Result {
  string url = 1;
  string title = 2;
}
```

##### Повторяющиеся поля (Массивы/Слайсы)
Любой скалярный тип или тип сообщения может быть объявлен как повторяющийся (массив) с помощью ключевого слова `repeated`. В Go это будет представлено в виде слайса (`slice`).
```protobuf
// В Go это будет: []int32
repeated int32 error_codes = 4;
```


##### Словари (Maps)
Protobuf поддерживает тип "словарь" или "ассоциативный массив" с помощью ключевого слова `map`. В Go это транслируется напрямую в `map`.
```protobuf
// В Go это будет: map[string]int32
map<string, int32> project_scores = 5;
```

##### Специальные типы (Well-Known Types)
Protobuf поставляется с набором предопределенных, часто используемых сообщений, которые можно импортировать и использовать. Пакет `protoc-gen-go` предоставляет готовые структуры Go для этих типов.
- `google.protobuf.Any`: Позволяет вложить в поле сообщение любого типа.
- `google.protobuf.Timestamp`: Для представления времени.
- `google.protobuf.Duration`: Для представления промежутка времени.
- `google.protobuf.Struct`: Для представления произвольных данных в формате, похожем на JSON.
- `google.protobuf.Empty`: Сообщение без полей, используется, когда метод не принимает или не возвращает данные.
- Типы-обертки (`StringValue`, `Int32Value` и т.д.): Позволяют отличать неустановленное значение от значения по умолчанию (например, 0 для `int32`).
#### Базовая Структура .proto файла
Каждый `.proto` файл имеет четкую иерархическую структуру. Вот основные элементы, которые вы найдете в типичном `.proto` файле:

```protobuf
// (Опционально) Заголовок с комментариями о файле, авторе, назначении и т.д.

syntax = "proto3"; // 1. Обязательное объявление синтаксиса

package my_application.my_service; // 2. Обязательное объявление пакета Protobuf

// 3. (Опционально) Импорты других .proto файлов
import "google/protobuf/timestamp.proto";
import "common/user.proto";

// 4. (Опционально) Опции файла (глобальные настройки для сгенерированного кода)
option java_package = "com.my_application.my_service.proto";
option java_multiple_files = true;
option go_package = "github.com/my_org/my_application/gen/proto;my_service_pb"; // Очень важно для Go!

// 5. Определения Сообщений (Messages)
message UserProfile {
  string user_id = 1;
  string username = 2;
  int32 age = 3;
  repeated string interests = 4; // Повторяющееся поле (массив)
  bool is_active = 5;
  google.protobuf.Timestamp last_login_at = 6; // Использование импортированного типа
  // Вложенное сообщение
  message Address {
    string street = 1;
    string city = 2;
    string zip_code = 3;
  }
  Address home_address = 7;
  
  // Oneof поле
  oneof contact_info {
    string email = 8;
    string phone_number = 9;
  }
  map<string, string> metadata = 10; // Карта (map)
}

// 6. Определения Перечислений (Enums)
enum UserStatus {
  USER_STATUS_UNKNOWN = 0; // Всегда начинайте с 0 для UNKNOWN/UNSPECIFIED
  USER_STATUS_ACTIVE = 1;
  USER_STATUS_INACTIVE = 2;
  USER_STATUS_PENDING = 3;
}

// 7. Определения Сервисов (Services - обычно для gRPC)
service UserService {
  rpc GetUserProfile (GetUserProfileRequest) returns (UserProfile);
  rpc CreateUser (CreateUserRequest) returns (UserProfile);
  rpc UpdateUserStatus (UpdateUserStatusRequest) returns (google.protobuf.Empty); // Использование стандартного пустого сообщения
}

// Вспомогательные сообщения для сервисов
message GetUserProfileRequest {
  string user_id = 1;
}

message CreateUserRequest {
  string username = 1;
  int32 age = 2;
  repeated string interests = 3;
}

message UpdateUserStatusRequest {
  string user_id = 1;
  UserStatus status = 2;
}
```

#### Подробное Описание Элементов Структуры и Требований

##### Объявление Синтаксиса (`syntax = "proto3";`)
- **Требование:** Обязательно должна быть первой не-комментированной строкой в файле.
- **Назначение:** Указывает версию синтаксиса Protocol Buffers, который используется в файле.
- **Важность:** `proto3` является рекомендуемым и наиболее современным синтаксисом. Он имеет упрощенные правила по сравнению с `proto2` (например, нет `required`, нет полей `default`, изменены правила для `repeated`, появился `oneof` и `map`).
- **Пример:** `syntax = "proto3";`

##### Объявление Пакета (`package`)
- Представляет собой неймспейс  прото-файла.
- Должен быть уникальным!!
- **Требование:** Рекомендуется, но не строго обязательно для компиляции. Однако **настоятельно рекомендуется** для предотвращения конфликтов имен.
- **Назначение:** Определяет пространство имен для ваших сообщений и сервисов. Это помогает избежать коллизий имен, особенно когда вы импортируете сообщения из других `.proto` файлов.
- **Влияние на сгенерированный код:**
    - В Java: Становится частью имени пакета (например, `com.example.my_package.MyMessage`).
    - В Go: Влияет на `go_package` (если не указано явно) и на пути импорта.
    - В Python: Может влиять на структуру модулей.
- **Пример:** `package my_application.user_service;`

##### Импорты (`import`)

- **Требование:** Обязательно, если ваш `.proto` файл использует типы, определенные в других `.proto` файлах.
- **Назначение:** Позволяет вам повторно использовать сообщения, перечисления и сервисы, определенные в других `.proto` файлах.
- **Относительные пути:** Пути импорта обычно относительны к одному из каталогов, указанных в флаге `--proto_path` (или `-I`) при вызове `protoc`.
- **Пример:**
    - `import "google/protobuf/timestamp.proto";` (для использования стандартных типов Google)
    - `import "common/user.proto";` (для импорта вашего собственного файла `user.proto` из директории `common`)


##### Опции Файла (`option`)

- **Требование:** Опционально.
- **Назначение:** Предоставляют метаданные для `protoc`, которые влияют на то, как генерируется код для конкретного языка.
- **Важные опции (примеры):**
    - `option java_package = "com.example.my_app.protos";` (Java: определяет имя пакета для сгенерированного Java-кода)
    - `option java_outer_classname = "MyAppProto";` (Java: определяет имя класса, который содержит все сообщения и сервисы, если `java_multiple_files` не `true`)
    - `option java_multiple_files = true;` (Java: генерирует отдельные файлы для каждого сообщения/сервиса, а не один большой класс-обертку)
    - **`option go_package = "github.com/my_org/my_app/protos;my_app_proto";` (Go: критически важно! Определяет полный импортный путь и имя Go-пакета для сгенерированного кода).**
    - `option csharp_namespace = "MyApp.Protos";` (C#)
    - `option php_namespace = "MyApp\\Protos";` (PHP)
- **Размещение:** Обычно располагаются после `syntax` и `package`, но до определений сообщений и сервисов.

##### Определения Сообщений (`message`)

- **Требование:** Обязательное ядро любого `.proto` файла, определяющее структуру ваших данных.
- **Назначение:** Определяет структурированные данные. Сообщения состоят из полей.
- **Поля сообщения:**
    - **Тип поля:** (например, `string`, `int32`, `bool`, `UserStatus`, `UserProfile.Address`).
    - **Имя поля:** (например, `username`, `age`). Должно быть в `snake_case`.
    - **Уникальный номер поля (tag number):** (например, `1`, `2`, `3`). Это **очень важно** для бинарной совместимости.
        - Номера от 1 до 15 занимают один байт для кодирования тега. Используйте их для часто используемых полей.
        - Номера от 16 до 2047 занимают два байта.
        - Не используйте номера от 19000 до 19999 (`FieldDescriptor::kFirstReservedTag` до `FieldDescriptor::kLastReservedTag`), так как они зарезервированы для внутреннего использования Protocol Buffers.
        - **Никогда не меняйте номер поля после его публикации!** Изменение типа поля также является критическим изменением.
        - При удалении поля, зарезервируйте его номер и имя с помощью `reserved` для предотвращения случайного повторного использования:
            
            Protocol Buffers
            
            ```proto
            message MyMessage {
              string old_field_name = 1; // Это поле удалено
              reserved 1, 3 to 5;
              reserved "old_field_name", "another_old_field";
              string new_field = 2;
            }
            ```
            
    - **Правила поля (`proto3`):**
        - Поля по умолчанию **опциональны**. Если поле не установлено, оно принимает значение по умолчанию для своего типа (0 для чисел, пустая строка для строк, false для булевых, пустое значение для enum, `nil` для сообщений).
        - `repeated`: Указывает, что поле может содержать ноль или более элементов (аналог массива/списка).
        - `map<key_type, value_type>`: Для ассоциативных массивов/карт. `key_type` может быть любым целочисленным или строковым типом.
        - `oneof`: Позволяет определить набор полей, из которых в каждый момент времени может быть установлено только одно. Удобно для представления взаимоисключающих данных.
            
            Protocol Buffers
            
            ```
            oneof data {
              string text_data = 1;
              bytes binary_data = 2;
            }
            ```
            
- **Вложенные сообщения:** Сообщения могут быть вложенными, что помогает организовывать сложные структуры данных.

##### Определения Перечислений (`enum`)
- **Требование:** Опционально, но очень полезно для определения фиксированного набора значений.
- **Назначение:** Определяет перечисляемый тип (список именованных констант).
- **Требование:** **Первый элемент перечисления (с номером 0) всегда должен быть "неизвестным" или "неуказанным" значением.** Это критически важно для обработки неизвестных значений при десериализации (например, при получении данных от более новой версии сервиса, которая имеет новые значения enum).
- **Пример:** `USER_STATUS_UNKNOWN = 0;`


##### Определения Сервисов (`service`)
- **Требование:** Опционально. Используется в основном для определения gRPC сервисов.
- **Назначение:** Определяет RPC-сервис с набором методов, которые могут быть вызваны удаленно.
- **Методы RPC:**
    - `rpc MethodName (RequestType) returns (ResponseType);`
    - `RequestType` и `ResponseType` должны быть определенными в proto-файле сообщениями.
    - Поддерживаются также потоковые RPC:
        - `rpc ClientStream (stream RequestType) returns (ResponseType);` (клиентский поток)
        - `rpc ServerStream (RequestType) returns (stream ResponseType);` (серверный поток)
        - `rpc BidirectionalStream (stream RequestType) returns (stream ResponseType);` (двунаправленный поток)
- **Пример:**
```proto
service UserService {
  rpc GetUserProfile (GetUserProfileRequest) returns (UserProfile);
}
```

##### Общие Требования и Лучшие Практики
- **Соглашения об именовании:**
	- **Файлы:** `snake_case.proto` (например, `user_profile.proto`, `payment_service.proto`).
	- **Сообщения:** `CamelCase` (PascalCase) (например, `UserProfile`, `OrderConfirmation`).
	- **Поля сообщений:** `snake_case` (например, `user_id`, `order_status`).
	- **Перечисления:** `CamelCase` (PascalCase) (например, `UserStatus`).
	- **Значения перечислений:** `ALL_CAPS_SNAKE_CASE` (например, `USER_STATUS_ACTIVE`, `ORDER_STATUS_PENDING`).
	- **Сервисы:** `CamelCase` (PascalCase) (например, `UserService`, `ProductCatalogService`).
	- **Методы RPC:** `CamelCase` (PascalCase) (например, `GetUserProfile`, `CreateOrder`).
	- 
- **Постоянство номеров полей (Tag Numbers):** Это критически важно для обратной и прямой совместимости. После того, как вы определили поле с определенным номером, **никогда не меняйте этот номер и никогда не используйте его повторно для другого поля**, даже если вы удалили исходное поле (используйте `reserved`).

- **Совместимость:**
	- **Добавление новых полей:** Допустимо. Старые клиенты будут игнорировать новые поля. Новые клиенты будут получать значения по умолчанию от старых серверов (для новых полей).
	- **Удаление полей:** Опасно. Сначала зарезервируйте номер и имя. Старые клиенты будут пытаться отправлять это поле, а новые серверы будут его игнорировать.
	- **Изменение типа поля:** **Никогда не делайте этого**, если вам нужна совместимость.
	- **Изменение `package` или `go_package`:** Требует перекомпиляции всех зависимых сервисов.

- **`option go_package` (для Go):** Для Go-проектов это является **ключевым требованием** для правильной организации пакетов. Он должен содержать полный путь импорта к пакету и опционально имя пакета после точки с запятой (например, `github.com/your_org/your_repo/protos/my_package;my_package`).

- **Использование стандартных типов Google:** Для общих типов данных, таких как даты/время (`google.protobuf.Timestamp`), продолжительность (`google.protobuf.Duration`), любые (`google.protobuf.Any`), пустые сообщения (`google.protobuf.Empty`) и другие, всегда импортируйте и используйте соответствующие типы из `google/protobuf/*.proto`. Это обеспечивает согласованность и совместимость.

- **Комментарии:** Используйте стандартные C-стиль комментарии (`//` или `/* ... */`) для объяснения цели сообщений, полей, перечислений и сервисов. Это значительно улучшает читаемость и поддерживаемость.

- **Разделение файлов:** Для больших систем рекомендуется разбивать `.proto` файлы на логические единицы (например, по доменным сущностям или по сервисам), а затем импортировать их по мере необходимости.