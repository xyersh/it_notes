
### ТЕРМИНЫ
**Protobuf (Protocol Buffers)** — это, по своей сути, язык и набор инструментов для сериализации структурированных данных. Представьте его как более эффективную, быструю и компактную альтернативу форматам XML и JSON.

**gRPC (gRPC Remote Procedure Call)** — это высокопроизводительный фреймворк для удаленного вызова процедур (RPC), разработанный Google. Он позволяет клиентскому приложению напрямую вызывать методы на серверном приложении, как будто это локальный вызов функции.

### Ключевые особенности Protobuf:

- **Сериализация данных:** Основная задача Protobuf — преобразование структурированных данных (например, объектов в коде) в компактный двоичный формат для хранения или передачи по сети. Этот процесс называется сериализацией. Затем эти двоичные данные могут быть легко преобразованы обратно в структуру данных (десериализация).
- **Определение схемы:** Структура данных описывается в специальном файле с расширением `.proto`. В этом файле вы определяете "сообщения" (messages), которые содержат поля с определенными типами данных (например, `string`, `int32`, `bool`).
- **Генерация кода:** На основе `.proto` файла специальный компилятор Protobuf генерирует исходный код для различных языков программирования (Java, Python, Go, C++ и др.). Этот сгенерированный код упрощает работу с данными: создание, чтение и запись сообщений.
- **Независимость от языка и платформы:** Двоичный формат Protobuf является платформенно-независимым, что позволяет разным сервисам, написанным на разных языках, обмениваться данными без проблем.

### Ключевые особенности gRPC:

- **Клиент-серверная модель:** gRPC работает по принципу клиент-сервер. Клиент инициирует вызов, а сервер предоставляет сервис с набором удаленных методов.
- **Использование Protobuf по умолчанию:** gRPC использует Protobuf в качестве своего "языка" для определения сервисов и сериализации данных. В `.proto` файле, помимо сообщений (данных), описываются и "сервисы" (services) с их методами.
- **Работа поверх HTTP/2:** gRPC использует протокол HTTP/2, что дает ему значительные преимущества в производительности по сравнению с традиционными REST API на базе HTTP/1.1. HTTP/2 поддерживает двунаправленную потоковую передачу данных (streaming), мультиплексирование (множество запросов в одном соединении) и сжатие заголовков.
- **Различные типы RPC:** gRPC поддерживает не только простые "запрос-ответ" вызовы, но и более сложные сценарии взаимодействия, такие как серверный стриминг, клиентский стриминг и двунаправленный стриминг.
### ПРЕИМУЩЕСТВА ПРИМЕНЕНИЯ gRPC
- четкая схема данных с четкими типами
- Меньший объем данных
-  поддержка на разных языках и платформах
- обратная совместимость

 
### ИНСТРУМЕНТЫ  ДЛЯ РАБОТЫ С gRPC
- **protoc** - компилятор, который генерирует код на нужном нам ЯП на основе ваших `.proto` файлов и параметров компиляции.
- **Go gRPC плагины для protoc** - генерируют Go-код для gRPC.
	- **protoc-gen-go** - 
	- **protoc-gen-go-grpc** - 
- **.proto** - прото-файл, 


### GRPC-МЕТОДЫ
Тип метода rpc зависит от наличия/положения ключевого слова `stream` 
- **rpc Method_name(Request) returns Responce;** - унарные rpc
- **rpc Method_name(Request) returns (stream Responce);** - серверные потоковые rpc
- **rpc Method_name(stream Request) returns Responce;** - клиентские потоковые rpc
- **rpc Method_name(stream Request) returns (stream Responce);** - двунаправленные потоковые rpc



### УСТАНОВКА КОМПОНЕНТОВ
#### Protoc
- [https://github.com/protocolbuffers/protobuf/releases](https://github.com/protocolbuffers/protobuf/releases)- скачать нужный релиз софтины
- распаковать архив в любое удобное место на компе
-  В системной переменной `PATH` установить абсолютный путь к директории /bin протобафа
- проверить установку протобафа: 
```bash
 protoc --version
```

#### Go gRPC плагины для protoc:
```go
go install google.golang.org/protobuf/cmd/protoc-gen-go@latest
go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@latest
```
Убедиться что путь, эквивалентный `$GOPATH/bin` находится в переменной `$PATH`.


### СОЗДАНИЕ .proto - ФАЙЛА

```proto
syntax = "proto3";  
  
option go_package= "simple_grpc_app/calculatorpb";  
  
package calculator;  
  
message SumRequest {  
    int32 a = 1;  
    int32 b = 2;  
}  
  
message SumResponce {  
    int32 result = 1;  
}  
  
// Сервис  
service CalculatorService{  
    rpc Sum(SumRequest) returns (SumResponce);  
}
```

### protoc - КОМПИЛЯЦИЯ ФАЙЛОВ

Компиляция происходит при помощи команды вида: 
```bash
protoc --proto_path=proto --go_opt=paths=source_relative --go_out=./proto_out/ --go-grpc_out=./proto_out/ --go-grpc_opt=paths=source_relative calculator.proto
```
Где:
- `--proto_path=proto` или `-I proto` - флаг с указанием директории (`proto`) с исходными .proto-файлом 
- `--go_out=./proto_out/` - указывает `protoc-gen-go` генерировать Go-код в  директорию `proto_out`
- `--go_opt=paths=source_relative` - указывает, что пути к генерируемым файлам должны быть относительными к папке, указанной флагом `--go_out`
- `--go-grpc_out=./proto_out/` - указывает `protoc-gen-go-grpc` генерировать Go-код в  директорию `proto_out`
- `--go-grpc_opt=paths=source_relative` - указывает, что пути к генерируемым файлам должны быть относительными к папке, указанной флагом `--go-grpc_out`
- `calculator.proto` -исходный .proto-файл, который нужно компилировать

В итоге получаем 2 файла: 
- **calculator.pb.go** -  Содержит сгенерированные структуры Go для ваших Protocol Buffer сообщений.
- **calculator_grpc.pb.go** - Содержит сгенерированные интерфейсы для нашего gRPC-сервиса, которые нам нужно будет реализовать (для сервера) и использовать (для клиента).

