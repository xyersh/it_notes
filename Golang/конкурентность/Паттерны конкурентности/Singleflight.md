
### Что это такое?
**Паттерн "singleflight"** (одиночный вызов) применяется для решения задач, связанных с **дедупликацией одновременных вызовов** к ресурсоёмким операциям. Основная его цель — предотвратить многократное выполнение одной и той же задачи, инициированной несколькими параллельными запросами.

Представьте ситуацию, когда множество пользователей одновременно запрашивают одни и те же данные, которые нужно вычислить или загрузить из внешнего источника (например, из базы данных или другого сервиса). Без "singleflight" система выполнит эту дорогостоящую операцию для каждого запроса, создавая избыточную нагрузку.

С паттерном "singleflight" **только первый запрос** инициирует выполнение операции. Все последующие идентичные запросы, поступившие во время её выполнения, не запускают новый процесс, а **ожидают результата от первого вызова** и получают его же.

### Основные задачи для применения паттерна "singleflight":

- **Кеширование с защитой от "собачьей конуры" (Cache Stampede/Dogpiling):** Это классический пример. Когда данные в кеше устаревают, множество запросов одновременно пытаются их обновить. "Singleflight" гарантирует, что только один запрос пойдёт за новыми данными в базу данных или API, а остальные будут ожидать и затем получат свежие данные из кеша, обновлённого первым запросом.
    
- **Работа с API и внешними сервисами:** При интеграции с внешними системами, где количество запросов может быть ограничено (rate limiting) или каждый вызов является платным, "singleflight" помогает сократить число обращений и избежать лишних расходов или блокировок.
    
- **Выполнение ресурсоёмких вычислений:** Если в системе есть сложные расчёты (например, генерация отчётов, обработка изображений, машинное обучение), которые запрашиваются параллельно с одинаковыми параметрами, этот паттерн предотвратит дублирование работы процессора и использование памяти.
    
- **Инициализация объектов и состояний:** При запуске системы или компонента, когда несколько потоков могут попытаться инициализировать один и тот же глобальный объект или состояние, "singleflight" обеспечивает, что инициализация произойдёт только один раз.
    

Таким образом, "singleflight" — это эффективный механизм оптимизации, который **снижает нагрузку на систему**, **ускоряет ответ для параллельных клиентов** и **экономит ресурсы** в сценариях с повторяющимися дорогостоящими операциями.


### Примеры
#### использование стандартного singleflight
применяется пакет:  **golang.org/x/sync/singleflight**
Представим, что у нас есть функция `getDataFromDB()`, которая делает дорогой запрос к базе данных. Мы хотим защитить её от одновременных вызовов.
```go
package main

import (
	"fmt"
	"sync"
	"time"

	"golang.org/x/sync/singleflight"
)

// getDataFromDB имитирует долгий запрос к базе данных.
func getDataFromDB(key string) (string, error) {
	fmt.Printf("Запрос к БД для ключа: %s\n", key)
	time.Sleep(2 * time.Second) // Имитация долгой работы
	return fmt.Sprintf("Данные для %s", key), nil
}

func main() {
	var g singleflight.Group
	var wg sync.WaitGroup

	// Запускаем 10 горутин, которые одновременно пытаются получить данные
	for i := 0; i < 10; i++ {
		wg.Add(1)
		go func(i int) {
			defer wg.Done()
			
			// Ключ для всех запросов один и тот же
			resourceKey := "some_resource"

			// Используем Do для выполнения функции
			v, err, shared := g.Do(resourceKey, func() (interface{}, error) {
				return getDataFromDB(resourceKey)
			})

			if err != nil {
				fmt.Printf("Горутина %d: ошибка: %v\n", i, err)
				return
			}
			
			// Выводим результат и информацию о том, был ли он получен совместно
			fmt.Printf("Горутина %d: получила результат: '%s'. Результат общий: %t\n", i, v, shared)
		}(i)
	}

	wg.Wait()
}
```
##### Как это работает?
Основным типом в пакете является `singleflight.Group`. Вы создаете экземпляр этой структуры и используете его для всех операций, которые хотите защитить от дублирования.

У `Group` есть ключевой метод — `Do(key string, fn func() (interface{}, error))`.

1. **`key`**: Уникальный ключ, который идентифицирует операцию. Например, если вы запрашиваете данные пользователя, ключом может быть его ID.
2. **`fn`**: Функция, которая выполняет ресурсоёмкую работу (например, запрос в базу данных или к внешнему API).

Когда `Do` вызывается с определённым ключом:

- **Если операция с таким ключом ещё не выполняется**, `singleflight` запускает вашу функцию `fn` и сохраняет её результат (и ошибку).
- **Если операция с таким ключом уже запущена другим запросом**, новый вызов `Do` не запускает `fn` повторно, а просто ожидает завершения первого вызова и возвращает его же результат.


#### Пример кастомной реализации



**`call`** - эта структура представляет собой состояние одного активного вызова.

- `val` и `err`: Здесь будут храниться результат (`value`) и ошибка (`error`) выполненной операции `action`. Тип `any` (псевдоним `interface{}`) позволяет хранить результат любого типа.
- `done chan struct{}`: Это **ключевой механизм синхронизации**. Канал `done` используется как сигнал о завершении. Когда операция выполнена, этот канал закрывается. Все горутины, ожидающие результата, заблокированы на чтении из этого канала (`<-call.done`). Как только канал закрывается, все они мгновенно разблокируются.

	**`SingleFlight`** -  это главный управляющий объект.

- `calls map[string]*call`: Это хранилище всех **текущих, активных** операций.
    - **Ключ (`string`)** — это идентификатор операции (например, "user:123").
    - **Значение (`*call`)** — это указатель на объект `call`, который содержит состояние этой активной операции.
- `mu sync.Mutex`: Мьютекс необходим для защиты карты `calls` от одновременного доступа из разных горутин (гонки данных). Любая операция с `s.calls` (чтение, запись, удаление) должна быть обёрнута в `s.mu.Lock()` и `s.mu.Unlock()`.


```go
package main  
  
import (  
    "fmt"  
    "sync"    "time")  
  
type call struct {  
    err  error  
    val  any  
    done chan struct{}  
}  
  
type SingleFlight struct {  
    mu    sync.Mutex  
    calls map[string]*call  
}  
  
func NewSingleFlight() *SingleFlight {  
    return &SingleFlight{  
       calls: make(map[string]*call),  
    }  
}  
  
func (s *SingleFlight) Do(key string, action func() (any, error)) (any, error) {  
    // 1. Захватываем мьютекс для безопасной работы с картой `calls`.  
    s.mu.Lock()  
  
    // 2. Проверяем, есть ли уже активный вызов для этого ключа.  
    if call, found := s.calls[key]; found {  
       // 2a. ВЫЗОВ УЖЕ В ПРОЦЕССЕ  
       // Если нашли, значит, другая горутина уже запустила эту операцию.       // Важно: немедленно освобождаем мьютекс, чтобы не блокировать другие горутины.       s.mu.Unlock()  
       // Начинаем ждать результата от уже идущего вызова.  
       return s.wait(call)  
    }  
  
    // 2b. ЭТО ПЕРВЫЙ ВЫЗОВ ДЛЯ ДАННОГО КЛЮЧА  
    // Создаём новый объект `call` с каналом для сигнализации.    call := &call{  
       done: make(chan struct{}),  
    }  
    // Добавляем его в карту, чтобы другие горутины знали, что операция запущена.  
    s.calls[key] = call  
    // Освобождаем мьютекс, чтобы другие горутины могли продолжить работу.  
    s.mu.Unlock()  
  
    // 3. Запускаем выполнение `action` в отдельной горутине.  
    // Это нужно, чтобы не блокировать текущего вызывающего на время выполнения `action`.    go func() {  
       // 4. Блок `defer` гарантирует очистку после завершения `action`.  
       defer func() {  
          // Снова блокируем мьютекс для безопасной очистки карты.  
          s.mu.Lock()  
          // Закрываем канал `done` - это сигнал всем ожидающим, что результат готов.  
          close(call.done)  
          // Удаляем запись из карты, т.к. операция завершена.  
          delete(s.calls, key)  
          s.mu.Unlock()  
       }()  
  
       // 5. Выполняем саму ресурсоёмкую операцию и сохраняем её результат в `call`.  
       call.val, call.err = action()  
    }()  
  
    // 6. Первый вызывающий (как и все последующие) тоже ждёт результата.  
    return s.wait(call)  
}  
  
func (s *SingleFlight) wait(call *call) (any, error) {  
    // Блокируемся здесь, пока канал `call.done` не будет закрыт.  
    <-call.done  
    // Как только канал закрыт, чтение из него моментально завершается.  
    // Возвращаем сохранённые в `call` значение и ошибку.    return call.val, call.err  
}  
  
func main() {  
    const inFlightREquests = 5  
    var wg sync.WaitGroup  
    singleFlight := NewSingleFlight()  
  
    // Используем один и тот же ключ для всех запросов  
    const requestKey = "my_resource_key"  
  
    for i := 0; i < inFlightREquests; i++ {  
       wg.Add(1)  
       go func(i int) {  
          defer wg.Done()  
  
          fmt.Printf("Горутина %d запрашивает ключ '%s'\n", i, requestKey)  
          value, err := singleFlight.Do(requestKey, func() (any, error) {  
             // Эта часть выполнится только ОДИН РАЗ  
             fmt.Println("!!! Выполняется ресурсоёмкая операция... !!!")  
             time.Sleep(2 * time.Second)  
             return "результат из долгой операции", nil  
          })  
  
          fmt.Printf("Горутина %d получила: val: %v, err: %v\n", i, value, err)  
       }(i)  
    }  
    wg.Wait()  
}
```