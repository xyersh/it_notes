### Идея паттерна "Or-Done"
Паттерн **Or-Done** (или **Or-Channel**) — это один из ключевых шаблонов конкурентного программирования в **Go**, используемый для **управления отменой (cancellation)** и **завершением** работы нескольких горутин или конвейера (pipeline) при получении сигнала от одного из каналов.

Как только любой из входных каналов `done` будет закрыт или получит значение, "объединенный" канал также закроется (или получит значение, в зависимости от реализации), сигнализируя всем ожидающим горутинам, что пора прекращать работу.

### Преимущества использования

|**Преимущество**|**Описание**|
|---|---|
|**Управление отменой**|Позволяет изящно остановить цепочку горутин или конвейер обработки данных, предотвращая утечки горутин (goroutine leaks) и ненужное потребление ресурсов.|
|**Реакция на множественные сигналы**|Дает возможность горутине отслеживать не только свой рабочий канал, но и несколько потенциальных сигналов завершения, реагируя на тот, который сработает первым.|
|**Гибкость**|Может быть использован для создания канала, который закрывается, как только любой из нескольких входных каналов _завершится_ (поэтому "or-done").|


### Возможные нюансы использования

1. **Утечки горутин:** Основная цель паттерна — предотвратить утечки, но неправильная его реализация (например, забыть о `defer close(out)` или не проверить канал `done` в цикле `select`) сама может привести к утечке горутины-обработчика паттерна.
    
2. **Арбитражность `select`:** Если одновременно доступны и рабочий канал (`c`), и канал завершения (`done`), оператор `select` **произвольно** выберет один из них. В большинстве случаев это не критично, поскольку канал `done` обычно _закрывается_ (становится доступным постоянно) и будет выбран очень быстро, что приведет к завершению работы.
    
3. **Использование пустого `struct{}`:** Каналы `done` часто имеют тип `chan struct{}`, так как важен сам факт закрытия/приема сигнала, а не пересылаемое значение. Использование пустого `struct{}` минимизирует накладные расходы на память.





```go
func OrDone[T any](src <-chan T, done <-chan struct{}) <-chan T {
	out := make(chan T)

	go func() {
		defer close(out)
		for {
			select {
				//контроль на Done при чтении с входного канала
				case <-done:
				    return
				case v, ok := <-src:
				    if !ok {
					    return
				    }

				    select {
					    // контроль на Done записи в выходной канал
					    case <-done:
						    return
					    case out <- v:
					}
			}
		}
	}()
 return out
}

```



### Пример


 