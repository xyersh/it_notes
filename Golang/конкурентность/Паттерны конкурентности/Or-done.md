### Назначение паттерна "Or-Done"
Паттерн **Or-Done** (или **Or-Channel**) — это один из ключевых шаблонов конкурентного программирования в **Go**, используемый для **управления отменой (cancellation)** и **завершением** работы нескольких горутин или конвейера (pipeline) при получении сигнала от одного из каналов.

Как только любой из входных каналов `done` будет закрыт или получит значение, "объединенный" канал также закроется (или получит значение, в зависимости от реализации), сигнализируя всем ожидающим горутинам, что пора прекращать работу.

### Преимущества использования

|**Преимущество**|**Описание**|
|---|---|
|**Управление отменой**|Позволяет изящно остановить цепочку горутин или конвейер обработки данных, предотвращая утечки горутин (goroutine leaks) и ненужное потребление ресурсов.|
|**Реакция на множественные сигналы**|Дает возможность горутине отслеживать не только свой рабочий канал, но и несколько потенциальных сигналов завершения, реагируя на тот, который сработает первым.|
|**Гибкость**|Может быть использован для создания канала, который закрывается, как только любой из нескольких входных каналов _завершится_ (поэтому "or-done").|


### Возможные нюансы использования

1. **Утечки горутин:** Основная цель паттерна — предотвратить утечки, но неправильная его реализация (например, забыть о `defer close(out)` или не проверить канал `done` в цикле `select`) сама может привести к утечке горутины-обработчика паттерна.
    
2. **Арбитражность `select`:** Если одновременно доступны и рабочий канал (`c`), и канал завершения (`done`), оператор `select` **произвольно** выберет один из них. В большинстве случаев это не критично, поскольку канал `done` обычно _закрывается_ (становится доступным постоянно) и будет выбран очень быстро, что приведет к завершению работы.
    
3. **Использование пустого `struct{}`:** Каналы `done` часто имеют тип `chan struct{}`, так как важен сам факт закрытия/приема сигнала, а не пересылаемое значение. Использование пустого `struct{}` минимизирует накладные расходы на память.





```go
func OrDone[T any](src <-chan T, done <-chan struct{}) <-chan T {
	out := make(chan T)

	go func() {
		defer close(out)
		for {
			select {
				//контроль на Done при чтении с входного канала
				case <-done:
				    return
				case v, ok := <-src:
				    if !ok {
					    return
				    }

				    select {
					    // контроль на Done записи в выходной канал
					    case <-done:
						    return
					    case out <- v:
					}
			}
		}
	}()
 return out
}

```






Паттерн предназначен для замены конструкции вида:
```go 
for{
	select {
		case value, ok := <- inoutCh:
			if  !ok {
				return
			}
			//processing
		case <-doneCh:
			return
	}
}
```
на более лаконичную кострукцию:
```go
for value := range OrDone(inputCh, done) {
	//processing
}
```

### Пример
```go 
package main  
  
import (  
    "fmt"  
    "time")  
  
func OrDone[T any](inputCh chan T, done chan struct{}) <-chan T {  
    outputCh := make(chan T)  
  
    go func() {  
       defer close(outputCh)  
  
       for {  
          select {  
          case <-done:  
             return  
          default:  
          }  
  
          select {  
          case value, opened := <-inputCh:  
             if !opened {  
                return  
             }  
             outputCh <- value  
          case <-done:  
             return  
          }  
       }  
    }()  
    return outputCh  
}  
  
func main() {  
    ch := make(chan string)  
  
    //горутинка для наполнения канала значениями  
    go func() {  
       for {  
          ch <- "test"  
          time.Sleep(200 * time.Millisecond)  
       }  
    }()  
  
    //закрытие канала done для остановки работы  
    done := make(chan struct{})  
    go func() {  
       time.Sleep(1 * time.Second)  
       close(done)  
    }()  
  
    for value := range OrDone(ch, done) {  
       fmt.Println(value)  
    }  
}
```

 