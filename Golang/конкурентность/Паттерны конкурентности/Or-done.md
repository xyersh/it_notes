### Идея паттерна "Or-Done"
Паттерн **Or-Done** (или **Or-Channel**) — это один из ключевых шаблонов конкурентного программирования в **Go**, используемый для **управления отменой (cancellation)** и **завершением** работы нескольких горутин или конвейера (pipeline) при получении сигнала от одного из каналов.

Как только любой из входных каналов `done` будет закрыт или получит значение, "объединенный" канал также закроется (или получит значение, в зависимости от реализации), сигнализируя всем ожидающим горутинам, что пора прекращать работу.

### Преимущества использования

|**Преимущество**|**Описание**|
|---|---|
|**Управление отменой**|Позволяет изящно остановить цепочку горутин или конвейер обработки данных, предотвращая утечки горутин (goroutine leaks) и ненужное потребление ресурсов.|
|**Реакция на множественные сигналы**|Дает возможность горутине отслеживать не только свой рабочий канал, но и несколько потенциальных сигналов завершения, реагируя на тот, который сработает первым.|
|**Гибкость**|Может быть использован для создания канала, который закрывается, как только любой из нескольких входных каналов _завершится_ (поэтому "or-done").|


### Возможные нюансы использования

1. **Утечки горутин:** Основная цель паттерна — предотвратить утечки, но неправильная его реализация (например, забыть о `defer close(out)` или не проверить канал `done` в цикле `select`) сама может привести к утечке горутины-обработчика паттерна.
    
2. **Арбитражность `select`:** Если одновременно доступны и рабочий канал (`c`), и канал завершения (`done`), оператор `select` **произвольно** выберет один из них. В большинстве случаев это не критично, поскольку канал `done` обычно _закрывается_ (становится доступным постоянно) и будет выбран очень быстро, что приведет к завершению работы.
    
3. **Использование пустого `struct{}`:** Каналы `done` часто имеют тип `chan struct{}`, так как важен сам факт закрытия/приема сигнала, а не пересылаемое значение. Использование пустого `struct{}` минимизирует накладные расходы на память.



### Примеры

#### С применением рекурсии

```go
func OrDoneRecursive(channels ...<-chan struct{}) <-chan struct{}{
    switch len(channels){
    case 0:
        return nil
    case 1:
        return channels[0]
    case 2:
        orDoneChan := make(chan struct{})

        go func(){
            defer close(orDoneChan)
            select {
            case <-channels[0]:
            case <-channels[1]:
            }

        }()
        return orDoneChan
        default:
            mid := len(channels)
            return OrDone(OrDone(channels[:mid]...), OrDone(channels[mid:]...))
    }
}
```

#### Итеративный подход

```go
func OrDoneSafe(channels ...<-chan struct{}) <-chan struct{} {
    out := make(chan struct{})

    // goOnce — это канал, который будет использоваться для сигнализации о том,
    // что ПЕРВЫЙ канал закрыт. Он нужен, чтобы избежать множественного закрытия 'out'.
    goOnce := make(chan struct{})

    for _, ch := range channels{
        ch := ch // Создание локальной копии в цикле
        go func(){
            select {
            case <-ch:
                // Сигнализируем, что один из каналов сработал
                // Попытка отправить в закрытый канал будет проигнорирована.
                // Это предотвращает множественное закрытие 'out'.
                defer func() {
                    // Используем recover на случай паники при close(goOnce)
                    // (хотя в данном случае это не строго необходимо, но хорошая практика)
                    if r := recover(); r != nil && r != "close of closed channel" {
                        panic(r)
                    }
                }()
                close(goOnce)
            case <-goOnce:
                // Если кто-то другой уже закрыл goOnce, просто выходим
                return
            }
        }()
    }

    // 2. Закрыватель: Одна горутина ждет первого сигнала и закрывает выходной канал
    go func() {
        defer close(out)
        <-goOnce
    }()
    return out
}
```


#### С применением рефлексии

```go
import "reflect"

// OrDoneReflect объединяет несколько каналов struct{} в один выходной канал.
// Выходной канал закрывается, как только закрывается любой из входных каналов.
// Использует reflect.Select для нерекурсивной реализации.
func OrDoneReflect(dones ...<-chan struct{}) <-chan struct{} {
	if len(dones) == 0 {
		// Специальный случай: сразу возвращаем закрытый канал
		closed := make(chan struct{})
		close(closed)
		return closed
	}

	out := make(chan struct{})

	// Создаем массив reflect.SelectCase
	cases := make([]reflect.SelectCase, len(dones))
	for i, d := range dones {
		cases[i] = reflect.SelectCase{
			Dir:  reflect.SelectRecv,
			Chan: reflect.ValueOf(d),
		}
	}

	go func() {
		defer close(out)
		
		// Блокирующий вызов select с использованием отражения
		// Он ждет, пока один из каналов не будет готов к приему (т.е., закрыт).
		// Возвращает индекс сработавшего канала и значение (которое будет невалидным/nil, т.к. канал пустой)
		reflect.Select(cases) 
		
		// Как только любой канал срабатывает, горутина завершается и закрывает out.
	}()

	return out
}
```


 #### Сравнительная характеристика вариантов Or-Done

Три основных подхода к реализации Or-Done:
1. **Рекурсивный Бинарный** (`OrDoneRecursive`).
2. **Итеративный с Координацией** (`OrDoneSafe`).
3. **Итеративный с `reflect`** (`OrDoneReflect`).
    

| **Характеристика**           | **1. Рекурсивный (Бинарный)**                  | **2. Итеративный (с Координацией)**                            | **3. Итеративный (с reflect)**                             |
| ---------------------------- | ---------------------------------------------- | -------------------------------------------------------------- | ---------------------------------------------------------- |
| **Количество горутин**       | $O(N)$ ($\approx N-1$)                         | **$O(N+1)$** (N слушателей + 1 закрыватель)                    | **1** (независимо от $N$)                                  |
| **Структура слияния**        | $O(\log N)$ уровней (иерархическая)            | **Плоская** (все слушают параллельно)                          | **Плоская** (одна горутина слушает всех)                   |
| **Задержка (Latency)**       | **$O(\log N)$** (сигнал проходит через уровни) | **Минимальная** (сигнал проходит через 2 горутины)             | **Минимальная** (один нативный `select`)                   |
| **Производительность**       | **Высокая** (нативные каналы)                  | **Высокая** (нативные каналы)                                  | **Низкая** (накладные расходы `reflect`)                   |
| **Сложность / Безопасность** | Средняя. Чистый, идиоматичный код Go.          | Высокая. Требует **координационного канала** для безопасности. | Высокая. Требует **импорта `reflect`**, менее идиоматично. |
|                              |                                                |                                                                |                                                            |

## Резюме: Выбор для продакшена

|**Сценарий**|**Рекомендованный Вариант**|**Причина**|
|---|---|---|
|**Общий случай (умеренный $N$)**|**Рекурсивный Бинарный**|Лучший баланс между простотой, производительностью и идиоматичностью Go.|
|**Критически низкая задержка**|**Итеративный с Координацией**|Минимальное время отклика, несмотря на большее количество горутин.|
|**Ограниченная память / Огромный $N$**|**Итеративный с `reflect`**|Когда необходимо гарантировать только **одну** дополнительную горутину, несмотря на снижение производительности.|