Для гошки паттерн не актуален.

Принцип работы **async/await** основан на использовании асинхронных функций и позволяет писать асинхронный код так, будто он синхронный. Это делает его более читаемым и легким для отладки.

### Как это работает

- **async**-функция: помечает функцию как асинхронную. Такая функция всегда возвращает **Promise**.
    
- **await**: используется внутри **async**-функции, чтобы "дождаться" выполнения **Promise**. `await` приостанавливает выполнение функции до тех пор, пока `Promise` не будет выполнен или отклонен. При этом он не блокирует главный поток выполнения, позволяя другим операциям работать в фоновом режиме.


Привет из мира JS )))
```go
package main
  
import "fmt"

func Async(fn func() any) <-chan any {
    ch := make(chan any, 1)
    go func() {
        ch <- fn()
    }()
  
    return ch
}

  

func Await(ch <-chan any) any {
    return <-ch
}

  

func main() {

    // АСИНХРОННЫЙ ВЫЗОВ ФУНКЦИИ ЧЕРЕЗ Async
    fn := Async(func() any {
        return "Hello, Result!!!"
    })

    fmt.Print(`
    .
    Some another important work
    .
    `)

    // ПОЛУЧЕНИЕ РЕЗУЛЬТАТА ОТ АСИНХРОННОГО ВЫЗОВА
    res := Await(fn)
    fmt.Printf("result: %s\n", res)
}
```