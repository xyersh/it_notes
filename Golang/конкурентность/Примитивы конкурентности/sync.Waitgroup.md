**sync.WaitGroup** – это встроенный в Go механизм синхронизации, который позволяет ожидать завершения нескольких горутин перед продолжением выполнения основной программы. Он особенно полезен в сценариях, где необходимо запустить несколько асинхронных задач и убедиться, что все они завершились успешно перед переходом к следующему этапу.

### **Структура и основные методы:**

- **Zero value:** При создании WaitGroup автоматически инициализируется нулевым значением, что означает, что нет ожидающих горутин.
- **Add(delta int):** Увеличивает внутренний счетчик на значение delta. Обычно вызывается перед запуском новой горутины, чтобы указать, что нужно дождаться ее завершения.
- **Done():** Уменьшает внутренний счетчик на 1. Вызывается в каждой горутине после завершения ее работы.
- **Wait():** Блокирует текущую горутину до тех пор, пока внутренний счетчик не станет равен нулю, то есть пока все ожидающие горутины не завершат свою работу.
- **Go(func())** - метод был добавлен для упрощения запуска горутин с использованием WaitGroup. Фактически, он является заменой совместного использования функций `Add()` и `Done()`
### **Область применения:**

- **Параллельные вычисления:** Когда нужно запустить несколько вычислений параллельно и дождаться результатов всех вычислений.
- **Асинхронные операции ввода-вывода:** При выполнении нескольких операций ввода-вывода одновременно и ожидании их завершения.
- **Тестирование:** Для синхронизации различных частей теста.

### **Основные тезисы использования:**

- **Инициализация:** Создается экземпляр WaitGroup в начале программы.
- **Увеличение счетчика:** Перед запуском каждой новой горутины вызывается метод Add, чтобы увеличить счетчик ожидающих горутин.
- **Уменьшение счетчика:** Внутри каждой горутины после завершения работы вызывается метод Done, чтобы уменьшить счетчик.
- **Ожидание завершения:** В основной горутине вызывается метод Wait для ожидания завершения всех горутин.

### **Пример использования:**

#### Применение Add() и  Done()
```go
package main

import (
    "fmt"
    "sync"
    "time"
)

  

func worker(id int, wg *sync.WaitGroup) {
    defer wg.Done() // Уменьшаем счетчик задач при завершении горутины
    fmt.Printf("Worker %d starting\n", id)

    // Симулируем работу
    time.Sleep(time.Second)
    fmt.Printf("Worker %d done\n", id)
}

  

func main() {
    var wg sync.WaitGroup

    // Добавляем 3 задачи в группу
    numWorkers := 3
    wg.Add(numWorkers)

    for i := 1; i <= numWorkers; i++ {
        go worker(i, &wg) // Запускаем горутины
    }

    wg.Wait() // Ожидаем завершения всех горутин
    fmt.Println("All workers finished")
}
```


#### Применение Go()
```go
package main

import (
	"fmt"
	"sync"
	"time"
)

func worker(id int) {
	fmt.Printf("Воркер %d начинает работу\n", id)
	time.Sleep(time.Second) // Имитация работы
	fmt.Printf("Воркер %d закончил работу\n", id)
}

func main() {
	var wg sync.WaitGroup

	fmt.Println("Начало работы с wg.Go")

	// ⭐️ Новый подход с использованием wg.Go(f func())
	for i := 1; i <= 3; i++ {
		// wg.Go() автоматически вызывает wg.Add(1) и defer wg.Done()
		wg.Go(func() {
			worker(i) // Запускаем воркер (захват переменной i)
		})
	}

	wg.Wait()
	fmt.Println("Все воркеры завершены (новый подход)")
}

/*
Вывод (порядок и значения i могут отличаться из-за захвата переменной):
Начало работы с wg.Go
Воркер 4 начинает работу (ОШИБКА: захват переменной)
Воркер 4 начинает работу
Воркер 4 начинает работу
...
Воркер 4 закончил работу
Воркер 4 закончил работу
Воркер 4 закончил работу
Все воркеры завершены (новый подход)
*/```