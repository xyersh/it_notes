

В Go обычная `map` **не является потокобезопасной**. Если вы попытаетесь писать в неё из нескольких горутин (goroutines) одновременно без синхронизации, программа аварийно завершится с ошибкой `fatal error: concurrent map writes`.

Стандартное решение — использовать `sync.Mutex` или `sync.RWMutex` для защиты мапы. Однако в стандартной библиотеке (начиная с Go 1.9) существует специализированная структура `sync.Map`, которая в определенных сценариях работает эффективнее.


## Основные методы sync.Map

В отличие от обычной мапы, `sync.Map` работает как структура и не имеет специального синтаксиса (вроде `m[key]`). Все операции проходят через методы, и, что важно, она работает с типом `any` (пустой интерфейс `interface{}`), поэтому мы теряем строгую типизацию при компиляции.

Основные методы:



| Метод                                                   | Описание                                                                                           |
| ------------------------------------------------------- | -------------------------------------------------------------------------------------------------- |
| `Store(key, value any)`                                 | Сохраняет значение в мапу (аналог `m[k] = v`)                                                      |
| `Load(key any) (value any, ok bool)`                    | Получает значение (аналог `v, ok := m[k]`)                                                         |
| `Delete(key any)`                                       | Удаляет значение (аналог `delete(m, k)`)                                                           |
| `LoadOrStore(key, value any) (actual any, loaded bool)` | Атомарно проверяет наличие ключа. Если есть — возвращает существующее, если нет — сохраняет новое. |
| `Range(f func(key, value any) bool)`                    | Перебирает все элементы мапы.                                                                      |


## Когда следует использовать sync.Map?

В документации Go четко сказано, что `sync.Map` оптимизирована для **двух конкретных сценариев**:

### Сценарий А: "Write Once, Read Many" (Кэши)

Когда запись ключа происходит только один раз, но чтение происходит очень часто.

> **Пример:** Кэширование конфигурации, которая загружается при старте и редко меняется, но читается сотнями горутин.

### Сценарий Б: "Disjoint Sets" (Разрозненные ключи)

Когда множество горутин читают, пишут и перезаписывают записи для **разных** ключей.

> **Пример:** Шардированные структуры, где каждая горутина работает со своим уникальным набором ID.

**Почему это быстрее?** `sync.Map` внутри разделена на две части: "read-only" (быстрая, без блокировок) и "dirty" (требует блокировки). В описанных выше сценариях большинство операций попадает в "read-only" путь, избегая дорогих вызовов мьютексов и CPU cache contention (конкуренции за кэш процессора).


## Когда НЕ следует использовать sync.Map?

Для большинства стандартных задач `sync.Map` будет **хуже**, чем `map` + `RWMutex`.
Не используйте её, если:
1. **Вам нужна строгая типизация.** Вам придется постоянно делать приведение типов (`val.(MyType)`), что неудобно и может привести к панике в рантайме, если ошибиться с типом.
2. **Частые перезаписи одних и тех же ключей.** Если вы постоянно обновляете значение одного и того же ключа, `sync.Map` будет работать медленнее из-за внутренней логики переноса данных между "read" и "dirty" хранилищами.
3. **Вам нужно знать длину (`len`).** У `sync.Map` нет метода `Len()`. Чтобы узнать количество элементов, нужно пройтись по всем элементам через `Range`, что очень медленно (O(N)).

## Сравнительная таблица 

| **Характеристика**                   | **Обычная Map + RWMutex** | **sync.Map**                       |
| ------------------------------------ | ------------------------- | ---------------------------------- |
| **Типизация**                        | Строгая (Generic)         | Нет (`any`/`interface{}`)          |
| **Синтаксис**                        | Удобный (`m[k]`)          | Вызовы методов                     |
| **Производительность (Read Heavy)**  | Хорошая                   | **Отличная** (меньше блокировок)   |
| **Производительность (Write Heavy)** | **Хорошая**               | Средняя/Низкая                     |
| **Получение длины**                  | `len(m)` — O(1)           | Только перебором — O(N)            |
| **Инициализация**                    | `make(map[...])`          | Просто объявление `var m sync.Map` |

## пример использования sync.Map

```go
package main

import (
	"fmt"
	"sync"
	"time"
)

// User - простая структура данных
type User struct {
	Name string
	Age  int
}

func main() {
	// 1. Инициализация.
	// Обратите внимание: не нужно использовать make или new,
	// нулевое значение sync.Map готово к использованию.
	var userCache sync.Map

	var wg sync.WaitGroup

	// 2. Симуляция писателей (Writers)
	// Записываем данные в мапу из разных горутин
	writers := 5
	for i := 0; i < writers; i++ {
		wg.Add(1)
		go func(id int) {
			defer wg.Done()
			key := fmt.Sprintf("user_%d", id)
			val := User{Name: fmt.Sprintf("User %d", id), Age: 20 + id}
			
			// Используем Store для записи
			userCache.Store(key, val)
			fmt.Printf("[Write] Записан %s\n", key)
		}(i)
	}

	// Ждем, чтобы часть данных точно записалась перед активным чтением
	// (в реальной жизни это не обязательно, просто для наглядности вывода)
	time.Sleep(100 * time.Millisecond)

	// 3. Симуляция читателей (Readers)
	readers := 5
	for i := 0; i < readers; i++ {
		wg.Add(1)
		go func(id int) {
			defer wg.Done()
			key := fmt.Sprintf("user_%d", id)

			// Используем Load для чтения
			if val, ok := userCache.Load(key); ok {
				// ВАЖНО: val имеет тип any (interface{}),
				// нужно сделать Type Assertion
				user := val.(User) 
				fmt.Printf("[Read ] Прочитан %s: %v\n", key, user)
			} else {
				fmt.Printf("[Read ] Ключ %s не найден\n", key)
			}
		}(i)
	}
	
	// 4. Использование LoadOrStore (Атомарная операция)
	// Пытаемся записать user_0. Если он есть - вернет старого, если нет - запишет нового.
	wg.Add(1)
	go func() {
		defer wg.Done()
		newVal := User{Name: "New Admin", Age: 99}
		actual, loaded := userCache.LoadOrStore("user_0", newVal)
		
		if loaded {
			fmt.Printf("[LoadOrStore] Ключ user_0 уже был. Значение: %v\n", actual)
		} else {
			fmt.Printf("[LoadOrStore] Ключ user_0 создан. Значение: %v\n", actual)
		}
	}()

	wg.Wait()
	fmt.Println("--- Итерация по всем элементам ---")

	// 5. Итерация через Range
	// Функция должна возвращать true, чтобы продолжить перебор,
	// или false, чтобы остановить его.
	userCache.Range(func(key, value any) bool {
		u := value.(User)
		fmt.Printf("Key: %v | Value: %s (%d years)\n", key, u.Name, u.Age)
		return true
	})
}
```

### Ключевые моменты в коде:

1. **Приведение типов:** Обратите внимание на строку `user := val.(User)`. Без этого вы не сможете обратиться к полям `.Name` или `.Age`.
2. **Итерация:** Мы не можем использовать цикл `for k, v := range`. Вместо этого мы передаем анонимную функцию в метод `.Range()`.
3. **Нулевое значение:** `var userCache sync.Map` сразу готова к работе, инициализация не требуется.