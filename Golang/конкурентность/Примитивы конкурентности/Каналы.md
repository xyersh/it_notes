### Теория
**Каналы** в Go представляют собой тип данных, позволяющий горутинам безопасно обмениваться значениями. Они являются одним из ключевых механизмов для достижения параллелизма и конкурентности в Go, следовательно, они полностью потокобезопасны 

Каналы реализуют собой модель **CSP** выражают философию Go  в знаменитой фразе: **"Don't communicate by sharing memory; share memory by communicating"**

#### Внутренняя структура
Каналы в Go реализованы в виде структур:
```go
gotype hchan struct {    
	qcount   uint           // количество элементов в буфере    
	dataqsiz uint           // размер кольцевого буфера      
	buf      unsafe.Pointer // указатель на буфер данных    
	elemsize uint16         // размер одного элемента    
	closed   uint32         // флаг закрытого канала    
	timer    *timer         // таймер для временных каналов    
	elemtype *_type         // тип элемента канала    
	sendx    uint           // индекс для записи в буфер    
	recvx    uint           // индекс для чтения из буфера    
	recvq    waitq          // очередь ожидающих получателей    
	sendq    waitq          // очередь ожидающих отправителей    
	lock     mutex          // мьютекс для синхронизации}
}
// очередь ожидания
gotype waitq struct {    
	first *sudog    
	last  *sudog
}

```

Cам канал в коде Go — это указатель на эту структуру, поэтому каналы можно безопасно копировать и передавать между горутинами без потери функциональности.1




#### Аксиомы каналов

|                       | Чтение                                                                       | Запись                                                                       | Закрытие                       | Использование                |
| :-------------------- | ---------------------------------------------------------------------------- | ---------------------------------------------------------------------------- | ------------------------------ | ---------------------------- |
| nil-канал             | вечная блокировка                                                            | вечная блокировка                                                            | паника: close of nil channel   | Условное отключение          |
| открытый небуф. канал | канал блокируется, пока  в канал не пройдет запись                           | блокируется, пока из  канала не пройдет чтение                               | закрывается                    | Синхронизация                |
| открытый буф. канал   | канал возвращает данные без блокировки, пока буфер не пуст. Иначе блокировка | канал принимает данные без блокировки, пока буфер не полон. Иначе блокировка | закрывается                    | Развязка, производительность |
| Закрытый канал        | возвр. nil-значение                                                          | panic: send on closed channel                                                | panic: close of closed channel | Завершение работы            |
|                       |                                                                              |                                                                              |                                |                              |

#### Виды каналов по различным признакам

##### По наличию буфера

- **Небуферизированный канал:** 
	Небуферизованные каналы (`make(chan T)`) реализуют **синхронную передачу данных**. Отправитель блокируется до тех пор, пока получатель не будет готов принять данные, и наоборот. Это создает точку синхронизации между горутинами — операция завершается только тогда, когда обе стороны готовы к обмену данными.
	Отправка значения в такой канал блокирует отправителя до тех пор, пока не найдется горутина, готовая принять это значение. То же самое касается получения значения из канала: получатель будет блокироваться до тех пор, пока в канал не будет отправлено значение.
	Небуферизованные каналы имеют минимальные накладные расходы по памяти, но обеспечивают сильные гарантии синхронизации. Они идеальны для сценариев, где важна точная координация между горутинами.



- **Буферизированный канал:** 
Буферизованные каналы (`make(chan T, size)`) позволяют **асинхронную передачу данных**. Отправитель может поместить данные в буфер и продолжить выполнение, не ожидая получателя, пока буфер не заполнится полностью. 
Выбор размера буфера также важен для производительности:
- **Маленькие буферы (1-10)**: обеспечивают баланс между производительностью и потреблением памяти
- **Средние буферы (10-100)**: подходят для большинства производственных задач
- **Большие буферы (100+)**: максимизируют производительность, но требуют значительной памяти

- Имеет ограниченный внутренний буфер. Отправитель может отправить значение в канал без блокировки, даже если в данный момент нет готового получателя, пока буфер не заполнится. Получатель может получить значение из канала, даже если в данный момент нет готового отправителя, пока в буфере есть значения.

##### По статусу каналов
 **Nil каналы** Являются мощным инструментом для условной логики. Операции с nil каналом блокируются навсегда, что может показаться бесполезным, но на самом деле это отличный инструмент для **conditional logic** в `select`statements:
```go
govar ch chan int // nil канал
select {
		case ch <- 42:    // эта ветка никогда не выполнится    
			// код не выполнится
		case <-time.After(1*time.Second):    // выполнится через секунду
		}
```
Nil каналы позволяют динамически включать и отключать ветки в `select`, что критично важно для реализации некоторых паттернов, таких как graceful shutdown или conditional merging.

##### Закрытые каналы

Закрытие канала (`close(ch)`) сигнализирует о том, что больше никаких данных передаваться не будет. Это механизм для координации завершения работы:
- Попытка отправить данные в закрытый канал вызывает панику
- Получение из закрытого канала возвращает нулевое значение типа и `false` в качестве второго параметра
- Закрытый канал можно использовать для уведомления произвольного количества горутин
- 
#### Инициализация каналов
```go
// Создание nil-канала
var ch chan int

// Создание небуферизированного канала для передачи целых чисел
ch := make(chan int)

// Создание буферизированного канала для передачи строк с емкостью 10
ch := make(chan string, 10)
```



#### Работа с каналами
- **Отправка значения:**
    ```go
    ch <- value
    ```

- **Получение значения:**
    ```go    
    value <- ch
    ```
    
- **Закрытие канала:**
    ```go
    close(ch)
    ```
	- После закрытия канала нельзя отправлять в него новые значения, иначе - паника!!!!
	- Чтение из закрытого канала является неблокирующим. Сначала возвращаются данные из буфера канала (если таковой имеется). Если буфер исчерпан - возвращаются zero-значения.

- **Сделать канал ниловым**
```go
ch := make(chan int)
ch = nil
```


#### Использование nil-каналов
Nil-канал в Go (канал со значением `nil`) является полезным инструментом для управления горутинами и логикой в `select` стейтментах. Основное его предназначение — **блокировка операций чтения и записи**.

Когда канал равен `nil`, любая попытка отправить в него данные, получить из него данные или закрыть его приведет к **вечной блокировке** горутины. Это свойство делает его идеальным для временного "отключения" одного из `case` в `select`.


При слиянии нескольких каналов в один, когда один из входных каналов закрывается, его можно установить в `nil`, чтобы `select` больше не пытался из него читать и не вызывал панику при чтении из закрытого канала.

```go
func merge(ch1, ch2 <-chan int) <-chan int {
	out := make(chan int)
	go func() {
		defer close(out)
		for ch1 != nil || ch2 != nil {
			select {
			case val, ok := <-ch1:
				if !ok {
					ch1 = nil // Канал закрыт, отключаем его
					continue
				}
				out <- val
			case val, ok := <-ch2:
				if !ok {
					ch2 = nil // Канал закрыт, отключаем его
					continue
				}
				out <- val
			}
		}
	}()
	return out
}
```

Здесь, как только чтение из канала `ch1` или `ch2` показывает, что он закрыт (`ok == false`), соответствующая переменная канала устанавливается в `nil`. В следующих итерациях цикла `select` будет игнорировать этот `case`. Цикл завершится, когда оба канала станут `nil`.


### Примеры использования каналов
#### Каналы как мьютексы

```go
func ChanAsMutex(){
	var counter := 0
	mutexChan := make(chan strunc{}, 1)
	wg := sync.WaitGroup()
	for i := 0; i < 1000; i++ {
		wg.Add(1)
		go func(){
			defer wg.Done()
			mutexChan <- strunc{}{} //ставим блокировку
			counter++
			<-mutesChan //снимаем группировку
		}()
	}
	wg.Wait()
	fmt.Println(counter)
}
```

#### Каналы как промисы
```go
func makeRequest(num int) <-chan string {
	responseChan := make(chan string)

	go func() {
		time.Sleep(time.Second)
		responseChan <- fmt.Sprintf("response number %d", num)
	}()
	return responseChan
}

func chanAsPromise() {
	firstResponseChan := makeRequest(1)
	secondResponseChan := makeRequest(2)
	// do something else
	fmt.Println("non blocking")

	fmt.Println(<-firstResponseChan, <-secondResponseChan)
}
```

