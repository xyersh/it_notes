**Атомики** — это низкоуровневые примитивы синхронизации, которые позволяют производить операции чтения, записи и 
модификации на переменных (обычно целых числах или указателях) атомарно, то есть без прерываний другими потоками. 
В Go атомики реализуются через пакет sync/atomic.

#### Поддерживаемые типы для атомарных операций: 
	- `int32`
	- `int64`
	- `uint32`
	- `uint64`
	- `uintptr`
	- `unsafe.Pointer`



#### Перечень функций(где T - любой поддерживаемый тип):
- `LoadT(addr *T) (val T)` - атомарное возвращение значения из пепеменной
- `StoreT(addr *T, val T)` - атомарное сохранение  значения `val` в переменной `*addr`
- `AddT(old_addr *T, delta T) (new_val T)` - атомарное добавление значение к переменной, возвращает новое значение
- `CompareAndSwapT(addr *T, old T, new T) (swapped bool)` - атомарно сравнивает значение переменной `*addr` с ожидаемым значением `old` и, если они равны, заменяет его на новое значение `new`. возвращает статус замены`swapped`: `true` - замена произошла, `false` - замена не произошла. Данная функция часто применяется , когда необходимо реализовать поведение "одиночки"(что бы какой-то блок выполнялся лишь один раз).
- `SwapT(addr *T, new T)(old T)` - атомарно заменяет значение переменной `*addr` на новое `new` и возвращает старое значение `old`.
Эти функции используют низкоуровневую поддержку процессоров, обеспечивая высокую производительность.

#### Преимущества атомиков
1.  **Высокая производительность:**

    Операции атомиков реализуются на уровне процессора и часто быстрее мьютексов, так как они избегают контекстных переключений и блокировок потоков.
    Особенно полезно для простых операций, таких как инкременты или проверки.

2. **Минимизация блокировок:**

    Атомики не требуют захвата блокировки, что снижает вероятность взаимных блокировок (deadlock).

3. **Легкость в использовании:**

    Для некоторых задач (например, подсчёт счётчиков) атомики обеспечивают простой и эффективный способ синхронизации.



Примеры:
-  **Add:**
```go
package main

import (
	"fmt"
	"sync"
	"sync/atomic"
)

func main() {
	var counter int64 // переменная, к которой нужен безопасный доступ
	var wg sync.WaitGroup

	increment := func() {
		defer wg.Done()
		for i := 0; i < 1000; i++ {
			atomic.AddInt64(&counter, 1) // атомарное увеличение
		}
	}

	// Запускаем несколько горутин
	wg.Add(3)
	go increment()
	go increment()
	go increment()

	wg.Wait()
	fmt.Printf("Итоговое значение счётчика: %d\n", counter) // Ожидается 3000
}
```


- **CAS:**
```go
package main

import (
	"fmt"
	"sync"
	"sync/atomic"
)

func main() {
	var value int32 = 42
	var wg sync.WaitGroup

	updateValue := func(expected, newValue int32) {
		defer wg.Done()
		for {
			// Попытка обновить значение
			if atomic.CompareAndSwapInt32(&value, expected, newValue) {
				fmt.Printf("Успешно обновлено: %d -> %d\n", expected, newValue)
				break
			} else {
				fmt.Printf("Неудача, текущее значение: %d\n", value)
				break
			}
		}
	}

	wg.Add(2)
	go updateValue(42, 100) // Первая горутина
	go updateValue(42, 200) // Вторая горутина

	wg.Wait()
	fmt.Printf("Итоговое значение: %d\n", value)
}
```

### atomic.Value

**atomic.Value** в Go — это структура, предназначенная для безопасного хранения и обновления значений в конкурентной среде (т.е. при работе с горутинами). Она предоставляет атомарные операции для хранения и загрузки значений, что позволяет избежать гонок данных (data races) без использования мьютексов.
#### Основные особенности `atomic.Value`:

1. **Атомарность**: Операции с `atomic.Value` гарантируют, что чтение и запись значения будут выполняться атомарно, даже в многопоточной среде.
    
2. **Типизация**: `atomic.Value` может хранить значения любого типа, но тип значения должен быть одинаковым для всех операций. Если попытаться сохранить значение другого типа, это приведет к панике.
    
3. **Простота использования**: В отличие от низкоуровневых атомарных операций (например, `atomic.AddInt32`), `atomic.Value` работает с любыми типами данных.

### Основные методы:

- `Store(value interface{})`: Атомарно сохраняет значение.
    
- `Load() interface{}`: Атомарно загружает значение.
    
- `Swap(new interface{}) (old interface{})`: Атомарно заменяет значение на новое и возвращает старое (добавлено в Go 1.17).
    
- `CompareAndSwap(old, new interface{}) bool`: Атомарно заменяет значение на новое, если текущее значение равно `old` (добавлено в Go 1.17).

#### Пример использования atomik.Value
````go
package main

import (
	"fmt"
	"sync"
	"sync/atomic"
)

func main() {
	var config atomic.Value

	// Инициализация начального значения
	config.Store(map[string]string{
		"host": "localhost",
		"port": "8080",
	})

	// Горутина для обновления конфигурации
	var wg sync.WaitGroup
	wg.Add(1)
	go func() {
		defer wg.Done()
		// Обновляем конфигурацию
		config.Store(map[string]string{
			"host": "example.com",
			"port": "80",
		})
	}()

	// Горутина для чтения конфигурации
	wg.Add(1)
	go func() {
		defer wg.Done()
		// Читаем конфигурацию
		cfg := config.Load().(map[string]string)
		fmt.Println("Config:", cfg)
	}()

	wg.Wait()
}
```
