**Sync.Cond** и **sync.Mutex** — это два важных инструмента в Go для синхронизации конкурентных операций. Хотя они оба используются для предотвращения гонок данных, у них есть существенные различия в своей функциональности и областях применения.

### Sync.Mutex: Простой замок

- **Функциональность:** Mutex обеспечивает взаимное исключение: только одна горутина может владеть мьютексом в данный момент. Другие горутины, пытающиеся захватить мьютекс, будут блокироваться до тех пор, пока он не будет освобожден.
- **Использование:** Основное применение — защита критических секций кода, где доступ к общим ресурсам должен быть строго ограничен одной горутиной.
- **Простой механизм:** Мьютекс предоставляет только две операции: Lock и Unlock.

### Sync.Cond: Условное ожидание

- **Функциональность:** Cond объединяет в себе функциональность мьютекса и механизм сигнализации. Он позволяет горутинам ждать выполнения определенного условия, связанного с общим ресурсом, защищаемым мьютексом.
- **Использование:** Используется в ситуациях, когда горутина должна ждать, пока не произойдет какое-то событие или не изменится состояние общего ресурса.
- **Более сложный механизм:** Cond предоставляет методы для ожидания (Wait), сигнализации (Signal) и широкой сигнализации (Broadcast).

### Когда использовать что?

- **Sync.Mutex:**
    - Защита критических секций.
    - Предотвращение гонок данных.
    - Синхронизация доступа к общим ресурсам.
- **Sync.Cond:**
    - Ожидание выполнения условий.
    - Производитель-потребительские проблемы.
    - Синхронизация между горутинами, когда одна горутина должна ждать, пока другая изменит состояние.
    
    
#### Пример
```go
package main

import (
        "fmt"
        "sync"
        "time"
)

var data int
var mutex sync.Mutex
var cond = sync.NewCond(&mutex)

func producer() {
        for i := 0; i < 5; i++ {
                mutex.Lock()
                data++
                fmt.Println("Producer:", data)
                cond.Signal()
                mutex.Unlock()
                time.Sleep(time.Second)
        }
}

func consumer() {
        for i := 0; i < 5; i++ {
                mutex.Lock()
                for data == 0 {
                        cond.Wait()
                }
                fmt.Println("Consumer:", data)
                data--
                mutex.Unlock()
        }
}

func main() {
        go producer()
        go consumer()
        time.Sleep(5 * time.Second)
}
```

В этом примере:

- `mutex` используется для защиты переменной `data`.
- `cond` используется для того, чтобы потребитель мог ждать, пока производитель не увеличит значение `data`.


