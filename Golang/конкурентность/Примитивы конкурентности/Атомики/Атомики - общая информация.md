**Атомики** — это низкоуровневые примитивы синхронизации, которые позволяют производить операции чтения, записи и 
модификации на переменных (обычно целых числах или указателях) атомарно, то есть без прерываний другими потоками. 
В Go атомики реализуются через пакет sync/atomic.

#### Преимущества атомиков
1.  **Высокая производительность:**
    Операции атомиков реализуются на уровне процессора и часто быстрее мьютексов, так как они избегают контекстных переключений и блокировок потоков.
    Особенно полезно для простых операций, таких как инкременты или проверки.
2. **Минимизация блокировок:**
    Атомики не требуют захвата блокировки, что снижает вероятность взаимных блокировок (deadlock).
3. **Легкость в использовании:**
    Для некоторых задач (например, подсчёт счётчиков) атомики обеспечивают простой и эффективный способ синхронизации.

### Использование атомиков, старый вариант (До Go 1.19)

#### Поддерживаемые типы для атомарных операций: 
	- `int32`
	- `int64`
	- `uint32`
	- `uint64`
	- `uintptr`
	- `unsafe.Pointer`

#### Перечень функций(где T - любой поддерживаемый тип):

| Функция                                                 | Описание                                                                                                                                                                                                                                                                                                                                                               |
| ------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `LoadT(addr *T) (val T)`                                | атомарное возвращение значения из переменной                                                                                                                                                                                                                                                                                                                           |
| `StoreT(addr *T, val T)`                                | атомарное сохранение  значения `val` в переменной по адресу `*addr`                                                                                                                                                                                                                                                                                                    |
| `AddT(old_addr *T, delta T) (new_val T)`                | атомарное добавление значение к переменной, возвращает новое значение                                                                                                                                                                                                                                                                                                  |
| `CompareAndSwapT(addr *T, old T, new T) (swapped bool)` | атомарно сравнивает значение переменной `*addr` с ожидаемым значением `old` и, если они равны, заменяет его на новое значение `new`. возвращает статус замены`swapped`: `true` - замена произошла, `false` - замена не произошла. Данная функция часто применяется , когда необходимо реализовать поведение "одиночки"(что бы какой-то блок выполнялся лишь один раз). |
| `SwapT(addr *T, new T)(old T)`                          | атомарно заменяет значение переменной `*addr` на новое `new` и возвращает старое значение `old`.                                                                                                                                                                                                                                                                       |
| `OrT(addr *T, mask T) (old T)`                          | Атомарное проведение побитового OR над числом по указателю `addr` с применением маски `mask`                                                                                                                                                                                                                                                                           |
| `AndT(addr *T, mask T) (old T)`                         | Атомарное проведение побитового AND над числом по указателю `addr` с применением маски `mask`                                                                                                                                                                                                                                                                          |
|                                                         |                                                                                                                                                                                                                                                                                                                                                                        |


Эти функции используют низкоуровневую поддержку процессоров, обеспечивая высокую производительность.

#### Примеры:
-  **Атомарный инкремент**
```go
package main

import (
	"fmt"
	"sync"
	"sync/atomic"
)

func main() {
	var counter int64 // переменная, к которой нужен безопасный доступ
	var wg sync.WaitGroup

	increment := func() {
		defer wg.Done()
		for i := 0; i < 1000; i++ {
			atomic.AddInt64(&counter, 1) // атомарное увеличение
		}
	}

	// Запускаем несколько горутин
	wg.Add(3)
	go increment()
	go increment()
	go increment()

	wg.Wait()
	fmt.Printf("Итоговое значение счётчика: %d\n", counter) // Ожидается 3000
}
```


- **CompareAndSwap:**
```go
package main

import (
	"fmt"
	"sync"
	"sync/atomic"
)

func main() {
	var value int32 = 42
	var wg sync.WaitGroup

	updateValue := func(expected, newValue int32) {
		defer wg.Done()
		for {
			// Попытка обновить значение
			if atomic.CompareAndSwapInt32(&value, expected, newValue) {
				fmt.Printf("Успешно обновлено: %d -> %d\n", expected, newValue)
				break
			} else {
				fmt.Printf("Неудача, текущее значение: %d\n", value)
				break
			}
		}
	}

	wg.Add(2)
	go updateValue(42, 100) // Первая горутина
	go updateValue(42, 200) // Вторая горутина

	wg.Wait()
	fmt.Printf("Итоговое значение: %d\n", value)
}
```



### Использование атомиков, новый вариант (с версии Go 1.19)
#### atomic.Value

**atomic.Value** в Go — это структура, предназначенная для безопасного хранения и обновления значений в конкурентной среде (т.е. при работе с горутинами). Она предоставляет атомарные операции для хранения и загрузки значений, что позволяет избежать гонок данных (data races) без использования мьютексов.
##### Основные особенности `atomic.Value`:
1. **Атомарность**: Операции с `atomic.Value` гарантируют, что чтение и запись значения будут выполняться атомарно, даже в многопоточной среде.
2. **Типизация**: `atomic.Value` может хранить значения любого типа, но тип значения должен быть одинаковым для всех операций. Если в дальнейшем попытаться сохранить значение другого типа, это приведет к панике.
3. **Простота использования**: В отличие от низкоуровневых атомарных операций (например, `atomic.AddInt32`), `atomic.Value` работает с любыми типами данных.

##### Основные методы:

| Метод                                         | Описание                                                                                      |
| --------------------------------------------- | --------------------------------------------------------------------------------------------- |
| `(v *Value)Store(value any)`                  | Атомарно сохраняет значение в atomic.Value                                                    |
| `(v *Value)Load() any`                        | Атомарно загружает значение из atomic.Value                                                   |
| `(v *Value)Swap(new any) (old any)`           | Атомарно заменяет значение на новое и возвращает старое (добавлено в Go 1.17).                |
| `(v *Value)CompareAndSwap(old, new any) bool` | Атомарно заменяет значение на новое, если текущее значение равно `old` (добавлено в Go 1.17). |
##### Пример использования atomic.Value
``` go
package main

import (
	"fmt"
	"sync"
	"sync/atomic"
)

func main() {
	var config atomic.Value

	// Инициализация начального значения
	config.Store(map[string]string{
		"host": "localhost",
		"port": "8080",
	})

	// Горутина для обновления конфигурации
	var wg sync.WaitGroup
	wg.Add(1)
	go func() {
		defer wg.Done()
		// Обновляем конфигурацию
		config.Store(map[string]string{
			"host": "example.com",
			"port": "80",
		})
	}()

	// Горутина для чтения конфигурации
	wg.Add(1)
	go func() {
		defer wg.Done()
		// Читаем конфигурацию
		cfg := config.Load().(map[string]string)
		fmt.Println("Config:", cfg)
	}()

	wg.Wait()
}
```


#### atomic типы
В Go 1.19 появились удобные обертки: `atomic.Int64`, `atomic.Bool`, `atomic.Pointer[T]` и другие. Это делает код чище и безопаснее, так как позволяет работать с методами объекта, а не с указателями на `int23`, `int64` и на прочие типы.

##### Методы атомарных типов
Легенда:
- `*atomic` - тип ресивера атомарной структуры
- `T` - соответствующий примитивный тип

| Метод                                               | Назначение                                                             | Примечание                      |
| --------------------------------------------------- | ---------------------------------------------------------------------- | ------------------------------- |
| `(*atomic)Add(delta T)(new T)`                      | Атомарное добавление                                                   | отсутствует у `Bool`, `Pointer` |
| `(*atomic)And(mask T)(old T)`                       | атомарное битовое AND атомарного значения, возвращает старое значение  | отсутствует у `Bool`, `Pointer` |
| `(*atomic)CompareAndSwap(old, new T)(swapped bool)` | Атомарно заменяет значение на новое, если текущее значение равно `old` |                                 |
| `(*atomic)Load() T`                                 | Атомарное получение значения                                           |                                 |
| `(*atomic)Or(mask T)(old bool)`                     | атомарное битовое OR атомарного значения, возвращает старое значение   | отсутствует у `Bool`, `Pointer` |
| `(*atomic)Store(val T)`                             | Атомарное сохранение значения                                          |                                 |
| `(*atomic)Swap(new T)(old)`                         | Атомарно заменяет значение на новое и возвращает старое ое             |                                 |


##### Пример: безопасный счетчик
```go
package main

import (
	"fmt"
	"sync"
	"sync/atomic"
)

func main() {
	// Теперь это не просто int64, а специальный тип
	var counter atomic.Int64 
	var wg sync.WaitGroup

	for i := 0; i < 1000; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			
			// Вызываем метод у переменной.
			// Ошибиться и забыть & невозможно.
			counter.Add(1) 
		}()
	}

	wg.Wait()

	// Читаем через метод Load()
	fmt.Printf("Итоговое значение: %d\n", counter.Load())
}
```

##### "Горячая" замена конфигурации
```go
package main

import (
	"fmt"
	"sync/atomic"
	"time"
)

// ServerConfig — наша конфигурация
type ServerConfig struct {
	Host string
	Port int
}

func main() {
	// Создаем атомарный указатель на ServerConfig
	var config atomic.Pointer[ServerConfig]

	// Инициализируем начальным значением
	config.Store(&ServerConfig{Host: "localhost", Port: 8080})

	// Горутина-читатель (симуляция работы сервера)
	go func() {
		for {
			// Атомарно получаем текущий СЛЕПОК конфигурации
			currentCfg := config.Load()
			fmt.Printf("Обработка запроса на %s:%d\n", currentCfg.Host, currentCfg.Port)
			time.Sleep(500 * time.Millisecond)
		}
	}()

	// Симуляция обновления конфига через 2 секунды
	time.Sleep(2 * time.Second)
	fmt.Println("--- ОБНОВЛЕНИЕ КОНФИГУРАЦИИ ---")
	
	newCfg := &ServerConfig{Host: "production-db", Port: 5432}
	// Атомарно подменяем указатель.
	// Читатели мгновенно начнут видеть новые данные.
	config.Store(newCfg)

	time.Sleep(2 * time.Second)
}
```

##### полиморфное использование atomic.Value
```go 
package main

import (
	"fmt"
	"sync/atomic"
)

// Logger - наш интерфейс
type Logger interface {
	Log(msg string)
}

// ConsoleLogger - первая реализация
type ConsoleLogger struct{}
func (c ConsoleLogger) Log(msg string) { fmt.Println("Console:", msg) }

// JsonLogger - вторая реализация
type JsonLogger struct{}
func (j JsonLogger) Log(msg string) { fmt.Println(`{"msg": "` + msg + `"}`) }

func main() {
	var atomicLogger atomic.Value

	// 1. Инициализируем консольным логгером
	atomicLogger.Store(ConsoleLogger{})

	// Функция-хелпер для использования
	log := func(msg string) {
		// Load возвращает interface{}, приводим к нужному интерфейсу
		logger := atomicLogger.Load().(Logger)
		logger.Log(msg)
	}

	log("Привет!") // Вывод: Console: Привет!

	// 2. Атомарно меняем стратегию логирования на JSON
	atomicLogger.Store(JsonLogger{})

	log("Привет!") // Вывод: {"msg": "Привет!"}
}
```
### ### Рекомендации

-  **Используйте новые типы** (`atomic.Int64`, `atomic.Bool`, `atomic.Pointer`), если ваш проект на Go 1.19 и выше. Это читабельнее и безопаснее.
-  **Используйте атомики для простых счетчиков** или флагов (например, флаг "сервис остановлен").
-  **Используйте `sync.Mutex`**, если вам нужно защитить несколько переменных одновременно или выполнить сложную логику. Атомики защищают только _одну_ переменную за раз.
- **Используйте** `atomic.Value` если нужно поработать с интерфейсами, и добавить полиморфизма в атомарные операции. `atomic.Value` принимает `interface{}`, поэтому он идеально подходит для хранения "чего угодно, что реализует интерфейс".