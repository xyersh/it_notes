
## Готовая реализация паттерна  golang.org/x/sync/singleflight. 

Зависимость добавляется командой:
```bash
go get golang.org/x/sync/singleflight
```

### API

| Сущность/команда                                                                   | Описание                                                                                                                                                                                                                                        |
| ---------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `singleflight.Group`                                                               | Тип объекта, определяющего неймспейс, в рамках которого единицы работы выполняются с учетом подавлением дублирования исполнения                                                                                                                 |
| `(g *Group)Do(key string, fn func() (any, error)) (v any, err error, shared bool)` | Выполнить fn() один раз для каждого переданного ключа и вернуть результаты.  В случае повторного вызова ресурса с тем же ключом, вызывающая сторона ждет, пока не отработает оригинальный вызов `Do()`,  а затем вернет результаты ориг.вызова. |
| `(g *Group)DoChan(key string, fn func() (any, error)) <-chan Result`               | аналогична `Do()`, но возвращает канал, хранящий в себе результаты.                                                                                                                                                                             |
| `(g *Group) Forget(key string)`                                                    | Забыть результаты предыдущего выполнения `Do()`, `DocChan()` по указанному ключу.                                                                                                                                                               |
| `Result`                                                                           | type Result struct {<br>	Val    interface{}<br>	Err    error <br>	Shared bool<br>}                                                                                                                                                              |

Паттерн **SingleFlight** (или **Single Flight**) используется для **предотвращения выполнения дублирующих тяжелых операций** (например, запросов к базе данных, внешним API, вычислений), когда множество горутин одновременно запрашивают один и тот же ресурс или значение по одному и тому же ключу.
Решает проблему **"Громыхающего стада» (Thundering Herd)**

## Цель паттерна

**Гарантировать, что для одного и того же ключа в один момент времени выполняется только одна операция**, а все остальные запросы **ждут её завершения и получают тот же результат**.


## Какие проблемы решает?

1. **Избыточные запросы**  
    Без SingleFlight N горутин могут параллельно выполнять одинаковые дорогие операции (например, кэш-промах → обращение к БД → N одинаковых запросов к БД). Это ведет к:
    - Перегрузке внешних систем
    - Излишнему потреблению ресурсов (CPU, память, сеть)
    - Увеличению задержек
2. **Проблема "thundering herd" (стадного эффекта)**  
    Когда кэш истекает, и множество клиентов одновременно пытаются пересоздать значение — все идут в источник данных. SingleFlight предотвращает это.


## Как работает?

- При первом вызове по ключу `key` запускается функция `fn()`.
- Все последующие вызовы с тем же `key`, пока `fn()` не завершилась, **блокируются и ждут** результат.
- Как только `fn()` завершается, **все ожидающие получают тот же результат**.



## Пример использования 
```go
package main

import (
	"fmt"
	"golang.org/x/sync/singleflight"
	"log"
	"sync"
	"time"
)

var sf singleflight.Group

// Имитация "дорогой" операции (например, запрос к БД)
func fetchDataFromDB(userID string) (string, error) {
	fmt.Printf("Выполняется запрос к БД для userID=%s\n", userID)
	time.Sleep(2 * time.Second) // имитация задержки
	return fmt.Sprintf("Данные пользователя %s", userID), nil
}


// SingleFlight: выполняем операцию только один раз для каждого userID, 
// каждый повторный вызов getUserData() с тем же ключом будет работать мгновенно
func getUserData(userID string) (string, error) {
	result, err, _ := sf.Do(userID, func() (interface{}, error) {
		return fetchDataFromDB(userID)
	})
	return result.(string), err
}

func main() {
	var wg sync.WaitGroup

	userID := "123"

	// Запускаем 5 параллельных запросов на получение данных одного пользователя
	for i := 0; i < 5; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			data, err := getUserData(userID)
			if err != nil {
				log.Printf("Ошибка: %v", err)
				return
			}
			fmt.Printf("Получено: %s\n", data)
		}()
	}

	wg.Wait()
}
```