### База

#### Основные положения
- файлы бенчмарков располагаются в тех же файлах, что и тесты (обычно `_test.go`), и используют пакет `testing`.
- Функции бенчмарков должны начитаться с `Benchmark` и содержать в названии название тестируемой функции.
- Функция бенчмаркинга должна принимать один аргумент типа `*testing.B`. Этот объект `b` предоставляет методы для управления процессом бенчмаркинга.
- **Цикл `b.N`**: Основная логика, которую необходимо измерить, должна быть помещена в цикл `for i := 0; i < b.N; i++`. Go автоматически определяет оптимальное значение `b.N` (количество итераций) для достижения статистически значимого результата в течение заданного времени (по умолчанию 1 секунда).
	```go
	func Benchmark(b *testing.B) {
		for range b.N {
			//код для измерений
		}
	}	
	```
- **Цикл b.Loop()** - новая версия цикла. Во все лучше старой:
	- не дает компилятору делать ненужных оптимизаций
	- автоматически исключает настроечный код и код очистки из таймингов бенча
	- код не может быть случайным образом зависим от количества итераций
	```go
	func Benchmark(b *testing.B) {
		for  b.Loop {
			//код для измерений
		}
	}	
	```
- **Вывод результата**: Go сам соберет и выведет статистику по завершении бенчмарка.
- Чтобы бенчмарк проходил без тестирования, нужно указать маску несуществующего файла в опции `-run`. Например, `-run=^###`

###  benchstat

- утилита используется для сравнения бенчей для новой и старой реализации какой либо функции
- утилита сравнивает 2 файла с данными о бенчах . Пример: `benchstat old.txt new.txt`
- модуль находится по пути golang.org/x/perf/cmd/benchstat@latest


### Команды CLI
- `go test -bench=. -benchmem` - Показывает статистику по выделению памяти. Очень полезно для поиска неэффективного использования памяти. Показывает аллокации.
- `go test -bench=BenchSum` - Запускает бенчмарки, имена которых содержат `BenchSum`.
	- `go test -bench=\bBenchSum` - .... начинаются с `BenchSum`
	- `go test -bench=^BenchSum` - .... начинаются с `BenchSum`
	- `go test -bench=BenchSum\b` - ... заканчиваются на `BenchSum`
	- `go test -bench=BenchSum$` - ... заканчиваются на `BenchSum`
- `go test -bench=. -cpuprofile='cpu.prof'` -получить файл профилирования по CPU (`cpu.prog`)
- `go test -bench=. -memprofile='cpu.prof'` -получить файл профилирования по памяти (`mem.prog`)
- `go test -bench=. -count=5` - Запускает каждый бенчмарк 5 раз. Полезно, чтобы убедиться в стабильности результатов и исключить случайные всплески нагрузки на системе.
	- `go test -bench=. -benchtime=3s` - Запускает каждый бенчмарк в течение как минимум 3 секунд (вместо стандартной ~1 секунды). Полезно для коротких операций, чтобы собрать более точные данные.
- `go test -bench=. -benchtime=100x` - Запускает каждый бенчмарк ровно 100 раз (`b.N` будет равен 100).
### \*testing.B - описалово
предоставляет инструменты для бенчмаркинга. Главное поле в нем — это `N`. Это счетчик, который указывает, сколько раз нужно выполнить тестируемый код. Утилита `go test` сама подбирает значение `N`, чтобы тест выполнялся достаточное время для получения стабильных результатов (обычно около 1 секунды).

- `b.N` - определяет, сколько раз должен выполниться тестируемый код
- `b.ResetTimer()` - брасывает таймер производительности и статистику по выделению памяти. Все, что было выполнено _до_ вызова этого метода, не попадет в итоговый отчет.
- `b.StartTimer()` - запустить таймер
- `b.StopTimer()` - остановить таймер
- `b.ReportAllocs()` - Включает сбор статистики по выделению памяти для данного, конкретного бенчмарка. Это эквивалент запуска `go test` с флагом `-benchmem`, но примененный только к одной функции.
- `b.SetBytes(n int64)` - Устанавливает количество байт, обработанных за одну операцию. Это меняет вывод с `ns/op` (наносекунд на операцию) на `MB/s` (мегабайт в секунду).  Применяется для бенчмаркинга функций, которые обрабатывают потоки данных: хеширование, сжатие, чтение из сети или с диска.
- `b.Run(name string, f func(b *testing.B))` - Создает и запускает суб-бенчмарк. Это позволяет группировать связанные тесты под одним "зонтиком".
- `b.RunParallel(body func(pb *testing.PB))` -  Запускает переданную функцию одновременно в нескольких горутинах (`GOMAXPROCS` по умолчанию) для измерения производительности в конкурентной среде.
- - `b.Log(args ...any)` , `b.Logf(format string, args ...any)`: Логируют информацию, которая будет выведена вместе с результатами бенчмарка.
    
- `b.Fatal(args ...any)` , `b.Fatalf(format string, args ...any)`: Прекращают выполнение бенчмарка с сообщением об ошибке. Используется, когда дальнейшее выполнение бессмысленно (например, не удалось подготовить данные).
    
- `b.Error(args ...any)` , `b.Errorf(format string, args ...any)`: Сообщают об ошибке, но продолжают выполнение бенчмарка.
    
- `b.Skip(args ...any)` / `b.Skipf(format string, args ...any)`: Пропускают выполнение данного бенчмарка. Используется, когда условия для теста не выполнены (например, отсутствует необходимый файл конфигурации).

### b.N vs b.Loop()
Использование нового подхода с примерением `b.Loop()` вносит ряд преимуществ в процесс бенчмаркинга:
- **b.Loop() избавляет от необходимости вручную исключать из бенчмарка тайминги вспомогательного кода и кода очистки**. А значит - нет необходимости добавлять в код `b.ResetTimer()`,  `b.StopTimer()` . Это делает код проще и чище 

	Пример b.N:
```go
func Benchmark(b *testing.B) {
  ... setup ...
  b.ResetTimer() // if setup may be expensive
  for range b.N {
    ... code to measure ...
    ... use sinks or accumulation to prevent dead-code elimination ...
  }
  b.StopTimer() // if cleanup or reporting may be expensive
  ... cleanup ...
  ... report ...
}
```

Пример  b.Loop():
```go
func Benchmark(b *testing.B) {
  ... setup ...
  for range b.Loop() {
    ... code to measure ...
    ... use sinks or accumulation to prevent dead-code elimination ...
  }
  ... cleanup ...
  ... report ...
}
```

- **b.Loop() избавляет нас от ненужных оптимизаций**. Например, без b.Loop() компилятор может посчитать что измеряемая функция не используется и удаляет эту функция из проверяемого кода, что непременно приведет к занижению результатов тайминга.

```go 
func isCond(b byte) bool {
  if b%3 == 1 && b%7 == 2 && b%17 == 11 && b%31 == 9 {
    return true
  }
  return false
}

func BenchmarkIsCondWrong(b *testing.B) {
  for range b.N {
    isCond(201)   // код может быть удален
  }
}
```

### ПРИМЕРЫ

```go 
func FindPrimes(limit int) []int {
	var primeNums []int

	for i := 2; i < limit; i++ {
		isPrime := true

		for j := 2; j <= int(math.Sqrt(float64(i))); j++ {
			if i%j == 0 {
				isPrime = false
				break
			}
		}

		if isPrime {
			primeNums = append(primeNums, i)
		}
	}

	return primeNums
}
```


#### простейший бенчмарк
```go
func BenchmarkFindPrimes(b *testing.B) { for i := 0; i < b.N; i++ { FindPrimes(100) } }
```



####  table-driven бенчмарк
```go
func BenchmarkFindPrimes(b *testing.B) {
	var testcases = []struct {
		input int
	}{
		{input: 50},
		{input: 100},
		{input: 500},
		{input: 1000},
	}

	for _, tc := range testcases {
		b.Run(fmt.Sprintf("input=%d", tc.input), func(b *testing.B) {
			for i := 0; i < b.N; i++ {
				FindPrimes(tc.input)
			}
		})
	}
}
	```