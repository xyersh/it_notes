### Классификация по способу получения профиля
- Статическое / Офлайн-профилирование, через бенчмарки
- Динамическое профилирование, через `net/http/pprof`

| Критерий                | Профилирование через `net/http/pprof`                            | Профилирование через бенчмарки                                                |
| ----------------------- | ---------------------------------------------------------------- | ----------------------------------------------------------------------------- |
| **Когда использовать?** | Для работающих приложений, особенно веб-сервисов.                | Для отдельных функций, алгоритмов, библиотек.                                 |
| **Что анализирует?**    | Поведение всей системы под реальной или синтетической нагрузкой. | Производительность конкретного участка кода в изоляции.                       |
| **Процесс**             | Запустить приложение -> Подать нагрузку -> Подключиться по URL.  | Написать бенчмарк -> Запустить `go test` с флагами -> Открыть локальный файл. |
| **Преимущество**        | Показывает реальную картину взаимодействия компонентов.          | Быстро, удобно для точечной оптимизации и регрессионного тестирования.        |
|                         |                                                                  |                                                                               |

### Классификация по измеряемому ресурсу

##### CPU Profile (Профиль процессора)
- **Что измеряет:** Как часто и как долго каждая функция находится на вершине стека вызовов, то есть активно использует процессорное время.
- **Когда использовать:** Когда приложение **медленно работает**, а системный монитор показывает **высокую загрузку CPU**. Это основной инструмент для поиска "горячих точек" (hotspots) в коде.
- **Сравнительное пояснение:** В отличие от **Block Profile**, который ищет время простоя (ожидания), CPU-профиль ищет время активной работы. Программа может быть медленной из-за интенсивных вычислений (проблема CPU) или из-за ожидания ресурсов (проблема блокировок).

##### Heap Profile (Профиль кучи)
- **Что измеряет:** Какие функции выделяют больше всего памяти в куче (heap), которая не была освобождена сборщиком мусора на момент снятия профиля (`inuse_space`).
- **Когда использовать:** Когда потребление памяти приложением **постоянно растёт** (подозрение на утечку памяти) или когда приложение потребляет **слишком много памяти**.
- **Сравнительное пояснение:** Это профиль-снимок (snapshot) текущего состояния памяти. Его часто сравнивают с профилем `alloc_space`, который показывает общее количество выделенной памяти за всё время работы, даже если она уже была освобождена. Для поиска утечек `inuse_space` (профиль по умолчанию) более полезен.

##### Goroutine Profile (Профиль горутин)
- **Что измеряет:** Показывает стеки вызовов всех активных горутин в приложении на текущий момент.
- **Когда использовать:** Когда есть подозрение на **утечку горутин** (их количество постоянно растёт), или когда нужно понять, чем заняты тысячи горутин в сложной системе.
- **Сравнительное пояснение:** В отличие от **Heap Profile**, который показывает, _что_ занимает память (данные), этот профиль показывает, _кто_ занимает память под свои стеки (горутины). Утечка горутин — это тоже утечка памяти.

##### Block Profile (Профиль блокировок)
- **Что измеряет:** Места в коде, где горутины тратят время на ожидание разблокировки ресурсов. Сюда входит ожидание операций с каналами, системных вызовов (I/O) или таймеров.
- **Когда использовать:** Когда приложение **медленно отвечает на запросы**, но при этом **загрузка CPU низкая**. Это явный признак того, что программа больше ждёт, чем работает.
- **Сравнительное пояснение:** Это антипод **CPU Profile**. Если CPU-профиль показывает, где код _слишком много работает_, то Block-профиль показывает, где он _слишком много ждёт_.

	##### Mutex Profile (Профиль мьютексов)
- **Что измеряет:** Участки кода, где горутины дольше всего ждут освобождения мьютекса. Показывает "борьбу" (contention) за общие ресурсы.
- **Когда использовать:** В многопоточных приложениях, когда есть подозрение, что производительность падает из-за неэффективной синхронизации и горутины мешают друг другу.
- **Сравнительное пояснение:** Это специализированный подвид **Block Profile**, сфокусированный исключительно на блокировках `sync.Mutex`. Если Block-профиль показывает все виды ожиданий, то Mutex-профиль помогает глубже проанализировать именно проблемы с мьютексами.


