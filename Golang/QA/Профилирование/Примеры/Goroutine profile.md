Получение и анализ профиля горутин — ключевой навык для диагностики утечек ресурсов и понимания поведения конкурентных программ в Go.
Профиль горутин — это, по сути, "моментальный снимок" стеков вызовов всех горутин, работающих в приложении в данный момент.

###  Шаг 1: Получение профиля горутин
#### Способ 1: Для работающего веб-сервиса (самый частый)

Это самый простой способ. Достаточно импортировать пакет `net/http/pprof`.

**Пример кода с утечкой горутин:**

Создадим сервер, который на каждый запрос `/leak` запускает горутину, которая блокируется навсегда, тем самым "утекая".

**`main.go`**

```go
package main

import (
	"fmt"
	"log"
	"net/http"
	_ "net/http/pprof" // Импортируем для регистрации обработчиков pprof
	"time"
)

func leakingFunction() {
	// Эта горутина будет ждать вечно, так как никто не отправит данные в канал
	<-time.After(1 * time.Hour)
}

func leakHandler(w http.ResponseWriter, r *http.Request) {
	go leakingFunction() // Запускаем горутину и "забываем" про неё
	fmt.Fprintf(w, "Goroutine leaked!")
}

func main() {
	http.HandleFunc("/leak", leakHandler)
	log.Println("Starting server on :8080")
	log.Println("Pprof is available on http://localhost:8080/debug/pprof/")
	log.Fatal(http.ListenAndServe(":8080", nil))
}
```

**Как собрать профиль:**

1. **Запустите сервер:** `go run main.go`.
    
2. **Создайте утечки:** Откройте несколько вкладок в браузере или используйте `curl` в терминале, чтобы обратиться к `http://localhost:8080/leak`. Каждый запрос создаст новую "зависшую" горутину.
    
    ```bash
    curl http://localhost:8080/leak
    curl http://localhost:8080/leak
    curl http://localhost:8080/leak
    ```
    
3. **Получите профиль:** Теперь вы можете получить профиль прямо по URL.
    
    - **В браузере:** Просто откройте [http://localhost:8080/debug/pprof/goroutine?debug=1](https://www.google.com/search?q=http://localhost:8080/debug/pprof/goroutine%3Fdebug%3D1). Вы увидите текстовое представление всех стеков горутин.
    - **Через `go tool pprof` (рекомендуется):** Это способ для глубокого анализа.
        
        ```bash
        go tool pprof http://localhost:8080/debug/pprof/goroutine
        ```
        

---

### Шаг 2: Анализ профиля с помощью `go tool pprof`

После выполнения последней команды вы попадёте в интерактивную консоль `pprof`. Вот как с ней работать.

#### 1. Визуальный анализ (самый эффективный способ)

Введите команду `web`. Она сгенерирует **пламенный граф (flame graph)** и откроет его в браузере.

```
(pprof) web
```

**Как читать пламенный граф для горутин:**

- **Ширина блока** соответствует количеству горутин, имеющих данный стек вызовов.
- **По оси Y** — глубина стека вызовов (внизу — начало, вверху — текущая функция).
- **Что искать:** Ищите **широкие "плато"** на графе. Это группы горутин, которые "застряли" в одном и том же месте.

В нашем примере вы увидите широкую полосу, соответствующую вызову `time.Sleep` внутри `main.leakingFunction`, что сразу укажет на источник утечки.

#### 2. Текстовый анализ

- **Команда `top`**: Показывает список самых частых стеков горутин.
    
    ```bash
    (pprof) top
    Showing nodes accounting for 4, 66.67% of 6 total
          flat  flat%   sum%        cum   cum%
             3 50.00% 50.00%          3 50.00%  runtime.gopark
             1 16.67% 66.67%          1 16.67%  internal/poll.runtime_pollWait
             0     0% 66.67%          3 50.00%  main.leakingFunction
             0     0% 66.67%          3 50.00%  time.Sleep
    ```
    
    Здесь мы видим, что 3 горутины (столько раз мы вызвали `/leak`) находятся в состоянии `runtime.gopark` (ожидание), и их путь вызова проходит через `main.leakingFunction`.
    
- **Команда `list <имя_функции>`**: Показывает исходный код функции и подсвечивает строки, где горутины были созданы или заблокированы.
    
    ```
    (pprof) list leakingFunction
    Total: 6
    ROUTINE ======================== main.leakingFunction in /path/to/main.go
             0          3 (flat, cum) 50.00% of Total
             .          .     13: func leakingFunction() {
             .          .     14: 	// Эта горутина будет ждать вечно, так как никто не отправит данные в канал
             .          3     15: 	<-time.After(1 * time.Hour)
             .          .     16: }
    ```
    
    `pprof` точно указывает на строку 15 как на место, где "застряли" 3 горутины.
    

---

### Что искать при анализе профиля горутин?

1. **Большое общее количество горутин.** Если ваше приложение в спокойном состоянии имеет тысячи горутин, это может быть признаком проблемы.
    
2. **Большое количество горутин, заблокированных в одном месте.** Это главный признак утечки. Ищите горутины в состоянии `chan receive`, `select`, `time.Sleep`, `syscall.Syscall`.
    
3. **Неожиданные стеки вызовов.** Профиль может показать, что горутины выполняют совсем не ту работу, которую вы ожидали.