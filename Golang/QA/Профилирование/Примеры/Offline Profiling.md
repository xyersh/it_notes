### Профилирование через бенчмарки (Offline Profiling)
##### Шаг 1: Код и бенчмарк для примера
- Создайте файл `fib.go` с функцией, которую мы будем тестировать.
    **`fib.go`**
```go
    package main

// Медленная рекурсивная функция для вычисления чисел Фибоначчи
func Fibonacci(n int) int {
    if n <= 1 {
        return n
    }
    return Fibonacci(n-1) + Fibonacci(n-2)
}
```

- Рядом создайте файл `fib_test.go` с бенчмарком для этой функции.
**`fib_test.go`**
```go
package main

import "testing"

// Имя бенчмарка должно начинаться с Benchmark
func BenchmarkFibonacci(b *testing.B) {
    // b.N - это количество итераций, которое определит сам фреймворк
    for i := 0; i < b.N; i++ {
        Fibonacci(20) // Используем не слишком большое число, чтобы тест не длился вечно
    }
}
```

##### Шаг 2: Сбор профилей с помощью флагов

Теперь, вместо запуска веб-сервера, мы запустим наш тест с специальными флагами, чтобы сгенерировать файлы профилей.

1. **Создание профиля CPU**: Запускаем бенчмарк и указываем флаг `-cpuprofile`, а также имя файла для сохранения (`cpu.out`).
    ```bash
    go test -bench=. -cpuprofile cpu.out
    ```
    После выполнения команды в  директории появится файл `cpu.out`.
    
2. **Создание профиля Памяти**: Аналогично для памяти используется флаг `-memprofile` и файл `mem.out`
    ```bash
    go test -bench=. -memprofile mem.out
    ```
    
    В директории появится файл `mem.out`.
    

##### Шаг 3: Анализ локальных файлов профилей

Теперь для анализа мы передаем утилите `go tool pprof` не URL, а путь к сгенерированному файлу.
1. **Анализ профиля CPU**
    ```bash
    go tool pprof cpu.out
    ```
    
    Вы попадете в ту же самую интерактивную консоль. Введите `top`, чтобы увидеть самые затратные функции, или `web`, чтобы построить визуальный граф. Анализ покажет, что почти все время уходит на рекурсивные вызовы `main.Fibonacci`.
    
2. **Анализ профиля памяти**: Для анализа использования памяти (количества аллокаций) откройте файл профиля памяти.
    ```bash
    go tool pprof mem.out
    ```
    Используйте те же команды (`top`, `list`, `web`) для выявления участков кода, которые выделяют больше всего памяти. В данном случае аллокаций будет немного, так как функция в основном нагружает CPU.