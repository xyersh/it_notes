runtime/pprof
net http/pprof


### База
**Профилирование** — это процесс сбора и анализа данных о работе программы с целью выявления узких мест в производительности. Проще говоря, это способ понять, какие части вашего кода работают медленно или потребляют слишком много ресурсов (например, памяти).

Ключевые задачи, решаемые профилированием:

- **Увеличение скорости работы программы**: нахождение и оптимизация "горячих точек" (hotspots) — функций, которые потребляют больше всего процессорного времени.
- **Уменьшение потребления памяти**: обнаружение и устранение утечек памяти или неэффективного использования памяти.
- **Анализ параллелизма**: выявление проблем с блокировками и состязаниями (contention) в многопоточных приложениях.
####  Инструментарий Go: пакет `pprof`

В Go встроен мощный инструмент для профилирования под названием `pprof`. Он состоит из двух частей:

1. **Пакет `runtime/pprof` и `net/http/pprof`**: Встраиваются в ваш код для сбора данных о производительности (профилей) во время работы приложения. `net/http/pprof` делает это особенно просто для веб-сервисов.
    
2. **Утилита `go tool pprof`**: Консольная утилита для анализа собранных профилей. Она позволяет просматривать данные в текстовом виде, а также генерировать наглядные визуализации, такие как графы вызовов и пламенные графы (flame graphs).

#### Виды профилей в `pprof`

- **CPU Profile**: Показывает, какие функции тратят больше всего процессорного времени.
- **Heap Profile**: Показывает, какие участки кода выделяют больше всего памяти в "куче" (heap).
- **Goroutine Profile**: Показывает стеки вызовов всех активных горутин в программе.
- **Block Profile**: Показывает места, где горутины блокируются в ожидании (например, при операциях ввода-вывода или ожидания каналов).
- **Mutex Profile**: Показывает, где происходит борьба за мьютексы.


### Основные команды интерактивной оболочки `pprof`
- **`topN`** (где `N` — число): Показывает N самых ресурсоемких функций (по умолчанию 10). Эта команда полезна для быстрого выявления "горячих" точек в вашем коде. Например, `top20` покажет 20 наиболее затратных функций.
    
- **`list <regexp>`**: Отображает исходный код функций, имена которых соответствуют заданному регулярному выражению, с аннотациями, показывающими потребление ресурсов для каждой строки. Это незаменимо для детального анализа производительности конкретных участков кода. Например, `list main\.` покажет код функции `main`.
- **`web`**: Генерирует и открывает в веб-браузере SVG-граф вызовов функций. Этот визуальный инструмент значительно упрощает понимание потока выполнения программы и выявление узких мест. Это, пожалуй, одна из самых полезных команд для общего обзора профиля.
- **`tree`**: Отображает граф вызовов функций в текстовом виде. Удобно для быстрого просмотра иерархии вызовов без необходимости открывать браузер.
- **`peek <regexp>`**: Показывает профиль для функций, имена которых соответствуют регулярному выражению. Отличие от `list` в том, что `peek` дает более агрегированные данные о вызовах, а не построчный анализ.
- **`traces`**: Выводит все трассировки стека, связанные с текущим профилем. Полезно для понимания полных путей вызовов, которые привели к наблюдаемой активности.
- **`source <regexp>`**: Подобно `list`, но иногда может предоставлять более подробную информацию об исходном коде, особенно в сочетании с опциями отладки.
- **`disasm <regexp>`**: Дезассемблирует функции, соответствующие регулярному выражению, показывая потребление ресурсов на уровне ассемблерного кода. Это полезно для очень глубокого анализа производительности.
- **`help`**: Выводит список всех доступных команд и их краткое описание. Всегда полезно, если вы забыли конкретную команду или ищете новые возможности.
- **`quit`** или **`exit`**: Выходит из интерактивной оболочки `pprof`.

### Анализ диаграмм профилировщика

Анализ диаграмм профиля, генерируемых `pprof`, является ключевым шагом в оптимизации производительности. Различные типы профилей (CPU, память, блокировки и т.д.) и их визуализации (граф вызовов, Flame Graph, Top N) предоставляют разные ракурсы для выявления узких мест.


####  Граф вызовов (Call Graph) - `pprof web`

Это наиболее распространенный и интуитивно понятный способ анализа. При выполнении команды `web` `pprof` генерирует SVG-файл и открывает его в браузере.

- **Что это такое:** Визуализация, показывающая функции в виде прямоугольников и стрелки, обозначающие вызовы функций. Размер прямоугольника функции пропорционален количеству ресурсов, которые эта функция потребляет (например, времени CPU, памяти).
    
- **Как читать:**
    
    - **Размер прямоугольника:** Чем больше прямоугольник функции, тем больше ресурсов она потребляет. Это ваш первый индикатор потенциальных узких мест.
        
    - **Стрелки:** Стрелки показывают, какая функция вызывает другую. Толщина стрелки может указывать на частоту или объем вызовов.
        
    - **Цвет:** Цвет прямоугольника может варьироваться в зависимости от типа профиля. Например, в CPU-профиле более "горячие" (ресурсоемкие) функции могут быть окрашены в более насыщенные цвета.
        
    - **"Родители" и "Дети":** Функции, вызывающие другие, называются "родителями" (callers), а вызываемые — "детьми" (callees). Если у функции большой прямоугольник, но она вызывает много маленьких функций, это может означать, что проблема не в самой функции, а в функциях, которые она вызывает.
        
    - **"Горячие пути":** Ищите длинные или широкие "цепочки" вызовов, которые потребляют много ресурсов. Это может быть "горячий путь", который стоит оптимизировать.
        
- **Что искать:**
    - Функции с очень большими прямоугольниками.
    - Длинные цепочки вызовов, которые начинаются от часто вызываемых функций.
    - Неожиданные вызовы или зависимости.


####  Flame Graph (Пламенной график) - `pprof web` (опция Flame Graph)

Flame Graph — это специализированный тип графа вызовов, который отлично подходит для визуализации стеков вызовов и потребления ресурсов.

- **Что это такое:** Иерархическая визуализация, где каждая "коробка" представляет функцию в стеке вызовов. Ширина коробки пропорциональна количеству времени, которое функция провела в стеке вызовов (или другому ресурсу). "Дети" функции располагаются над "родителями".
    
- **Как читать:**
    
    - **Горизонтальная ось (ширина):** Представляет суммарное время, проведенное в функции (или потребленную память/другой ресурс), включая время, проведенное в ее дочерних вызовах. Чем шире коробка, тем больше ресурсов потребляет эта функция и все функции, которые она вызывает.
        
    - **Вертикальная ось (глубина):** Представляет стек вызовов. Каждая следующая "коробка" выше — это функция, вызванная функцией, расположенной ниже.
        
    - **Цвет:** Цвет обычно случайный и служит для лучшего визуального разделения функций. Некоторые реализации могут использовать цвет для обозначения типа функции или модуля.
        
    - **"Пламя":** Ищите "высокие" и "широкие" "пламена". Широкое "пламя" указывает на функцию, которая потребляет много ресурсов. Высокое "пламя" указывает на глубокие стеки вызовов.
        
    - **Интерактивность:** Во Flame Graph можно нажимать на функции, чтобы "зумировать" их и видеть детали их поддеревьев.
        
- **Что искать:**
    
    - **Широкие "пламена":** Указывают на функции или подсистемы, которые потребляют значительную долю ресурсов.
        
    - **"Прямоугольники" на самом верху "пламени":** Это функции, которые непосредственно выполняются (не вызывают другие функции), и их ширина показывает, сколько времени они сами по себе потребляют. Если такая функция широкая, она сама является узким местом.
        
    - **"Короткие" и "широкие" "пламена":** Могут указывать на рекурсию или циклы, где функция многократно вызывает саму себя или связанные функции.


#### Вид "Top N" (в текстовом или веб-режиме)

Это самый простой способ получить общее представление о наиболее ресурсоемких функциях.

- **Что это такое:** Таблица, которая показывает функции, отсортированные по убыванию потребления ресурсов.
    
- **Столбцы (могут варьироваться в зависимости от типа профиля):**
    
    - `flat`: Количество ресурсов, потребляемых непосредственно этой функцией, без учета вызовов дочерних функций.
    - `flat%`: Процент `flat` от общего объема профиля.
    - `sum%`: Накопленный процент `flat` (сумма `flat%` для этой функции и всех функций выше в списке).
    - `cum`: Кумулятивное (накопленное) количество ресурсов, потребляемых этой функцией, включая все вызовы дочерних функций.
    - `cum%`: Процент `cum` от общего объема профиля.
    - `calls`: Количество вызовов функции (не всегда доступно или полезно).
    - `name`: Имя функции.
        
- **Как анализировать:**
    
    - **Высокие значения `flat`:** Указывают на то, что сама функция является причиной высоких затрат. Оптимизация ее внутреннего кода может дать существенный эффект.
    - **Высокие значения `cum` при низком `flat`:** Означают, что функция сама по себе не потребляет много ресурсов, но она вызывает другие функции, которые являются ресурсоемкими. В этом случае нужно углубляться в функции, которые она вызывает.
    - **Сочетание `flat` и `cum`:** Сравнивайте `flat` и `cum`. Если `flat` близок к `cum`, функция является узким местом сама по себе. Если `flat` мал, а `cum` велик, то проблема в функциях, которые она вызывает.
        
- **Что искать:**
    
    - Функции с высокими `flat%` и `cum%`.
    - Функции с низким `flat%`, но очень высоким `cum%` — исследуйте их дочерние вызовы.


#### Профили памяти (Memory Profile - `heap`)

Профили памяти помогают выявить утечки памяти и функции, которые выделяют слишком много памяти.

- **Типы данных:**
    
    - **`inuse_space`:** Объем памяти, который в данный момент используется программой (после сборки мусора).
        
    - **`alloc_space`:** Общий объем памяти, который был выделен программой (включая уже освобожденную память).
        
    - **`inuse_objects`:** Количество объектов, которые в данный момент используются.
        
    - **`alloc_objects`:** Общее количество выделенных объектов.
        
- **Что искать:**
    
    - **`inuse_space` или `alloc_space`:** Большие значения указывают на потенциальные утечки или чрезмерное выделение памяти.
        
    - **`alloc_space` намного больше `inuse_space`:** Это может указывать на то, что программа выделяет много памяти, но затем быстро ее освобождает. Возможно, это не утечка, но все равно может быть неэффективным.
        
    - **Функции, которые постоянно появляются в профиле памяти:** Даже если они освобождают память, частое выделение/освобождение может привести к фрагментации или нагрузке на сборщик мусора.
        
    - **"Пики" на графиках памяти:** Указывают на временные, но значительные выделения памяти.


#### Профили блокировок (Block Profile - `block`)

Помогают выявить места, где goroutines блокируются, ожидая мьютексов, операций ввода-вывода или других событий.

- **Что искать:**
    
    - Функции, которые тратят много времени на блокировки. Это часто видно по вызовам `sync.Mutex.Lock`, `sync.RWMutex.RLock`, системных вызовов для ввода-вывода и т.д.
        
    - "Горячие" мьютексы, которые постоянно вызывают задержки. Возможно, потребуется пересмотреть стратегию блокировок или использовать более гранулярные блокировки.
        

---

### Общие советы по анализу:

- **Начинайте с обзора:** Всегда начинайте с `web` или `top` для получения общего представления, а затем углубляйтесь в детали с помощью `list`, `peek` или `source`.
    
- **Сравнивайте профили:** Если вы вносите изменения для оптимизации, делайте профили до и после изменений, а затем сравнивайте их, чтобы увидеть эффект. `pprof` поддерживает сравнение профилей.
    
- **Обращайте внимание на системные функции:** Функции из `runtime` или `syscall` могут быть значительными потребителями ресурсов. Это не всегда плохо (например, сборщик мусора), но если они занимают слишком много, это может указывать на проблемы в вашем коде, которые вызывают их чрезмерную активность.
    
- **Используйте фильтры:** В `pprof` можно фокусироваться на определенных функциях (`focus <regexp>`) или игнорировать их (`ignore <regexp>`), чтобы сузить область анализа.
    
- **Не оптимизируйте преждевременно:** Сосредоточьтесь на самых больших "горячих" точках. Оптимизация небольших функций, которые потребляют 1% ресурсов, не даст такого эффекта, как оптимизация функции, потребляющей 30%.
    
- **Повторяйте профилирование:** Производительность может меняться в зависимости от нагрузки и входных данных. Повторяйте профилирование в различных условиях.





