### при получении срезов из срезов

Иногда на практике приходится работать с большими объемами данных. Например, представьте, что в функцию передается срез данных размером в один гигабайт:
```go

func findSequence(data []byte) []byte {
	for i := 0; i < len(data)-1; i++ {
		if data[i] == 0xFF && data[i+1] == 0xEE {
			//имитация полезной работы свзянной с получением какого-либо среза
			return data[i+2 : i+12]
		}
	}

	return nil
}

func processBigData() {
	var data []byte
	// let's imagine that data (1GB) was read from a file

	sequence := findSequence(data)
	_ = sequence // using of sequence later
}
```
В этом примере функция findSequence возвращает срез размером всего 10 байт, который ссылается на исходный массив data (1 GB).

Несмотря на то что массив data больше не нужен, сборщик мусора не сможет его освободить, потому что новый срез sequence продолжает ссылаться на данные из исходного массива. Память, выделенная под массив, может быть освобождена только целиком, а не частично.

**Результат: утечка памяти на 1 GB — 10 B. Память остаётся занятой до тех пор, пока существует хотя бы одна ссылка на неё.**

**Решение**
Нужно перестать ссылаться на исходный срез. Достаточно скопировать всего 10 байт, чтобы сборщик мусора освободил большой участок памяти. Например, так:
```go
func findSequence(data []byte) []byte {
	for i := 0; i < len(data)-1; i++ {
		if data[i] == 0xFF && data[i+1] == 0xEE {
			copied := make([]byte, 10)     // инициализируем копию
			copy(copied, data)             // заполняем копию
			return copied                  // возвращаем копию 
		}
	}

	return nil
}

func processBigData() {
	var data []byte
	// let's imagine that data (1GB) was read from a file

	sequence := findSequence(data)
	_ = sequence // using of sequence later
}
```


### Утечки памяти при работе с вложенными срезами

Утечки памяти в Go могут возникать даже тогда, когда мы с использованием указателя ссылаемся на один элемент большого среза. Рассмотрим следующий пример:

```go
func findElement(data []int, target int) *int {
	for idx := range data {
		if data[idx] == target {
			return &data[idx]
		}
	}

	return nil
}

func processBigData() {
	var data []int
	// let's imagine that data (1GB) was read from a file

	pointer := findElement(data, 100_000)
	_ = pointer // using of sequence later
}
```

В этом примере мы возвращаем указатель. Он будет ссылаться только на один элемент исходного гигабайтного среза. Но после выполнения функции `findElement` сам исходный срез уже не нужен.

**Результат: утечка памяти на 8GB - 8B.**

**Решение**
Решение аналогично предыдущему примеру: перестаем ссылаться на исходный срез и копируем объект.


### Утечки памяти при работе с вложенными срезами

Рассмотрим ещё один интересный пример утечки памяти:
```go
type Data struct {
	values []byte
}

func getPartialData() []Data {
	data := make([]Data, 1000) // ~24KB
	for i := 0; i < len(data); i++ {
		data[i] = Data{
			values: make([]byte, 1<<20),
		}
	}

	return data[:2]
}
```

В этом примере я специально допускаю небольшую утечку памяти размером **24KB — 16B** и использую часть среза. Это решение связано с тем, что срез имеет небольшой размер, и такая утечка в некоторых ситуациях может не влиять на работу приложения (такое происходит не всегда).  
  
Но тут есть важная деталь. Сам срез действительно небольшой, но каждый его элемент содержит указатель на другой срез. Этот срез занимает уже 1MB памяти. Поэтому итоговая утечка будет не **24KB — 48B**, а **1GB + 24KB - 48B - 2MB**.


**Решение:**
1. Нужно либо перестать ссылаться на исходный срез и скопировать только 2 элемента;
2. Либо обнулить ненужные элементы массива. Если утечка памяти размером 24KB — 16B допустима, можно продолжать ссылаться на массив data, но важно обнулить элементы, которые больше не нужны:
```go
type Data struct {
	values []byte
}

func getPartialData() []Data {
	data := make([]Data, 1000) // ~24KB
	for i := 0; i < len(data); i++ {
		data[i] = Data{
			values: make([]byte, 1<<20),
		}
	}

    clear(data[2:])
	return data[:2]
}
```

### Условная утечка памяти при изменении размера среза

Этот пример иллюстрирует ситуацию, которая формально не является утечкой памяти, но может привести к неэффективному использованию ресурсов:

```go
func main() {
	size := 1 << 30
	data := make([]int, size)
	for i := 0; i < size; i++ {
		data[i] = i
	}

	// using big data

	data = data[:0]

	// further I will work only
	// with a small number of values
}
```

**Что происходит:**  
Создается массив размером 1 GB и срез data, ссылающийся на него.  

1. После обнуления длины среза (data = data[:0]) его размер становится 0, но емкость (capacity) остается прежней.
2. Несмотря на то что мы больше не используем весь массив, сборщик мусора не освобождает память, так как срез data продолжает ссылаться на исходный массив.

Когда мы работаем с большим срезом и устанавливаем его размер в ноль, делая его пустым, память в размере 1GB всё равно не будет очищена.


**Решение:**
1. Либо присвоить срезу nil. Так сборщик мусора сможет освободить память;
2. Либо уменьшить размер среза. Для этого самостоятельно выдели нужный объем памяти и перенеси туда данные из старого среза, а старый участок памяти в будущем освободит сборщик мусора, потому что на него не будет никто ссылаться.