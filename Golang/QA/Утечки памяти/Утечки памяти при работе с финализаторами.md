
Иногда при работе с Go нужно использовать CGO для аллокации памяти. Чтобы избежать утечек и не забыть освободить память, можно использовать финализаторы.  
  
Когда больше не останется указателей на созданный объект CString — сборщик мусора обнаружит его, вызовет финализатор и только на следующей итерации сборки мусора освободит память, как в примере ниже:

```go
type CString struct {
	cpointer *C.char
}

func Allocate() *CString {
	str := CString{cpointer: C.allocate()}
	runtime.SetFinalizer(str, func(ptr *CString) {
		C.free(ptr.cpointer)
	})

	return str
}
```

Также финализаторы помогают закрывать разные ресурсы. С их помощью можно автоматически закрывать файлы или сетевые соединения, чтобы ничего не забыть. Например, они применяются в стандартной библиотеке для работы с файлами:

```go
func newFile(fd int, name string, kind newFileKind, nonBlocking bool) *File {
	// other implementation of function

	runtime.SetFinalizer(f.file, (*file).close)
	return f
}
```

### Проблемы финализаторов: циклические ссылки

Несмотря на пользу, финализаторы имеют ограничения. Одна из основных проблем — невозможность корректно работать с циклическими ссылками. Рассмотрим пример:


```go
type Foo struct {
	bar *Bar
}

type Bar struct {
	foo *Foo
}

func main() {
	foo := &Foo{}
	bar := &Bar{}

	foo.bar = bar
	bar.foo = foo

	runtime.SetFinalizer(foo, func(ptr *Foo) {
		fmt.Println("finalizer called on addr", ptr, "value is", *ptr)
	})

	runtime.GC()
	time.Sleep(time.Second)
}
```

В этом примере между объектами foo и bar возникает циклическая ссылка: foo.bar указывает на bar, а bar.foo на foo. Сборщик мусора не сможет вызвать финализатор для foo, а память для объектов foo и bar не гарантируется, что будет освобождена. Это может привести к настоящей утечке памяти.

**Важно: Сборщик мусора в Go является трассирующим, поэтому он способен корректно обрабатывать циклические ссылки, если не используются финализаторы.**

Чтобы решить эту проблему, избегайте циклических ссылок при использовании финализаторов.


