
### База


#### Ошибки
- ошибки в golang - это значения, ошибку принято возвращать последним значением функции
-  `if err != nil` - от этого условия никуда не сбежать
- в основе работы ошибками находится интерфейс Error:
```go
 type error interface { 
 Error() string 
 }
```
Любая структура, у которой есть метод `Error()`, возвращающий строку, может считаться ошибкой




##### Создание своих ошибок: `errors.New` vs `fmt.Errorf`
- `errors.New("сообщение")`: Идеально для простых, статичных ошибок. Это как заготовленная табличка «Закрыто на учёт».
- `fmt.Errorf("шаблон %s", значение)`: хороший  выбор, когда в сообщение нужно добавить контекст. Это как написать на табличке: «Закрыто, потому что ленивый %s забыл ключи».

[[Работа с ошибками#^err|пример работы с ошибками]]


#### Паники
Иногда случаются вещи настолько плохие, что просто вернуть ошибку недостаточно. Программа заходит в состояние, из которого не может логически продолжаться. Это не «файл не найден». Это «фундамент здания исчез».
Для таких случаев в Go есть `panic`.

`panic` — это встроенная функция, которая останавливает обычное выполнение программы. Когда функция вызывает `panic`, её выполнение немедленно прекращается. Все отложенные вызовы (`defer`) выполняются, а затем программа завершается с грохотом, выводя на экран трассировку стека (stack trace).

Панику можно обработать и продолжить выполнение программы дальше. Для этого существует `recover`. `recover` — это встроенная функция, которая позволяет «перехватить» панику и восстановить нормальное выполнение.

**Важнейшее правило:** `recover` работает только внутри отложенных (`defer`) функций
[[Работа с ошибками#^panic|пример работы с паниками]]


### Продвинутая работа с ошибками 

#### Оборачивание ошибок (Error Wrapping)
Представьте цепочку событий: `main` вызывает `setup`, `setup` вызывает `readConfig`, а `readConfig` не находит файл. Мы хотим, чтобы ошибка, вернувшаяся в `main`, содержала всю эту историю.
Для этого используется директива `%w` в `fmt.Errorf`. Она «оборачивает» одну ошибку в другую.
[[Работа с ошибками#^wrapping|пример оборачивания ошибок]]

Также ошибку можно развернуть - получить самую первую ошибку которую, когда-то заворачивали в другие ошибки. Для этого применяется функция 
`errors.Unwrap(wrapped_err error) unwrapped error` 


#### Проверка ошибок: `errors.Is`
Как проверить, есть ли внутри "сборной матрешки из ошибок" самая маленькая, «Файл не найден»? Для этого есть `errors.Is(err, target error) bool`. Она просматривает всю цепочку вглубь.
[[Работа с ошибками#^errors-is|пример использования errors.Is()]]

#### Пользовательские типы ошибок и `errors.As`
Иногда нам нужно не просто проверить тип ошибки, но и получить из неё дополнительную информацию. Например, при сетевой ошибке нам может быть важен HTTP-статус код. Для этого мы создаём собственный тип ошибки. Далее прогоняем ошибку через `errors.As` и если ошибка относится к нужному нам типу, функция  предоставляет нам преобразованную ошибку в качестве второго аргумента.

`errors.As(err error, target any) bool` - проверяет, относится ли ошибка `err`  к кастомной структуре  ошибки `target`, или нет:
[[Работа с ошибками#^errors-as|пример использования errors.As()]]



### Примеры

#### Cоздание и возврат ошибки ^err
```go
package main

import (
	"errors"
	"fmt"
)

// divide делит одно число на другое.
// Возвращает результат и ошибку, если что-то пошло не так.
func divide(a, b float64) (float64, error) {
	if b == 0 {
		// Создаем новую, простую ошибку.
		return 0, errors.New("деление на ноль! Ты пытаешься сломать Вселенную?")
	}
	// Если все хорошо, возвращаем результат и nil в качестве ошибки.
	return a / b, nil
}

func main() {
	result, err := divide(10.0, 2.0)
	if err != nil {
		// О нет, ошибка! Обрабатываем ее.
		fmt.Println("Произошла катастрофа:", err)
	} else {
		fmt.Println("Все прошло гладко! Результат:", result)
	}

	fmt.Println("--- Попытка №2 ---")

	result, err = divide(10.0, 0)
	if err != nil {
		// Наш главный защитник - `if err != nil`
		fmt.Println("Произошла катастрофа:", err)
	} else {
		fmt.Println("Все прошло гладко! Результат:", result)
	}
}
```

#### Создание  и обработка паники ^panic
```go
package main

import "fmt"

func handleRequest() {
	// defer гарантирует, что эта функция выполнится в самом конце,
	// даже если (особенно если) произойдет паника.
	defer func() {
		// recover() вернет значение, переданное в panic, или nil, если паники не было.
		if r := recover(); r != nil {
			fmt.Println("Восстановлено после паники:", r)
			fmt.Println("Сервер продолжает жить, но администратору стоит выпить кофе и проверить логи.")
		}
	}()

	fmt.Println("Обработка запроса началась...")
	// Представим, что здесь может возникнуть паника
	causePanic("неправильный ID")
	fmt.Println("Обработка запроса успешно завершена (это сообщение не появится).")
}

func causePanic(reason string) {
	panic(fmt.Sprintf("Что-то ужасное случилось по причине: %s", reason))
}

func main() {
	handleRequest()
	fmt.Println("Программа завершилась штатно. Ура!")
}
```

#### Оборачивание ошибок ^wrapping
```go
package main

import (
	"errors"
	"fmt"
	"os"
)

// readConfig пытается прочитать конфигурацию.
func readConfig() error {
	// os.ErrNotExist - это стандартная ошибка в Go.
	err := os.ErrNotExist
	// Оборачиваем исходную ошибку в новый контекст.
	return fmt.Errorf("не удалось прочитать файл конфигурации: %w", err)
}

// setup настраивает приложение.
func setup() error {
	err := readConfig()
	if err != nil {
		// Оборачиваем еще раз, добавляя еще больше контекста.
		return fmt.Errorf("ошибка на этапе настройки сервиса: %w", err)
	}
	return nil
}

func main() {
	err := setup()
	if err != nil {
		fmt.Println("Полная цепочка ошибки:", err)
	}
}
// Вывод:
// Полная цепочка ошибки: ошибка на этапе настройки сервиса: не удалось прочитать файл конфигурации: file does not exist
```

#### Применение errors.Is() ^errors-is
```go
// Продолжение предыдущего примера...
package main

import (
	"errors"
	"fmt"
	"os"
)

// readConfig пытается прочитать конфигурацию.
func readConfig() error {
	// os.ErrNotExist - это стандартная ошибка в Go.
	err := os.ErrNotExist
	// Оборачиваем исходную ошибку в новый контекст.
	return fmt.Errorf("не удалось прочитать файл конфигурации: %w", err)
}

// setup настраивает приложение.
func setup() error {
	err := readConfig()
	if err != nil {
		// Оборачиваем еще раз, добавляя еще больше контекста.
		return fmt.Errorf("ошибка на этапе настройки сервиса: %w", err)
	}
	return nil
}


func main() {
	err := setup()
	if err != nil {
		fmt.Println("Полная ошибка:", err)

		// Проверяем, является ли причиной нашей проблемы именно отсутствие файла.
		if errors.Is(err, os.ErrNotExist) {
			fmt.Println("Ага! Проблема в том, что файл конфигурации отсутствует. Создам его по умолчанию.")
			// Здесь может быть логика создания дефолтного конфига.
		} else {
			fmt.Println("Произошла какая-то другая, неизвестная ошибка.")
		}
	}
}
```

#### Применение errors.As() ^errors-as
```go
package main

import (
	"errors"
	"fmt"
)

// NetworkError - наш собственный тип для сетевых ошибок.
type NetworkError struct {
	URL        string
	StatusCode int
	Msg        string
}

// Реализуем интерфейс error.
func (e *NetworkError) Error() string {
	return fmt.Sprintf("сетевая ошибка для %s: статус %d - %s", e.URL, e.StatusCode, e.Msg)
}

// fetchData имитирует получение данных из сети.
func fetchData() error {
	// Имитируем ошибку "Service Unavailable".
	return &NetworkError{
		URL:        "https://api.super-service.com/data",
		StatusCode: 503,
		Msg:        "Сервис временно недоступен",
	}
}

func main() {
	err := fetchData()

	var netErr *NetworkError
	// errors.As проверяет, есть ли в цепочке ошибка типа *NetworkError.
	// Если есть, она присваивает ее переменной netErr и возвращает true.
	if errors.As(err, &netErr) {
		fmt.Println("Это точно сетевая ошибка!")
		fmt.Printf("URL: %s\n", netErr.URL)
		fmt.Printf("Статус код: %d\n", netErr.StatusCode)

		if netErr.StatusCode == 503 {
			fmt.Println("План действий: попробовать еще раз через минуту.")
		}
	} else if err != nil {
		fmt.Println("Произошла ошибка неизвестного типа:", err)
	}
}
```