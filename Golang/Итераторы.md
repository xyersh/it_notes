Итераторы в Go - это не встроенная языковая конструкция, как в Python или Java. Вместо этого, они реализуются с помощью **функций, замыканий и каналов**. Такой подход даёт большую гибкость, но требует явной реализации.


### Зачем нужны итераторы?

Итераторы полезны, когда нужно **последовательно обрабатывать элементы** из большой коллекции, источника данных (например, файла, базы данных) или потока, не загружая все данные в память целиком. Это особенно актуально для:
- **Огромных массивов данных**, которые не помещаются в оперативную память.
- **Бесконечных последовательностей** (например, генератор чисел Фибоначчи).
- **Ленивых вычислений**, где данные генерируются по мере необходимости.


### Реализация итераторов в Go

#### Без использования пакета  iter

В Go до версии 1.23 итератор обычно представляет собой структуру, которая хранит состояние обхода, и метод `Next()`, который возвращает следующий элемент и булево значение, указывающее, есть ли ещё элементы.

#####  Пример 1: Простой итератор по массиву
Этот подход требует явного цикла `for` и проверки `ok`.
```go
package main

import (
	"fmt"
)

// StringIterator - структура итератора
type StringIterator struct {
	data  []string
	index int
}

// NewStringIterator - конструктор итератора
func NewStringIterator(data []string) *StringIterator {
	return &StringIterator{
		data:  data,
		index: 0,
	}
}

// Next - возвращает следующий элемент и булево значение (true, если есть еще элементы)
func (it *StringIterator) Next() (string, bool) {
	if it.index >= len(it.data) {
		return "", false
	}
	value := it.data[it.index]
	it.index++
	return value, true
}

func main() {
	names := []string{"Alice", "Bob", "Charlie"}
	it := NewStringIterator(names)

	for {
		name, ok := it.Next()
		if !ok {
			break
		}
		fmt.Println(name)
	}
}
```

#####  Пример 2: Итератор с использованием замыкания
Иногда итератор можно реализовать в виде функции, которая возвращает другую функцию (замыкание). Эта "внутренняя" функция будет хранить состояние и возвращать следующий элемент.
```go
package main

import "fmt"

// NewIteratorFunc возвращает функцию-итератор
func NewIteratorFunc(data []string) func() (string, bool) {
	index := 0
	return func() (string, bool) {
		if index >= len(data) {
			return "", false
		}
		value := data[index]
		index++
		return value, true
	}
}

func main() {
	names := []string{"Alice", "Bob", "Charlie"}
	it := NewIteratorFunc(names)

	for {
		name, ok := it()
		if !ok {
			break
		}
		fmt.Println(name)
	}
}
```

##### Пример 3: Итератор с использованием канала
Каналы (channels) - это мощный инструмент для итерации, особенно когда элементы генерируются в фоновом режиме (например, при чтении из сети или файла) .
**Преимущества:**
- **Параллелизм:** Генерация данных может происходить в отдельной горутине.
- **Простой цикл `for range`**: Код становится очень читабельным и похожим на итерацию по срезу или карте.
```go
package main

import (
	"fmt"
	"time"
)

// GenerateNumbers создает канал и отправляет в него числа с задержкой
func GenerateNumbers(count int) <-chan int {
	ch := make(chan int)
	go func() {
		defer close(ch)
		for i := 0; i < count; i++ {
			time.Sleep(100 * time.Millisecond) // Имитация задержки
			ch <- i
		}
	}()
	return ch
}

func main() {
	for num := range GenerateNumbers(5) {
		fmt.Println(num)
	}
}
```


#### Итераторы с применением пакета iter (go v:1.23)



До версии 1.23 цикл `for range` умел работать только со встроенными типами: слайсами, картами, строками и каналами. Теперь мы можем использовать `range` с функциями специального вида.
**Итератор** — это функция, которая принимает другую функцию (callback), называемую **yield**.
- Если `yield` возвращает `true`, итерация продолжается.
- Если `yield` возвращает `false`, итерация должна немедленно прекратиться (аналог `break`).

##### Принципы использования и типы

В стандартной библиотеке (пакет `iter`) определены два основных типа итераторов:
- **`iter.Seq[V]`** — для последовательностей с одним значением (например, только элемент).
- **`iter.Seq2[K, V]`** — для последовательностей с двумя значениями (например, индекс и элемент или ключ и значение).

##### Преимущества

- **Универсальность:** Можно обходить кастомные структуры данных (деревья, связанные списки), не раскрывая их внутреннее устройство.
- **Экономия памяти:** Итераторы позволяют обрабатывать данные лениво (по одному элементу), не создавая огромные промежуточные слайсы в памяти.
- **Композиция:** Итераторы легко комбинировать (фильтрация, маппинг), создавая цепочки обработки.

#####  Стандартная библиотека

Многие пакеты уже обновились для поддержки итераторов:

- **`slices`**: методы `All()`, `Values()`, `Backward()`.
    
- **`maps`**: методы `All()`, `Keys()`, `Values()`.
    
- **`strings` / `bytes`**: новые функции для разбиения строк через итераторы.


#####  Итерация с удвоением чисел в последовательности
```go
import (
	"fmt"
	"iter"
)

func NumsIter(max int) iter.Seq[int] {
	return func(yield func(int) bool) {
		for i := 0; i < max; i++ {
			if !yield(i*2) {
				return
			}
		}
	}
}

func main() {
	for val := range NumsIter(10) {
		fmt.Println(val)
	}
}
```


##### Итерация  только по четным числам последовательности
```go
package main

import (
	"fmt"
	"iter"
)

func NumsIter(max int) iter.Seq[int] {
	return func(yield func(int) bool) {
		for i := 0; i < max; i = i + 2 {
			if !yield(i) {
				return
			}
		}
	}
}

func main() {
	for val := range NumsIter(10) {
		fmt.Println(val)
	}
}
```


##### Итерация по слайсу в обратном порядке
Допустим, у нас есть список, который мы хотим обойти в обратном порядке.
```go
package main

import (
	"fmt"
	"iter"
)

func Backwards[V any](s []V) iter.Seq[V] {
	return func(yield func(V) bool) {
		for i := len(s) - 1; i >= 0; i-- {
			if !yield(s[i]) {
				return
			}
		}
	}
}

func main() {
	sl := []int{1, 2, 3, 4, 5, 6}
	for val := range Backwards(sl) {
		fmt.Println(val)
	}
}
```

##### Бесконечный итератор и ленивые вычисления

Итераторы идеально подходят для генерации последовательностей, например, чисел Фибоначчи.
```go
package main

import (
	"fmt"
	"iter"
)

func Fibonacci() iter.Seq[int] {
	return func(yield func(int) bool) {
		a, b := 0, 1
		for {
			if !yield(a) {
				return
			}
			a, b = b, a+b
		}
	}
}

func main() {
	fmt.Print("Первые 7 чисел Фибоначчи: ")
	count := 0
	for n := range Fibonacci() {
		if count >= 7 {
			break // yield вернет false внутри итератора
		}
		fmt.Printf("%d ", n)
		count++
	}
}
```


##### Использование стандартного пакета `maps`
```go
package main

import (
	"fmt"
	"maps"
	"slices"
)

func main() {
	m := map[string]int{"Go": 2009, "Rust": 2010, "Python": 1991}

	// Получаем итератор ключей, превращаем в слайс и сортируем
	keys := slices.Collect(maps.Keys(m))
	slices.Sort(keys)

	for _, k := range keys {
		fmt.Printf("%s: %d\n", k, m[k])
	}
}
```



##### Конвейеры итераторов (Iterators Pipelines)
Принцип работы конвейера прост: одна функция-итератор принимает другой итератор в качестве входного параметра и возвращает новый итератор, который модифицирует или фильтрует поток данных.

Практический пример: Фильтрация и Трансформация
Ниже представлен рабочий код, где мы создаем цепочку:
1. **Источник** (слайс)
2. **Фильтр** (оставляем только четные числа)
3. **Маппер** (возводим числа в квадрат)
```go
package main

import (
	"fmt"
	"iter"
	"slices"
)

// Filter — принимает итератор и возвращает новый, содержащий только элементы, 
// удовлетворяющие условию f.
func Filter[V any](seq iter.Seq[V], f func(V) bool) iter.Seq[V] {
	return func(yield func(V) bool) {
		for v := range seq {
			if f(v) {
				// Если yield возвращает false, значит цикл range снаружи прерван
				if !yield(v) {
					return
				}
			}
		}
	}
}

// Map — трансформирует каждый элемент итератора из типа V в тип R.
func Map[V, R any](seq iter.Seq[V], f func(V) R) iter.Seq[R] {
	return func(yield func(R) bool) {
		for v := range seq {
			if !yield(f(v)) {
				return
			}
		}
	}
}

func main() {
	nums := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}

	// 1. Берем значения из слайса через slices.Values
	source := slices.Values(nums)

	// 2. Оставляем только четные
	evens := Filter(source, func(n int) bool {
		return n%2 == 0
	})

	// 3. Возводим в квадрат
	squares := Map(evens, func(n int) int {
		return n * n
	})

	fmt.Println("Квадраты четных чисел:")
	for val := range squares {
		fmt.Printf("%d ", val)
	}
	// Вывод: 4 16 36 64 100
}
```