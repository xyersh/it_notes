Итераторы в Go - это не встроенная языковая конструкция, как в Python или Java. Вместо этого, они реализуются с помощью **функций, замыканий и каналов**. Такой подход даёт большую гибкость, но требует явной реализации.


### Зачем нужны итераторы?

Итераторы полезны, когда нужно **последовательно обрабатывать элементы** из большой коллекции, источника данных (например, файла, базы данных) или потока, не загружая все данные в память целиком. Это особенно актуально для:
- **Огромных массивов данных**, которые не помещаются в оперативную память.
- **Бесконечных последовательностей** (например, генератор чисел Фибоначчи).
- **Ленивых вычислений**, где данные генерируются по мере необходимости.


### Реализация итераторов в Go

#### Без использования пакета  iter

В Go до версии 1.23 итератор обычно представляет собой структуру, которая хранит состояние обхода, и метод `Next()`, который возвращает следующий элемент и булево значение, указывающее, есть ли ещё элементы.

#####  Пример 1: Простой итератор по массиву
Этот подход требует явного цикла `for` и проверки `ok`.
```go
package main

import (
	"fmt"
)

// StringIterator - структура итератора
type StringIterator struct {
	data  []string
	index int
}

// NewStringIterator - конструктор итератора
func NewStringIterator(data []string) *StringIterator {
	return &StringIterator{
		data:  data,
		index: 0,
	}
}

// Next - возвращает следующий элемент и булево значение (true, если есть еще элементы)
func (it *StringIterator) Next() (string, bool) {
	if it.index >= len(it.data) {
		return "", false
	}
	value := it.data[it.index]
	it.index++
	return value, true
}

func main() {
	names := []string{"Alice", "Bob", "Charlie"}
	it := NewStringIterator(names)

	for {
		name, ok := it.Next()
		if !ok {
			break
		}
		fmt.Println(name)
	}
}
```

#####  Пример 2: Итератор с использованием замыкания
Иногда итератор можно реализовать в виде функции, которая возвращает другую функцию (замыкание). Эта "внутренняя" функция будет хранить состояние и возвращать следующий элемент.
```go
package main

import "fmt"

// NewIteratorFunc возвращает функцию-итератор
func NewIteratorFunc(data []string) func() (string, bool) {
	index := 0
	return func() (string, bool) {
		if index >= len(data) {
			return "", false
		}
		value := data[index]
		index++
		return value, true
	}
}

func main() {
	names := []string{"Alice", "Bob", "Charlie"}
	it := NewIteratorFunc(names)

	for {
		name, ok := it()
		if !ok {
			break
		}
		fmt.Println(name)
	}
}
```

##### Пример 3: Итератор с использованием канала
Каналы (channels) - это мощный инструмент для итерации, особенно когда элементы генерируются в фоновом режиме (например, при чтении из сети или файла) .
**Преимущества:**
- **Параллелизм:** Генерация данных может происходить в отдельной горутине.
- **Простой цикл `for range`**: Код становится очень читабельным и похожим на итерацию по срезу или карте.
```go
package main

import (
	"fmt"
	"time"
)

// GenerateNumbers создает канал и отправляет в него числа с задержкой
func GenerateNumbers(count int) <-chan int {
	ch := make(chan int)
	go func() {
		defer close(ch)
		for i := 0; i < count; i++ {
			time.Sleep(100 * time.Millisecond) // Имитация задержки
			ch <- i
		}
	}()
	return ch
}

func main() {
	for num := range GenerateNumbers(5) {
		fmt.Println(num)
	}
}
```


#### Итераторы с применением пакета iter (go v:1.23)

Пакет `iter` вводит новый **протокол итераторов**. Теперь итератор — это любой тип, у которого есть метод `Next()`, возвращающий следующий элемент. Этот подход позволяет стандартному циклу `for` взаимодействовать с итераторами напрямую, без необходимости использовать каналы или замыкания.