
### БАЗА

####  Причины использования бенчмарков
- **Оптимизация производительности:** Найти и улучшить медленные участки кода.
- **Контроль регрессий:** Убедиться, что новые изменения не ухудшили производительность.
- **Сравнение алгоритмов:** Объективно оценить эффективность разных подходов.
- **Прогнозирование масштабируемости:** Оценить поведение приложения под нагрузкой.
- **Принятие обоснованных решений:** Использовать данные для принятия решений об оптимизации.


#### Основные положения:
- `testing` - основной пакет для тестирования 
- файлы с тестами должны содержать название тестируемого пакета  и оканчиваться на   ***_test.go*
- Тестосвые файлы должны находиться в том же пакете, или ином пакете, назване которого содержит название тестируемого пакета + суффикс **_test** 
- Тестовые функции должны начинаться на **Test** и далее, содержать в названии имя тестируемой функции 
- Тестовые функции должны содержать 1 аргумент  `t  *testing.T`

#### `*testing.T` - что за зверь такой?
Это указатель на структуру `testing.T`, которая является основным типом для управления юнит-тестами в Golang. Она предоставляет методы для сообщения о статусе теста (успех/неудача), логирования информации, создания подтестов и управления их выполнением. Каждая тестовая функция в Go принимает аргумент типа `*testing.T`.

##### Методы структуры testing.T
- **`func (t *T) Error(args ...any)`**
    - **Назначение:** Сообщает об ошибке в тесте, но **продолжает** выполнение текущей тестовой функции.
    - **Пример:** `t.Error("Something went wrong")`
        
- **`func (t *T) Errorf(format string, args ...any)`**
    - **Назначение:** То же, что и `Error`, но с форматированием строки (аналогично `fmt.Printf`).
    - **Пример:** `t.Errorf("Expected %d, got %d", expected, actual)`
        
- **`func (t *T) Fail()`**
    - **Назначение:** Помечает текущий тест как неудачный, но **продолжает** выполнение текущей тестовой функции.
    - **Пример:** `if !condition { t.Fail() }`
        
- **`func (t *T) FailNow()`**
    - **Назначение:** Помечает текущий тест как неудачный и **немедленно прекращает** выполнение текущей тестовой функции. После вызова `FailNow` последующий код в этой тестовой функции не будет выполнен.
    - **Пример:** `if err != nil { t.FailNow() }`
        
- **`func (t *T) Fatal(args ...any)`**
    - **Назначение:** Сообщает об ошибке и вызывает `t.FailNow()`. Эквивалентно `t.Error()` с последующим `t.FailNow()`.
    - **Пример:** `t.Fatal("Critical error, stopping test")`
        
- **`func (t *T) Fatalf(format string, args ...any)`**
    - **Назначение:** То же, что и `Fatal`, но с форматированием строки (аналогично `fmt.Printf`).
    - **Пример:** `t.Fatalf("Failed to initialize: %v", err)`
        
- **`func (t *T) Log(args ...any)`**
    - **Назначение:** Выводит сообщение на стандартный вывод, но **не помечает** тест как неудачный.
    - **Пример:** `t.Log("Debugging info: variable X is", x)`
    - **Поведение:** Используется для отладочных сообщений или информации, которая не является ошибкой. Вывод отображается только при запуске с флагом `-v` (`go test -v`).
        
- **`func (t *T) Logf(format string, args ...any)`**
    - **Назначение:** То же, что и `Log`, но с форматированием строки.
    - **Пример:** `t.Logf("Processing item %d", i)`
    - **Поведение:** Используется для отладочных сообщений.
        
- **`func (t *T) Skip(args ...any)`**
    - **Назначение:** Помечает тест как пропущенный. Выводятся сообщения о пропущенных тестах.
    - **Пример:** `if !externalServiceAvailable { t.Skip("Skipping test: external service not available") }`
        
- **`func (t *T) Skipf(format string, args ...any)`**
    - **Назначение:** То же, что и `Skip`, но с форматированием строки.
    - **Пример:** `t.Skipf("Test requires feature '%s', which is disabled", featureName)`
        
- **`func (t *T) Skipped() bool`**
    - **Назначение:** Возвращает `true`, если тест был пропущен (т.е. был вызван `t.Skip` или `t.Skipf`).
    - **Пример:** `if t.Skipped() { return }`
        
- **`func (t *T) Parallel()`**
    - **Назначение:** Помечает текущий тест (или подтест) как готовый к параллельному выполнению с другими параллельными тестами.
    - **Пример:** `func TestMyParallelFunction(t *testing.T) { t.Parallel(); /* ... */ }`
    - **Поведение:** Тесты, помеченные `Parallel()`, будут запущены одновременно, когда все непараллельные тесты завершатся. Важно убедиться, что параллельные тесты не имеют состояний гонки и изолированы друг от друга.
        
- **`func (t *T) Run(name string, f func(t *T))`**
    - **Назначение:** Запускает новую горутину для выполнения подтеста. Это позволяет структурировать тесты, запускать части тестов независимо и выполнять их параллельно.
    - **Пример:**

        ```go
        t.Run("Subtest1", func(t *testing.T) {
            // ...
        })
        t.Run("Subtest2", func(t *testing.T) {
            t.Parallel() // Этот подтест может быть запущен параллельно
            // ...
        })
        ```
        
    - **Поведение:** Подтесты отображаются в выводе как `ParentTest/SubtestName`. Можно запускать отдельные подтесты с помощью флага `-run`.
        
- **`func (t *T) Name() string`**
    - **Назначение:** Возвращает полное имя текущего теста или подтеста.
    - **Пример:** `t.Log("Running test:", t.Name())`
    - **Поведение:** Полезно для отладки или логирования.
        
- **`func (t *T) TempDir() string`**
    - **Назначение:** Возвращает путь к временному каталогу, который будет автоматически удален после завершения теста. Идеально подходит для тестов, которые создают временные файлы.
    - **Пример:** `tmpDir := t.TempDir()`
    - **Поведение:** Упрощает управление временными ресурсами, предотвращая утечки.

##### Сводная таблица методов `*testing.T`
| Метод                             | Назначение                                                     | Поведение при ошибке | Останавливает тест? |
| --------------------------------- | -------------------------------------------------------------- | -------------------- | ------------------- |
| `Error(args ...)`                 | Сообщить об ошибке                                             | Неудача              | Нет                 |
| `Errorf(format string, args ...)` | Сообщить об ошибке (с форматированием)                         | Неудача              | Нет                 |
| `Fail()`                          | Пометить тест как неудачный                                    | Неудача              | Нет                 |
| `FailNow()`                       | Пометить тест как неудачный и немедленно остановить            | Неудача              | Да                  |
| `Fatal(args ...)`                 | Сообщить об ошибке и немедленно остановить                     | Неудача              | Да                  |
| `Fatalf(format string, args ...)` | Сообщить об ошибке (с форматированием) и немедленно остановить | Неудача              | Да                  |
| `Log(args ...)`                   | Вывести сообщение (только при `-v`)                            | Нет                  | Нет                 |
| `Logf(format string, args ...)`   | Вывести сообщение (с форматированием, только при `-v`)         | Нет                  | Нет                 |
| `Skip(args ...)`                  | Пропустить тест                                                | Пропущен             | Да (по сути)        |
| `Skipf(format string, args ...)`  | Пропустить тест (с форматированием)                            | Пропущен             | Да (по сути)        |
| `Skipped() bool`                  | Проверить, был ли тест пропущен                                | N/A                  | N/A                 |
| `Parallel()`                      | Разрешить параллельное выполнение подтеста                     | N/A                  | N/A                 |
| `Run(name string, f func(t *T))`  | Запустить подтест                                              | Зависит от подтеста  | Нет                 |
| `Name() string`                   | Получить имя текущего теста/подтеста                           | N/A                  | N/A                 |
| `TempDir() string`                | Создать временный каталог, удаляемый после теста               | N/A                  | N/A                 |

#### Table Driven Testing
Основан на организации набора тестовых случаев в виде структуры данных (таблицы), а затем итерировать по этой таблице, выполняя один и тот же тестовый код для каждого случая. 
Позволяет не создавать отдельную тестовую функцию для каждого сценария, вы создаете одну общую тестовую функцию и снабжаете её данными, которые описывают различные входные параметры, ожидаемые результаты и, возможно, даже имена тестовых случаев.

**TDT** хорош по следующим причинам
- **Чистота и читаемость кода:** Все тестовые сценарии собраны в одном месте, что делает тест более компактным и легким для понимания. Вы сразу видите, какие комбинации входных данных и ожидаемых результатов проверяются.
    
- **Простота добавления новых случаев:** Хотите добавить новый тестовый сценарий? Просто допишите новую строку в таблице данных, и все! Вам не нужно дублировать логику теста.
    
- **Уменьшение дублирования кода:** Основная логика проверки выполняется один раз в цикле, а не повторяется для каждого сценария.
    
- **Улучшенная организация:** Помогает поддерживать порядок в ваших тестовых файлах, особенно когда у функции много возможных состояний или комбинаций входных данных.
    
- **Интеграция с `t.Run`:** В Go табличные тесты прекрасно сочетаются с методом `t.Run()`, что позволяет запускать каждый тестовый случай как отдельный подтест. Это улучшает отчетность: вы точно видите, какой именно тестовый случай провалился.


### паралельное тестирование
По умолчанию тесты в Go исполняются последовательно. Чтобы запустить конкретный тест параллельно с другими, следует добавить в него метод `t.Parallel()`.

Утилита `go test` приостанавливает тесты, содержащие метод `t.Parallel()` , и возобновляет их после завершения непараллельных тестов. Стоит отметить, что количество тестов, способных исполнятся параллельно в единицу времени, определяет рассмотренный нами в предыдущей статье параметр `GOMAXPROCS` .

Тест можно сделать параллельным, добавив всего две строки – это вызов `t.Parallel()` в начале теста и внутри метода `t.Run()`,


### Полезные команды оболочки 
- `go test` - запускает тесты и бенчмарки
- `go test ./...` - запуск тестов всего модуля
- `go test -v` - запуск тестов в подробном режиме (verbose). Будут отражены все сообщения, выведенные методами `t.Log()`, `t.Logf()`. Будет отражено название каждого запущенного теста и его результат (PASS/FAIL/SKIP).
- `go test -run <regexp>` - запуск лишь тех тестов, название которых соответствует заданному регулярному выражению
	- `go test -run TestAdd` - запустить тесты ,начинающиеся с `TestAdd`
	- `go test -run TestAddMultipleCases/zero` -  запустить конкретный подтест
- `go test -race ./...` - включает детектор состояния гонки повсему модулю. 
	- Детектор гонки замедляет выполнение тестов, но его использование обязательно для любых приложений, активно использующих параллелизм. Он выводит подробную информацию о найденных гонках данных.
- `go test -cover` - Выводит **процент покрытия кода** тестами
- `go test -coverprofile=coverage.out` - Сохраняет необработанные данные о покрытии в указанный файл. После создания `coverage.out`, вы можете сгенерировать интерактивный HTML-отчет:
	- `go tool cover -html=coverage.out`
- `go test -count=1` - Принудительно запускает тесты, **игнорируя кэшированные результаты**. По умолчанию `go test` кэширует успешные результаты тестов, чтобы ускорить последующие запуски.
- `go test -timeout <duration>` - Установка таймаута для тестов.
	- `go test -timeout 30s`
	- `go test -timeout 5m`
- `go test -json` - Выводит результаты тестов в **формате JSON**, что очень удобно для автоматической обработки результатов CI/CD-системами или другими инструментами.


### Примеры



### Примитивный пример
Допустим, у нас есть функция `Add` в файле `math.go`:
```go
// math.go
package math_ops

func Add(a, b int) int {
    return a + b
}
```

Простой скрипт теста будет выглядеть следующим образом:
```go
// math_test.go
package math_ops

import "testing"

func TestAdd(t *testing.T) {
    result := Add(2, 3)
    expected := 5

    if result != expected {
        t.Errorf("Add(2, 3) = %d; expected %d", result, expected)
    }
}
```


#### Table Driven  - подход
```go
package math_ops

import "testing"

func TestAdd(t *testing.T) {
    // 1. Определяем таблицу тестовых случаев
    tests := []struct {
        name     string // Имя тестового случая для t.Run
        a, b     int    // Входные параметры
        expected int    // Ожидаемый результат
    }{
        {"positive numbers", 2, 3, 5},
        {"negative numbers", -2, -3, -5},
        {"mixed numbers", 2, -3, -1},
        {"zero values", 0, 0, 0},
        {"large numbers", 1000, 2000, 3000},
    }

    // 2. Итерируем по таблице
    for _, tt := range tests {
        // 3. Запускаем каждый случай как подтест с помощью t.Run
        // Это позволяет Go показывать результаты для каждого сценария отдельно
        t.Run(tt.name, func(t *testing.T) {
            // 4. Выполняем тестируемую функцию
            result := Add(tt.a, tt.b)

            // 5. Сравниваем фактический результат с ожидаемым
            if result != tt.expected {
                t.Errorf("Add(%d, %d) = %d; expected %d", tt.a, tt.b, result, tt.expected)
            }
        })
    }
}
```

#### Тестирование с ошибками (Error Handling)
При тестировании функций, которые могут возвращать ошибки, важно проверять не только успешные сценарии, но и корректность обработки ошибок.

Допустим, у нас есть функция `Divide` в `math.go`, которая возвращает ошибку при делении на ноль.
```go
// math.go (дополнение)
package math_ops

import "errors"

func Divide(a, b int) (int, error) {
    if b == 0 {
        return 0, errors.New("cannot divide by zero")
    }
    return a / b, nil
}
```


```go
// math_test.go (дополнение)
package math_ops

import (
    "errors"
    "testing"
)

func TestDivide(t *testing.T) {
    tests := []struct {
        name        string
        a, b        int
        expected    int
        expectedErr error
    }{
        {"valid division", 10, 2, 5, nil},
        {"divide by zero", 10, 0, 0, errors.New("cannot divide by zero")},
        {"negative result", 10, -2, -5, nil},
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            result, err := Divide(tt.a, tt.b)

            if tt.expectedErr != nil {
                if err == nil {
                    t.Errorf("Expected error but got none")
                } else if err.Error() != tt.expectedErr.Error() {
                    t.Errorf("Expected error %v, got %v", tt.expectedErr, err)
                }
            } else {
                if err != nil {
                    t.Errorf("Did not expect an error but got %v", err)
                }
                if result != tt.expected {
                    t.Errorf("Divide(%d, %d) = %d; expected %d", tt.a, tt.b, result, tt.expected)
                }
            }
        })
    }
}
```

### Паралельное тестирование 

```go
package main

func IsEven(input int) string {
	if input%2 == 0 {
		return "Even"
	}
	return "Odd"
}
```


```go 
func TestIsEvenParallel(t *testing.T) {
	t.Parallel() // помечает тест как параллельный
	var testcases = []struct {
		text  string
		input int
		want  string
	}{
		{"-1 - нечетное число", -1, "Odd"},
		{"0 - четное число", 0, "Even"},
		{"1 - нечетное число", 1, "Odd"},
		{"2 - четное число", 2, "Even"},
	}

	for _, tc := range testcases {
		t.Run(tc.text, func(t *testing.T) {
			t.Parallel() // помечает тест-кейс как параллельный
			result := IsEven(tc.input)
			if result != tc.want {
				t.Errorf("got %s, want %s", result, tc.want)
			}
		})
	}
}
```

