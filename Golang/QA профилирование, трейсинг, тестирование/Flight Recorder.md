**Flight Recorder** – это мощный инструмент для наблюдения (Observability), впервые официально представленный в **Go 1.25** (ранее доступный в экспериментальном пакете `golang.org/x/exp/trace`). Он позволяет собирать детальные данные трассировки выполнения программы Go, используя механизм **циклического буфера** (ring buffer)

### Что такое Flight Recorder и для чего он используется?

#### 1. Объяснение работы

**Flight Recorder** (буквально "бортовой самописец") работает по принципу **скользящего окна** или **кругового буфера**. Представьте это как камеру наблюдения, которая непрерывно записывает видео, но сохраняет только **самые последние** несколько минут (или определенный объем данных).
- **Непрерывная запись:** Он постоянно собирает данные трассировки (события Go-рантайма, активности горутин, блокировки, системные вызовы) с **минимальными накладными расходами** (благодаря улучшениям трассировки, внесенным в Go 1.21/1.22).
- **Циклический буфер:** Старые данные в буфере **автоматически удаляются**, освобождая место для новых.
- **Снимок по требованию:** Только когда происходит что-то **интересное** (например, таймаут, ошибка, необъяснимое замедление), вы вызываете метод для **сохранения (дампа) текущего содержимого буфера** в файл трассировки (`.trace`).
    

#### 2. Для чего используется (Сценарии применения)

Flight Recorder — это специализированный инструмент, который особенно полезен в **производственной среде** для решения сложных, трудновоспроизводимых проблем:
- **Отладка в продакшене:** Захват состояния приложения непосредственно **перед** или **во время** редкой, критической ошибки или сбоя, который невозможно воспроизвести локально.
- **Периодические проблемы с производительностью:** Отслеживание нерегулярных проблем, таких как внезапное замедление запросов или таймауты, когда обычное непрерывное трассирование слишком затратно.
- **Легкое наблюдение:** Поддержание некоторого уровня наблюдения в средах с ограниченной памятью, где невозможно позволить себе накладные расходы на полномасштабное, постоянное сохранение логов трассировки.
    

### Преимущества перед другими инструментами трассировки

Flight Recorder не заменяет полностью традиционные инструменты, а дополняет их, предлагая уникальные преимущества, особенно по сравнению с традиционной трассировкой Go (`trace.Start`/`trace.Stop`) и непрерывной записью:

| Особенность                | Flight Recorder                                                                                                                 | Традиционная Трассировка (`trace.Start`/`Stop`)                                        |
| -------------------------- | ------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------- |
| **Накладные расходы**      | **Очень низкие** (непрерывно включен, но данные не записываются на диск)                                                        | **Выше** (данные непрерывно записываются и обрабатываются)                             |
| **Хранение данных**        | Использует **циклический буфер** в памяти. Хранит только _последнее_ окно активности.                                           | Сохраняет _всю_ историю выполнения за период трассировки.                              |
| **Размер файлов**          | **Маленький** (фиксированный размер буфера).                                                                                    | **Может быть очень большим** (зависит от времени работы).                              |
| **Удобство использования** | Идеально для **случайных, непредсказуемых** событий. Вам не нужно знать, _когда_ проблема произойдет, чтобы начать трассировку. | Требует, чтобы вы знали, _когда_ начать и остановить трассировку.                      |
| **Снимок**                 | **Снимок по событию** (`WriteTo`) — мгновенно сохраняется состояние непосредственно перед триггером.                            | **Снимок по времени** (`Stop`) — вы захватываете все, что произошло с момента `Start`. |


### Показательный рабочий пример использования Flight Recorder

В этом примере мы создадим простую программу, которая работает некоторое время. Мы смоделируем "интересное" событие (например, таймаут) и используем **Flight Recorder**, чтобы сохранить трассировку, охватывающую активность непосредственно перед этим событием.


```go
package main

import (
	"context"
	"fmt"
	"log"
	"os"
	"sync"
	"time"

	"runtime/trace" // Встроенный пакет для Flight Recorder
)

// Global Flight Recorder instance
var fr *trace.FlightRecorder

// writeTrace сохраняет текущее окно Flight Recorder в файл.
func writeTrace(filename string) error {
	f, err := os.Create(filename)
	if err != nil {
		return fmt.Errorf("ошибка при создании файла трассировки: %w", err)
	}
	defer f.Close()

	n, err := fr.WriteTo(f)
	if err != nil {
		return fmt.Errorf("ошибка при записи трассировки: %w", err)
	}

	log.Printf("✅ Трассировка записана в %s (%d байт)", filename, n)
	return nil
}

// simulateWork имитирует фоновую работу, которую мы хотим отслеживать
func simulateWork(ctx context.Context, wg *sync.WaitGroup, name string, delay time.Duration) {
	defer wg.Done()

	// Запуск трассируемой задачи
	taskCtx, task := trace.NewTask(ctx, name)
	defer task.End()

	log.Printf("[%s] Запуск задачи...", name)
	select {
	case <-time.After(delay):
		trace.Log(taskCtx, "work_complete", "Задача завершена успешно")
		log.Printf("[%s] Задача завершена.", name)
	case <-ctx.Done():
		trace.Log(taskCtx, "work_interrupted", "Задача прервана")
		log.Printf("[%s] Задача прервана.", name)
	}
}

func main() {
	// 1. Создание и запуск Flight Recorder
	// Указываем конфигурацию: сохранять данные минимум за последние 5 секунд.
	cfg := trace.FlightRecorderConfig{
		MinAge: 5 * time.Second,
		// MaxBytes: 10 * 1024 * 1024, // Можно ограничить размер буфера в байтах
	}

	fr = trace.NewFlightRecorder(cfg)

	// fr.Start() запускает низкоуровневый сбор данных трассировки в циклический буфер.
	if err := fr.Start(); err != nil {
		log.Fatalf("❌ Ошибка при запуске Flight Recorder: %v", err)
	}
	defer fr.Stop() // Остановка сбора данных при завершении программы

	log.Println("--- Flight Recorder запущен. Непрерывная трассировка активности... ---")

	// Симуляция длительной работы (горутина 1)
	wg := sync.WaitGroup{}
	wg.Add(1)
	go simulateWork(context.Background(), &wg, "Task-A", 10*time.Second)

	// Симуляция работы, которая завершится ошибкой (горутина 2)
	wg.Add(1)
	errorCtx, cancelError := context.WithCancel(context.Background())
	go simulateWork(errorCtx, &wg, "Task-B-Bad", 7*time.Second)

	// Имитация 12 секунд работы, прежде чем произойдет "сбой"
	time.Sleep(12 * time.Second)

	// 2. Имитация "интересного" события (сбоя) и захват трассировки
	log.Println("\n--- Имитация критической ошибки или таймаута! Захват трассировки... ---")

	// Предполагаемая ошибка: отмена контекста для "Task-B-Bad"
	cancelError() 

	// Захват последних 5 секунд активности.
	if err := writeTrace("flight_trace.out"); err != nil {
		log.Println("❌ Не удалось сохранить трассировку:", err)
	}

	// Ждем завершения первой задачи для чистого выхода
	wg.Wait()
	log.Println("--- Программа завершена. ---")
	log.Println("Для анализа запустите: go tool trace flight_trace.out")
}
```


### Как запустить и проанализировать

1. **Сохраните** код выше в файл `main.go`.
2. **Запустите** программу:
    
    
```bash
    go run main.go
```
    
3. После завершения в текущей папке появится файл `flight_trace.out`.
4. **Проанализируйте** трассировку с помощью встроенного инструмента Go:
    
```bash
    go tool trace flight_trace.out
```
    
Этот инструмент откроет веб-интерфейс в вашем браузере, где вы сможете визуально увидеть, что делали горутины (Task-A и Task-B-Bad) непосредственно перед тем, как произошла отмена контекста, и что было записано в файл трассировки.