
Одной из частых причин утечек памяти в Go являются утечки горутин, особенно при неправильной работе с каналами. Рассмотрим пример, где происходит утечка при чтении из канала:

```go
func printMessages(messagesCh chan string) {
	for message := range messagesCh {
		fmt.Println(message)
	}
}

func processMessages(messages []string) {
	messagesCh := make(chan string)
	go printMessages(messagesCh)

	for _, message := range messages {
		messagesCh <- message
	}
}
```

Что происходит:  
1. Мы записываем сообщения из среза messages в последовательном порядке.  
2. Затем горутина, которую мы создали, блокируется.

Это происходит потому, что:  

- В канал больше никто не пишет.
- Канал никто не закрывает.

<pre>
Результат:  
- В памяти остаются данные заблокированной горутины (например, её стек и метаинформация);
- Канал тоже занимает память. Сборщик мусора его не освободит, так как на канал ссылается заблокированная горутина.
</pre>


Чтобы избежать этой проблемы, необходимо закрыть канал, когда запись в него завершена.

### Утечки при записи в канал

Утечки могут происходить не только при чтении из канала, но и при записи в канал. Рассмотрим пример:

```go
func doQuery(string) string {
	return "" // imitation of long remote query
}

func doDistributedQuery(queries []string) string {
	resultCh := make(chan string)
	for _, query := range queries {
		go func() {
			result := doQuery(query)
			resultCh <- result
		}()
	}

	return <-resultCh
}
```

Что происходит в этом примере?  

1. Мы создаём канал resultCh для передачи результата от одной из горутин.
2. Для каждого значения из queries создаём горутину, которая выполняет запрос и записывает результат в канал.
3. Однако в функции doDistributedQuery мы возвращаем только первое значение из канала (<-resultCh), то есть в этом примере только одна горутина сможет записать данные в канал.

  
Значение из канала будет прочитано один раз внутри функции. Все другие горутины, которые попытаются записать в канал после этого, останутся заблокированными навсегда. Это приведет к утечкам, так как заблокированные горутины продолжат ссылаться на канал, как и в примере с чтением.

**Решение:**  
- сделать канал буферизированным, установив буфер равным len(queries) - 1.
- либо писать в канал без блокировки, используя select, чтобы избежать блокировки:
```go
func doQuery(string) string {
	return "" // imitation of long remote query
}

func doDistributedQuery(queries []string) string {
	resultCh := make(chan string, 1)
	for _, query := range queries {
		go func() {
			result := doQuery(query)
			select {
			case resultCh <- result:
			default:
			}
		}()
	}

	return <-resultCh
}
```

При использовании второго решения, если запись в канал не может пройти сразу, будет выбрана ветка в select по умолчанию. Выполнение записи без блокировки гарантирует, что ни одна из запущенных в цикле горутин не останется бесконечно висеть. Канал можно не закрывать, так как он, как и другие объекты, будет очищен сборщиком мусора.  
  
При использовании select нам все равно нужен буфферизированный канал с размером не более единицы. Если запись пройдет до того, как функция doDistributedQuery начнет читать из канала, что маловероятно, отправка может не удастся. Это произойдет, потому что никто еще не готов, и для всех горутин в select будет выбрана ветка по умолчанию.  
  
Утечки данных горутин еще могут происходить при неправильном использовании контекстов и при работе с time. Ticker до версии Go 1.23. Однако внутри их используются каналы, поэтому мы не будем отдельно рассматривать эти случаи. Примеры утечек с time. Ticker и контекстами будут похожи на примеры утечек данных горутин при работе с каналами.  
  
Утечки данных горутин могут возникать не только при работе с каналами, но и при неправильном использовании примитивов синхронизации из пакета sync. Например, горутина или несколько горутин могут заблокироваться навсегда, если неправильно использовать один мьютекс:

```go
func process() {
	var mutex sync.Mutex
	go func() {
		mutex.Lock()
		mutex.Lock() // endless waiting
	}()
}
```

Или, например, так, используя несколько мьютексов:

```go
func validate(lhs, rhs *sync.Mutex) {
	lhs.Lock()
	rhs.Lock()
}

func process() {
	var mutex1 sync.Mutex
	var mutex2 sync.Mutex

	// potential deadlock - the order in
	// which mutexes are captured is violated

	go validate(&mutex1, &mutex2)
	go validate(&mutex2, &mutex1)
}
```