### 1. Что такое Circuit Breaker?

Представьте себе обычный электрический предохранитель в вашем доме. Когда происходит скачок напряжения, он размыкает цепь, чтобы защитить ваши электроприборы от сгорания.

Паттерн **Circuit Breaker** в программировании работает по схожему принципу. Это механизм защиты, который предотвращает повторные вызовы к сервису, который, вероятно, неисправен или недоступен. Вместо того чтобы бесконечно пытаться достучаться до упавшего сервиса и тратить на это ресурсы, "предохранитель" временно разрывает соединение и возвращает ошибку немедленно.

### 2. Какие проблемы решает?

В распределенных системах (например, микросервисах) один сервис часто зависит от другого. Если один из сервисов (назовем его "Сервис Б") перестает отвечать, то "Сервис А", который к нему обращается, может столкнуться со следующими проблемами:

- **Истощение ресурсов:** "Сервис А" будет продолжать отправлять запросы к "Сервису Б", тратя на это сетевые соединения, потоки, процессорное время и память. Если таких запросов много, это может привести к отказу уже самого "Сервиса А".
- **Увеличение времени ответа (Latency):** Пользователи "Сервиса А" будут испытывать долгие задержки, пока система тщетно пытается дождаться ответа от "Сервиса Б".
- **Каскадные сбои (Cascading Failures):** Проблемы в одном сервисе могут лавинообразно распространиться на всю систему. Если "Сервис А" перестает работать из-за проблем с "Сервисом Б", то сервисы, зависящие от "Сервиса А", также выйдут из строя.

**Circuit Breaker решает эти проблемы,** позволяя системе быстро реагировать на сбои и изолировать их, не допуская коллапса всей архитектуры.

### 3. Состояния Circuit Breaker

Паттерн имеет три основных состояния:

1. **Closed (Замкнуто):** Нормальное состояние. Все запросы свободно проходят к удаленному сервису. "Предохранитель" подсчитывает количество неудачных вызовов. Если число ошибок превышает заданный порог за определенное время, он переходит в состояние `Open`.
2. **Open (Разомкнуто):** "Предохранитель" разорвал цепь. Все запросы к сервису немедленно блокируются и возвращается ошибка, без реальной попытки вызова. Через определенный таймаут "предохранитель" переходит в состояние `Half-Open`.
3. **Half-Open (Полуоткрыто):** Проверочное состояние. "Предохранитель" позволяет пройти одному или нескольким тестовым запросам к сервису.
    - **Если запрос успешен:** "Предохранитель" считает, что сервис восстановился, и переходит в состояние `Closed`.
    - **Если запрос неудачен:** "Предохранитель" возвращается в состояние `Open` и снова запускает таймер ожидания.

### 4. Нюансы использования

- **Настройка порогов (Thresholds):** Самая сложная часть — правильно настроить параметры:
    - **Порог ошибок:** Сколько неудачных вызовов должно произойти, чтобы "разомкнуть" цепь? Слишком низкое значение может привести к ложным срабатываниям, а слишком высокое — не защитит от реальных проблем.
    - **Таймаут в состоянии Open:** Как долго ждать перед переходом в `Half-Open`? Слишком короткий таймаут не даст сервису времени на восстановление, а слишком долгий увеличит время простоя.
    - **Количество тестовых запросов:** Сколько успешных вызовов в `Half-Open` состоянии считать достаточным для полного восстановления?
- **Логирование и мониторинг:** Критически важно отслеживать смену состояний "предохранителя". Это дает понимание о здоровье зависимых сервисов.
- **Fallback-логика:** Что делать, когда цепь разомкнута? Просто вернуть ошибку — это уже хорошо. Но еще лучше предоставить альтернативный результат (fallback): например, вернуть кэшированные данные или значение по умолчанию.
- **Один предохранитель на экземпляр или на тип сервиса?** Если у вас несколько экземпляров одного и того же сервиса, стоит подумать: использовать один общий Circuit Breaker для всех или отдельный для каждого экземпляра.



### 5. Примеры на Golang

В Go нет встроенного Circuit Breaker, но есть множество отличных библиотек. Рассмотрим популярную `sony/gobreaker`.
Установка
```bash
go get github.com/sony/gobreaker
```

#### Пример 1: Простой вызов

Этот пример имитирует вызов к внешнему сервису, который иногда возвращает ошибку.

```go
package main

import (
	"errors"
	"fmt"
	"log"
	"time"

	"github.com/sony/gobreaker"
)

var cb *gobreaker.CircuitBreaker

func init() {
	// Настройки нашего "предохранителя"
	var settings gobreaker.Settings
	settings.Name = "HTTP-GET-Service"
	// Порог для открытия цепи - 5 последовательных ошибок
	settings.MaxRequests = 1
	// Таймаут перед переходом в Half-Open
	settings.Timeout = 10 * time.Second
	// Порог для открытия цепи
	settings.ReadyToTrip = func(counts gobreaker.Counts) bool {
		return counts.ConsecutiveFailures > 5
	}
	// Логирование смены состояний
	settings.OnStateChange = func(name string, from gobreaker.State, to gobreaker.State) {
		log.Printf("CircuitBreaker '%s' changed state from '%s' to '%s'\n", name, from, to)
	}

	cb = gobreaker.NewCircuitBreaker(settings)
}

// Имитация нестабильного внешнего сервиса
var requestCounter = 0

func getUnstableData() (string, error) {
	requestCounter++
	// Первые 6 вызовов будут неудачными
	if requestCounter <= 6 {
		return "", errors.New("service is currently unavailable")
	}
	// После этого сервис "восстанавливается"
	return "Hello from remote service!", nil
}

func main() {
	for i := 0; i < 15; i++ {
		body, err := cb.Execute(func() (interface{}, error) {
			// Оборачиваем наш вызов в Execute
			return getUnstableData()
		})

		if err != nil {
			log.Printf("Попытка %d: Ошибка: %v", i+1, err)
		} else {
			log.Printf("Попытка %d: Успех: %s", i+1, body.(string))
		}
		time.Sleep(1 * time.Second)
	}
}
```

**Что происходит в коде:**

1. Мы создаем `CircuitBreaker` с настройками: он перейдет в состояние `Open` после 5 последовательных ошибок.
2. В цикле мы 15 раз пытаемся выполнить функцию `getUnstableData` через `cb.Execute`.
3. Первые 6 вызовов `getUnstableData` возвращают ошибку. После 5-й ошибки "предохранитель" сработает и перейдет в `Open`.
4. 6-й вызов вернет ошибку немедленно, без реального вызова функции (это и есть работа Circuit Breaker).
5. Далее "предохранитель" будет в состоянии `Open` в течение 10 секунд. Все запросы в этот период будут мгновенно отклонены.
6. По истечении таймаута он перейдет в `Half-Open`. Следующий вызов будет тестовым. Поскольку `getUnstableData` уже "восстановился", вызов будет успешным.
7. "Предохранитель" вернется в состояние `Closed`, и последующие запросы снова будут проходить нормально.