
### Что это такое?
**Изящное закрытие** решает  проблемы потери данных, поврежденных состояний, ресурсных утечек  при закрытии приложения, предоставляя приложению время и возможность корректно завершить свою работу перед фактическим завершением процесса. Это включает в себя:
- **Завершение обработки текущих запросов:** Приложение перестает принимать новые запросы, но дожидается завершения уже выполняющихся.
- **Освобождение ресурсов:** Закрываются сетевые соединения, файлы, дескрипторы, отменяются таймеры и другие ресурсы.
- **Сохранение состояния:** При необходимости, приложение может сохранить свое текущее состояние, чтобы его можно было восстановить после перезапуска.
- **Уведомление зависимых сервисов:** Приложение может уведомить другие сервисы о своем скором завершении, чтобы они могли подготовиться.

Таким образом, изящное закрытие повышает надежность и стабильность приложения, предотвращает потерю данных и обеспечивает более плавный процесс перезапуска или обновления.

### Как реализовать изящное закрытие?
Реализация изящного закрытия обычно включает в себя следующие шаги:

1. **Перехват сигналов операционной системы:** Приложение должно отслеживать сигналы, которые указывают на необходимость завершения работы (например, `SIGINT` при нажатии `Ctrl+C` или `SIGTERM` при использовании команды `kill`).
2. **Блокировка приема новых запросов:** Как только получен сигнал на завершение, приложение должно перестать принимать новые входящие соединения или задачи.
3. **Ожидание завершения текущих операций:** Приложение должно дождаться завершения всех уже запущенных процессов, таких как обработка HTTP-запросов, выполнение фоновых задач и т.д.
4. **Освобождение ресурсов:** После завершения всех активных операций приложение должно корректно освободить все используемые ресурсы.
5. **Завершение работы:** После того как все задачи выполнены и ресурсы освобождены, приложение может безопасно завершить свой процесс.

```go
package main

import (
	"context"
	"fmt"
	"net/http"
	"os"
	"os/signal"
	"syscall"
	"time"
)

func main() {
	// Определяем обработчик для нашего HTTP-запроса
	http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
		fmt.Fprintf(w, "Привет от сервера!")
	})

	// Создаем HTTP-сервер
	srv := &http.Server{
		Addr:    ":8080",
		Handler: nil, // Используем дефолтный ServeMux
	}

	// Канал для приема сигналов завершения
	quit := make(chan os.Signal, 1)
	// Подписываемся на сигналы SIGINT и SIGTERM
	signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)

	// Запускаем HTTP-сервер в отдельной горутине
	go func() {
		fmt.Println("Сервер запущен на http://localhost:8080")
		if err := srv.ListenAndServe(); err != http.ErrServerClosed {
			fmt.Printf("Ошибка при запуске сервера: %v\n", err)
		}
	}()

	// Ожидаем сигнала завершения
	<-quit
	fmt.Println("Получен сигнал на завершение...")

	// Создаем контекст с тайм-аутом для изящного завершения
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	// Пытаемся изящно завершить работу сервера
	if err := srv.Shutdown(ctx); err != nil {
		fmt.Printf("Ошибка при изящном завершении сервера: %v\n", err)
	}

	fmt.Println("Сервер успешно остановлен.")
}
```

**Разберем этот пример:**

1. **Импорт необходимых пакетов:** `net/http` для создания HTTP-сервера, `os` и `os/signal` для работы с системными сигналами, `syscall` для определения конкретных сигналов, `context` для управления временем завершения и `time` для работы со временем.
2. **Создание HTTP-сервера:** Мы создаем простой HTTP-сервер, который отвечает "Привет от сервера!" на корневом пути.
3. **Канал для сигналов:** Создается канал `quit` типа `os.Signal` с буфером размером 1. Этот канал будет использоваться для приема сигналов завершения. Для большинства сценарием замера буфера  = 1 является достаточным.
4. **Подписка на сигналы:** Функция `signal.Notify` регистрирует канал `quit` для приема сигналов `syscall.SIGINT` (обычно генерируется при нажатии `Ctrl+C`) и `syscall.SIGTERM` (обычно используется командами `kill`).
5. **Запуск сервера в горутине:** HTTP-сервер запускается в отдельной горутине, чтобы основной поток мог продолжать выполнение и ожидать сигнала завершения. `srv.ListenAndServe()` блокирует выполнение, пока сервер не будет остановлен или не произойдет ошибка.
6. **Ожидание сигнала:** Основной поток блокируется на `<-quit` до тех пор, пока в канал `quit` не поступит сигнал.
7. **Создание контекста с тайм-аутом:** После получения сигнала создается контекст `ctx` с тайм-аутом в 5 секунд. Это означает, что сервер попытается завершить работу в течение этого времени. Если за это время все запросы не будут обработаны, сервер будет принудительно остановлен.
8. **Изящное завершение сервера:** Вызывается метод `srv.Shutdown(ctx)`, который пытается изящно завершить работу HTTP-сервера. Он перестает принимать новые соединения и ждет завершения всех активных запросов. Контекст с тайм-аутом контролирует время ожидания.
9. **Обработка ошибок:** Проверяется ошибка, возвращаемая `srv.Shutdown(ctx)`.
10. **Завершение программы:** После успешного или неудачного завершения сервера выводится соответствующее сообщение.

**Как запустить и протестировать этот пример:**

1. Сохраните код в файл `main.go`.
2. Откройте терминал и перейдите в каталог с файлом.
3. Выполните команду `go run main.go`. Вы увидите сообщение "Сервер запущен на http://localhost:8080".
4. Откройте браузер и перейдите по адресу `http://localhost:8080`. Вы должны увидеть "Привет от сервера!".
5. Вернитесь в терминал и нажмите `Ctrl+C`. Вы должны увидеть сообщения "Получен сигнал на завершение..." и "Сервер успешно остановлен.".

Если вы не нажмете `Ctrl+C`, а просто закроете терминал, сервер может завершиться не изящно.
